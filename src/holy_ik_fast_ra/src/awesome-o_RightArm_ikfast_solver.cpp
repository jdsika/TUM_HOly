/// autogenerated analytical inverse kinematics code from ikfast program part of OpenRAVE
/// \author Rosen Diankov
///
/// Licensed under the Apache License, Version 2.0 (the "License");
/// you may not use this file except in compliance with the License.
/// You may obtain a copy of the License at
///     http://www.apache.org/licenses/LICENSE-2.0
/// 
/// Unless required by applicable law or agreed to in writing, software
/// distributed under the License is distributed on an "AS IS" BASIS,
/// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
/// See the License for the specific language governing permissions and
/// limitations under the License.
///
/// ikfast version 0x10000048 generated on 2015-06-12 09:04:49.433696
/// To compile with gcc:
///     gcc -lstdc++ ik.cpp
/// To compile without any main function as a shared object (might need -llapack):
///     gcc -fPIC -lstdc++ -DIKFAST_NO_MAIN -DIKFAST_CLIBRARY -shared -Wl,-soname,libik.so -o libik.so ik.cpp
#define IKFAST_HAS_LIBRARY
#include "ikfast.h" // found inside share/openrave-X.Y/python/ikfast.h
using namespace ikfast;

// check if the included ikfast version matches what this file was compiled with
#define IKFAST_COMPILE_ASSERT(x) extern int __dummy[(int)x]
IKFAST_COMPILE_ASSERT(IKFAST_VERSION==0x10000048);

#include <cmath>
#include <vector>
#include <limits>
#include <algorithm>
#include <complex>

#ifndef IKFAST_ASSERT
#include <stdexcept>
#include <sstream>
#include <iostream>

#ifdef _MSC_VER
#ifndef __PRETTY_FUNCTION__
#define __PRETTY_FUNCTION__ __FUNCDNAME__
#endif
#endif

#ifndef __PRETTY_FUNCTION__
#define __PRETTY_FUNCTION__ __func__
#endif

#define IKFAST_ASSERT(b) { if( !(b) ) { std::stringstream ss; ss << "ikfast exception: " << __FILE__ << ":" << __LINE__ << ": " <<__PRETTY_FUNCTION__ << ": Assertion '" << #b << "' failed"; throw std::runtime_error(ss.str()); } }

#endif

#if defined(_MSC_VER)
#define IKFAST_ALIGNED16(x) __declspec(align(16)) x
#else
#define IKFAST_ALIGNED16(x) x __attribute((aligned(16)))
#endif

#define IK2PI  ((IkReal)6.28318530717959)
#define IKPI  ((IkReal)3.14159265358979)
#define IKPI_2  ((IkReal)1.57079632679490)

#ifdef _MSC_VER
#ifndef isnan
#define isnan _isnan
#endif
#ifndef isinf
#define isinf _isinf
#endif
//#ifndef isfinite
//#define isfinite _isfinite
//#endif
#endif // _MSC_VER

// lapack routines
extern "C" {
  void dgetrf_ (const int* m, const int* n, double* a, const int* lda, int* ipiv, int* info);
  void zgetrf_ (const int* m, const int* n, std::complex<double>* a, const int* lda, int* ipiv, int* info);
  void dgetri_(const int* n, const double* a, const int* lda, int* ipiv, double* work, const int* lwork, int* info);
  void dgesv_ (const int* n, const int* nrhs, double* a, const int* lda, int* ipiv, double* b, const int* ldb, int* info);
  void dgetrs_(const char *trans, const int *n, const int *nrhs, double *a, const int *lda, int *ipiv, double *b, const int *ldb, int *info);
  void dgeev_(const char *jobvl, const char *jobvr, const int *n, double *a, const int *lda, double *wr, double *wi,double *vl, const int *ldvl, double *vr, const int *ldvr, double *work, const int *lwork, int *info);
}

using namespace std; // necessary to get std math routines

#ifdef IKFAST_NAMESPACE
namespace IKFAST_NAMESPACE {
#endif

inline float IKabs(float f) { return fabsf(f); }
inline double IKabs(double f) { return fabs(f); }

inline float IKsqr(float f) { return f*f; }
inline double IKsqr(double f) { return f*f; }

inline float IKlog(float f) { return logf(f); }
inline double IKlog(double f) { return log(f); }

// allows asin and acos to exceed 1
#ifndef IKFAST_SINCOS_THRESH
#define IKFAST_SINCOS_THRESH ((IkReal)2e-6)
#endif

// used to check input to atan2 for degenerate cases
#ifndef IKFAST_ATAN2_MAGTHRESH
#define IKFAST_ATAN2_MAGTHRESH ((IkReal)2e-6)
#endif

// minimum distance of separate solutions
#ifndef IKFAST_SOLUTION_THRESH
#define IKFAST_SOLUTION_THRESH ((IkReal)1e-6)
#endif

// there are checkpoints in ikfast that are evaluated to make sure they are 0. This threshold speicfies by how much they can deviate
#ifndef IKFAST_EVALCOND_THRESH
#define IKFAST_EVALCOND_THRESH ((IkReal)0.000005)
#endif


inline float IKasin(float f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return float(-IKPI_2);
else if( f >= 1 ) return float(IKPI_2);
return asinf(f);
}
inline double IKasin(double f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return -IKPI_2;
else if( f >= 1 ) return IKPI_2;
return asin(f);
}

// return positive value in [0,y)
inline float IKfmod(float x, float y)
{
    while(x < 0) {
        x += y;
    }
    return fmodf(x,y);
}

// return positive value in [0,y)
inline double IKfmod(double x, double y)
{
    while(x < 0) {
        x += y;
    }
    return fmod(x,y);
}

inline float IKacos(float f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return float(IKPI);
else if( f >= 1 ) return float(0);
return acosf(f);
}
inline double IKacos(double f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return IKPI;
else if( f >= 1 ) return 0;
return acos(f);
}
inline float IKsin(float f) { return sinf(f); }
inline double IKsin(double f) { return sin(f); }
inline float IKcos(float f) { return cosf(f); }
inline double IKcos(double f) { return cos(f); }
inline float IKtan(float f) { return tanf(f); }
inline double IKtan(double f) { return tan(f); }
inline float IKsqrt(float f) { if( f <= 0.0f ) return 0.0f; return sqrtf(f); }
inline double IKsqrt(double f) { if( f <= 0.0 ) return 0.0; return sqrt(f); }
inline float IKatan2Simple(float fy, float fx) {
    return atan2f(fy,fx);
}
inline float IKatan2(float fy, float fx) {
    if( isnan(fy) ) {
        IKFAST_ASSERT(!isnan(fx)); // if both are nan, probably wrong value will be returned
        return float(IKPI_2);
    }
    else if( isnan(fx) ) {
        return 0;
    }
    return atan2f(fy,fx);
}
inline double IKatan2Simple(double fy, double fx) {
    return atan2(fy,fx);
}
inline double IKatan2(double fy, double fx) {
    if( isnan(fy) ) {
        IKFAST_ASSERT(!isnan(fx)); // if both are nan, probably wrong value will be returned
        return IKPI_2;
    }
    else if( isnan(fx) ) {
        return 0;
    }
    return atan2(fy,fx);
}

template <typename T>
struct CheckValue
{
    T value;
    bool valid;
};

template <typename T>
inline CheckValue<T> IKatan2WithCheck(T fy, T fx, T epsilon)
{
    CheckValue<T> ret;
    ret.valid = false;
    ret.value = 0;
    if( !isnan(fy) && !isnan(fx) ) {
        if( IKabs(fy) >= IKFAST_ATAN2_MAGTHRESH || IKabs(fx) > IKFAST_ATAN2_MAGTHRESH ) {
            ret.value = IKatan2Simple(fy,fx);
            ret.valid = true;
        }
    }
    return ret;
}

inline float IKsign(float f) {
    if( f > 0 ) {
        return float(1);
    }
    else if( f < 0 ) {
        return float(-1);
    }
    return 0;
}

inline double IKsign(double f) {
    if( f > 0 ) {
        return 1.0;
    }
    else if( f < 0 ) {
        return -1.0;
    }
    return 0;
}

template <typename T>
inline CheckValue<T> IKPowWithIntegerCheck(T f, int n)
{
    CheckValue<T> ret;
    ret.valid = true;
    if( n == 0 ) {
        ret.value = 1.0;
        return ret;
    }
    else if( n == 1 )
    {
        ret.value = f;
        return ret;
    }
    else if( n < 0 )
    {
        if( f == 0 )
        {
            ret.valid = false;
            ret.value = (T)1.0e30;
            return ret;
        }
        if( n == -1 ) {
            ret.value = T(1.0)/f;
            return ret;
        }
    }

    int num = n > 0 ? n : -n;
    if( num == 2 ) {
        ret.value = f*f;
    }
    else if( num == 3 ) {
        ret.value = f*f*f;
    }
    else {
        ret.value = 1.0;
        while(num>0) {
            if( num & 1 ) {
                ret.value *= f;
            }
            num >>= 1;
            f *= f;
        }
    }
    
    if( n < 0 ) {
        ret.value = T(1.0)/ret.value;
    }
    return ret;
}

/// solves the forward kinematics equations.
/// \param pfree is an array specifying the free joints of the chain.
IKFAST_API void ComputeFk(const IkReal* j, IkReal* eetrans, IkReal* eerot) {
IkReal x0,x1,x2,x3,x4,x5,x6,x7,x8,x9;
x0=IKsin(j[1]);
x1=IKcos(j[1]);
x2=IKcos(j[0]);
x3=IKsin(j[2]);
x4=IKcos(j[2]);
x5=IKsin(j[0]);
x6=((0.0707296823218818)*x1);
x7=((0.997495519808809)*x1);
x8=((0.0707296823218818)*x0);
x9=((0.997495519808809)*x0);
eerot[0]=(((x4*(((((-1.0)*x8))+(((-1.0)*x7))))))+((x3*(((((-1.0)*x6))+x9)))));
eerot[1]=(((x4*(((((-1.0)*x2*x6))+((x2*x9))))))+((x3*((((x2*x8))+((x2*x7)))))));
eerot[2]=(((x4*((((x5*x9))+(((-1.0)*x5*x6))))))+((x3*((((x5*x7))+((x5*x8)))))));
}

IKFAST_API int GetNumFreeParameters() { return 1; }
IKFAST_API int* GetFreeParameters() { static int freeparams[] = {2}; return freeparams; }
IKFAST_API int GetNumJoints() { return 3; }

IKFAST_API int GetIkRealSize() { return sizeof(IkReal); }

IKFAST_API int GetIkType() { return 0x23000004; }

class IKSolver {
public:
IkReal j15,cj15,sj15,htj15,j15mul,j16,cj16,sj16,htj16,j16mul,j17,cj17,sj17,htj17,new_r00,r00,rxp0_0,new_r01,r01,rxp0_1,new_r02,r02,rxp0_2;
unsigned char _ij15[2], _nj15,_ij16[2], _nj16,_ij17[2], _nj17;

IkReal j100, cj100, sj100;
unsigned char _ij100[2], _nj100;
bool ComputeIk(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions) {
j15=numeric_limits<IkReal>::quiet_NaN(); _ij15[0] = -1; _ij15[1] = -1; _nj15 = -1; j16=numeric_limits<IkReal>::quiet_NaN(); _ij16[0] = -1; _ij16[1] = -1; _nj16 = -1;  _ij17[0] = -1; _ij17[1] = -1; _nj17 = 0; 
for(int dummyiter = 0; dummyiter < 1; ++dummyiter) {
    solutions.Clear();
j17=pfree[0]; cj17=cos(pfree[0]); sj17=sin(pfree[0]);
r00 = eerot[0];
r01 = eerot[1];
r02 = eerot[2];
new_r00=((-1.0)*r02);
new_r01=r01;
new_r02=r00;
r00 = new_r00; r01 = new_r01; r02 = new_r02; {
IkReal j15eval[1];
j15eval[0]=((IKabs(r01))+(IKabs(r00)));
if( IKabs(j15eval[0]) < 0.0000010000000000  )
{
{
IkReal j16eval[1];
j16eval[0]=((sj17*sj17)+(cj17*cj17));
if( IKabs(j16eval[0]) < 0.0000010000000000  )
{
continue; // no branches [j15, j16]

} else
{
{
IkReal j16array[2], cj16array[2], sj16array[2];
bool j16valid[2]={false};
_nj16 = 2;
IkReal x10=((((-0.0707296823218818)*cj17))+(((0.997495519808809)*sj17)));
IkReal x11=((((-0.997495519808809)*cj17))+(((-0.0707296823218818)*sj17)));
CheckValue<IkReal> x14 = IKatan2WithCheck(IkReal(x11),x10,IKFAST_ATAN2_MAGTHRESH);
if(!x14.valid){
continue;
}
IkReal x12=((1.0)*(x14.value));
if((((x10*x10)+(x11*x11))) < -0.00001)
continue;
CheckValue<IkReal> x15=IKPowWithIntegerCheck(IKabs(IKsqrt(((x10*x10)+(x11*x11)))),-1);
if(!x15.valid){
continue;
}
if( ((r02*(x15.value))) < -1-IKFAST_SINCOS_THRESH || ((r02*(x15.value))) > 1+IKFAST_SINCOS_THRESH )
    continue;
IkReal x13=IKasin((r02*(x15.value)));
j16array[0]=((((-1.0)*x12))+x13);
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
j16array[1]=((3.14159265358979)+(((-1.0)*x12))+(((-1.0)*x13)));
sj16array[1]=IKsin(j16array[1]);
cj16array[1]=IKcos(j16array[1]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
if( j16array[1] > IKPI )
{
    j16array[1]-=IK2PI;
}
else if( j16array[1] < -IKPI )
{    j16array[1]+=IK2PI;
}
j16valid[1] = true;
for(int ij16 = 0; ij16 < 2; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 2; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];

{
IkReal j15eval[3];
IkReal x16=(cj16*cj17);
IkReal x17=(cj17*sj16);
IkReal x18=(sj16*sj17);
IkReal x19=(cj16*sj17);
j15eval[0]=((((-1.0)*x18))+x16+(((-14.1029266223667)*x17))+(((-14.1029266223667)*x19)));
j15eval[1]=IKsign(((((0.0707296823218818)*x16))+(((-0.0707296823218818)*x18))+(((-0.997495519808809)*x19))+(((-0.997495519808809)*x17))));
j15eval[2]=((IKabs(r01))+(IKabs(r00)));
if( IKabs(j15eval[0]) < 0.0000010000000000  || IKabs(j15eval[1]) < 0.0000010000000000  || IKabs(j15eval[2]) < 0.0000010000000000  )
{
{
IkReal j15eval[3];
IkReal x20=((707303176.795451)*cj17);
IkReal x21=((9975044802.11314)*sj17);
IkReal x22=((10000089829.0)*r02*sj16);
IkReal x23=(((cj16*(r01*r01)))+((cj16*(r00*r00))));
j15eval[0]=x23;
j15eval[1]=IKsign(x23);
j15eval[2]=((IKabs(((((-1.0)*r01*x20))+(((-1.0)*r01*x22))+((r01*x21)))))+(IKabs(((((-1.0)*r00*x21))+((r00*x22))+((r00*x20))))));
if( IKabs(j15eval[0]) < 0.0000010000000000  || IKabs(j15eval[1]) < 0.0000010000000000  || IKabs(j15eval[2]) < 0.0000010000000000  )
{
{
IkReal j15eval[3];
IkReal x24=((9975044802.11314)*cj17);
IkReal x25=((707303176.795451)*sj17);
IkReal x26=((10000089829.0)*cj16*r02);
IkReal x27=(((sj16*(r00*r00)))+((sj16*(r01*r01))));
j15eval[0]=x27;
j15eval[1]=((IKabs(((((-1.0)*r00*x24))+(((-1.0)*r00*x25))+(((-1.0)*r00*x26)))))+(IKabs((((r01*x26))+((r01*x24))+((r01*x25))))));
j15eval[2]=IKsign(x27);
if( IKabs(j15eval[0]) < 0.0000010000000000  || IKabs(j15eval[1]) < 0.0000010000000000  || IKabs(j15eval[2]) < 0.0000010000000000  )
{
{
IkReal evalcond[3];
bool bgotonextstatement = true;
do
{
IkReal x28=((((-0.997495519808809)*cj17))+(((-1.0)*r02))+(((-0.0707296823218817)*sj17)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j16))), 6.28318530717959)));
evalcond[1]=x28;
evalcond[2]=x28;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j15eval[3];
sj16=0;
cj16=1.0;
j16=0;
j15eval[0]=(cj17+(((-14.1029266223667)*sj17)));
j15eval[1]=IKsign(((((-0.997495519808809)*sj17))+(((0.0707296823218818)*cj17))));
j15eval[2]=((IKabs(r01))+(IKabs(r00)));
if( IKabs(j15eval[0]) < 0.0000010000000000  || IKabs(j15eval[1]) < 0.0000010000000000  || IKabs(j15eval[2]) < 0.0000010000000000  )
{
{
IkReal j15eval[3];
sj16=0;
cj16=1.0;
j16=0;
IkReal x29=((707303176.795451)*cj17);
IkReal x30=((9975044802.11314)*sj17);
IkReal x31=((r00*r00)+(r01*r01));
j15eval[0]=x31;
j15eval[1]=IKsign(x31);
j15eval[2]=((IKabs(((((-1.0)*r01*x29))+((r01*x30)))))+(IKabs(((((-1.0)*r00*x30))+((r00*x29))))));
if( IKabs(j15eval[0]) < 0.0000010000000000  || IKabs(j15eval[1]) < 0.0000010000000000  || IKabs(j15eval[2]) < 0.0000010000000000  )
{
{
IkReal evalcond[6];
bool bgotonextstatement = true;
do
{
IkReal x32=((0.997495519808809)*sj17);
IkReal x33=((0.0707296823218817)*cj17);
IkReal x34=x28;
evalcond[0]=((r00*r00)+(r01*r01));
evalcond[1]=0;
evalcond[2]=((((-1.0)*x32))+x33);
evalcond[3]=x34;
evalcond[4]=x34;
evalcond[5]=((((-1.0)*x33))+x32);
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j15eval[1];
sj16=0;
cj16=1.0;
j16=0;
r00=0;
r01=0;
j15eval[0]=IKabs((cj17+(((-14.1029266223667)*sj17))));
if( IKabs(j15eval[0]) < 0.0000000100000000  )
{
continue; // 3 cases reached

} else
{
IkReal op[2+1], zeror[2];
int numroots;
IkReal x35=((14.1029266223667)*sj17);
op[0]=((((-1.0)*x35))+cj17);
op[1]=0;
op[2]=(x35+(((-1.0)*cj17)));
polyroots2(op,zeror,numroots);
IkReal j15array[2], cj15array[2], sj15array[2], tempj15array[1];
int numsolutions = 0;
for(int ij15 = 0; ij15 < numroots; ++ij15)
{
IkReal htj15 = zeror[ij15];
tempj15array[0]=((2.0)*(atan(htj15)));
for(int kj15 = 0; kj15 < 1; ++kj15)
{
j15array[numsolutions] = tempj15array[kj15];
if( j15array[numsolutions] > IKPI )
{
    j15array[numsolutions]-=IK2PI;
}
else if( j15array[numsolutions] < -IKPI )
{
    j15array[numsolutions]+=IK2PI;
}
sj15array[numsolutions] = IKsin(j15array[numsolutions]);
cj15array[numsolutions] = IKcos(j15array[numsolutions]);
numsolutions++;
}
}
bool j15valid[2]={true,true};
_nj15 = 2;
for(int ij15 = 0; ij15 < numsolutions; ++ij15)
    {
if( !j15valid[ij15] )
{
    continue;
}
    j15 = j15array[ij15]; cj15 = cj15array[ij15]; sj15 = sj15array[ij15];
htj15 = IKtan(j15/2);

_ij15[0] = ij15; _ij15[1] = -1;
for(int iij15 = ij15+1; iij15 < numsolutions; ++iij15)
{
if( j15valid[iij15] && IKabs(cj15array[ij15]-cj15array[iij15]) < IKFAST_SOLUTION_THRESH && IKabs(sj15array[ij15]-sj15array[iij15]) < IKFAST_SOLUTION_THRESH )
{
    j15valid[iij15]=false; _ij15[1] = iij15; break; 
}
}
{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(3);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j15;
vinfos[0].indices[0] = _ij15[0];
vinfos[0].indices[1] = _ij15[1];
vinfos[0].maxsolutions = _nj15;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j16;
vinfos[1].indices[0] = _ij16[0];
vinfos[1].indices[1] = _ij16[1];
vinfos[1].maxsolutions = _nj16;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j17;
vinfos[2].indices[0] = _ij17[0];
vinfos[2].indices[1] = _ij17[1];
vinfos[2].maxsolutions = _nj17;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
    }

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x36=((1.00000000002649)+(((-1.0)*r02)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((3.07080386502207)+j17)))), 6.28318530717959)));
evalcond[1]=x36;
evalcond[2]=x36;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j15array[1], cj15array[1], sj15array[1];
bool j15valid[1]={false};
_nj15 = 1;
if( IKabs(((-429260169.745842)*r00)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((429260169.745842)*r01)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-429260169.745842)*r00))+IKsqr(((429260169.745842)*r01))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j15array[0]=IKatan2(((-429260169.745842)*r00), ((429260169.745842)*r01));
sj15array[0]=IKsin(j15array[0]);
cj15array[0]=IKcos(j15array[0]);
if( j15array[0] > IKPI )
{
    j15array[0]-=IK2PI;
}
else if( j15array[0] < -IKPI )
{    j15array[0]+=IK2PI;
}
j15valid[0] = true;
for(int ij15 = 0; ij15 < 1; ++ij15)
{
if( !j15valid[ij15] )
{
    continue;
}
_ij15[0] = ij15; _ij15[1] = -1;
for(int iij15 = ij15+1; iij15 < 1; ++iij15)
{
if( j15valid[iij15] && IKabs(cj15array[ij15]-cj15array[iij15]) < IKFAST_SOLUTION_THRESH && IKabs(sj15array[ij15]-sj15array[iij15]) < IKFAST_SOLUTION_THRESH )
{
    j15valid[iij15]=false; _ij15[1] = iij15; break; 
}
}
j15 = j15array[ij15]; cj15 = cj15array[ij15]; sj15 = sj15array[ij15];
{
IkReal evalcond[4];
IkReal x37=IKsin(j15);
IkReal x38=IKcos(j15);
IkReal x39=((1.0)*r01);
IkReal x40=((1.0)*r00);
evalcond[0]=((((-2.32958953678857e-9)*x37))+(((-1.0)*x40)));
evalcond[1]=((((-1.0)*x39))+(((2.32958953678857e-9)*x38)));
evalcond[2]=((((-1.0)*x37*x39))+(((-1.0)*x38*x40)));
evalcond[3]=((-2.32958953678857e-9)+(((-1.0)*x37*x40))+((r01*x38)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(3);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j15;
vinfos[0].indices[0] = _ij15[0];
vinfos[0].indices[1] = _ij15[1];
vinfos[0].maxsolutions = _nj15;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j16;
vinfos[1].indices[0] = _ij16[0];
vinfos[1].indices[1] = _ij16[1];
vinfos[1].maxsolutions = _nj16;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j17;
vinfos[2].indices[0] = _ij17[0];
vinfos[2].indices[1] = _ij17[1];
vinfos[2].maxsolutions = _nj17;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x41=((-1.00000000002649)+(((-1.0)*r02)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-0.0707887885677251)+j17)))), 6.28318530717959)));
evalcond[1]=x41;
evalcond[2]=x41;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j15array[1], cj15array[1], sj15array[1];
bool j15valid[1]={false};
_nj15 = 1;
if( IKabs(((429260169.745842)*r00)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-429260169.745842)*r01)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((429260169.745842)*r00))+IKsqr(((-429260169.745842)*r01))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j15array[0]=IKatan2(((429260169.745842)*r00), ((-429260169.745842)*r01));
sj15array[0]=IKsin(j15array[0]);
cj15array[0]=IKcos(j15array[0]);
if( j15array[0] > IKPI )
{
    j15array[0]-=IK2PI;
}
else if( j15array[0] < -IKPI )
{    j15array[0]+=IK2PI;
}
j15valid[0] = true;
for(int ij15 = 0; ij15 < 1; ++ij15)
{
if( !j15valid[ij15] )
{
    continue;
}
_ij15[0] = ij15; _ij15[1] = -1;
for(int iij15 = ij15+1; iij15 < 1; ++iij15)
{
if( j15valid[iij15] && IKabs(cj15array[ij15]-cj15array[iij15]) < IKFAST_SOLUTION_THRESH && IKabs(sj15array[ij15]-sj15array[iij15]) < IKFAST_SOLUTION_THRESH )
{
    j15valid[iij15]=false; _ij15[1] = iij15; break; 
}
}
j15 = j15array[ij15]; cj15 = cj15array[ij15]; sj15 = sj15array[ij15];
{
IkReal evalcond[4];
IkReal x42=IKsin(j15);
IkReal x43=IKcos(j15);
IkReal x44=((1.0)*r01);
IkReal x45=((1.0)*r00);
evalcond[0]=((((-1.0)*x45))+(((2.32958953678857e-9)*x42)));
evalcond[1]=((((-2.32958953678857e-9)*x43))+(((-1.0)*x44)));
evalcond[2]=((((-1.0)*x42*x44))+(((-1.0)*x43*x45)));
evalcond[3]=((2.32958953678857e-9)+(((-1.0)*x42*x45))+((r01*x43)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(3);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j15;
vinfos[0].indices[0] = _ij15[0];
vinfos[0].indices[1] = _ij15[1];
vinfos[0].maxsolutions = _nj15;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j16;
vinfos[1].indices[0] = _ij16[0];
vinfos[1].indices[1] = _ij16[1];
vinfos[1].maxsolutions = _nj16;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j17;
vinfos[2].indices[0] = _ij17[0];
vinfos[2].indices[1] = _ij17[1];
vinfos[2].maxsolutions = _nj17;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j15]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}

} else
{
{
IkReal j15array[1], cj15array[1], sj15array[1];
bool j15valid[1]={false};
_nj15 = 1;
IkReal x46=((0.997495519808809)*sj17);
IkReal x47=((0.0707296823218818)*cj17);
CheckValue<IkReal> x48=IKPowWithIntegerCheck(IKsign(((r00*r00)+(r01*r01))),-1);
if(!x48.valid){
continue;
}
CheckValue<IkReal> x49 = IKatan2WithCheck(IkReal(((((-1.0)*r00*x46))+((r00*x47)))),((((-1.0)*r01*x47))+((r01*x46))),IKFAST_ATAN2_MAGTHRESH);
if(!x49.valid){
continue;
}
j15array[0]=((-1.5707963267949)+(((1.5707963267949)*(x48.value)))+(x49.value));
sj15array[0]=IKsin(j15array[0]);
cj15array[0]=IKcos(j15array[0]);
if( j15array[0] > IKPI )
{
    j15array[0]-=IK2PI;
}
else if( j15array[0] < -IKPI )
{    j15array[0]+=IK2PI;
}
j15valid[0] = true;
for(int ij15 = 0; ij15 < 1; ++ij15)
{
if( !j15valid[ij15] )
{
    continue;
}
_ij15[0] = ij15; _ij15[1] = -1;
for(int iij15 = ij15+1; iij15 < 1; ++iij15)
{
if( j15valid[iij15] && IKabs(cj15array[ij15]-cj15array[iij15]) < IKFAST_SOLUTION_THRESH && IKabs(sj15array[ij15]-sj15array[iij15]) < IKFAST_SOLUTION_THRESH )
{
    j15valid[iij15]=false; _ij15[1] = iij15; break; 
}
}
j15 = j15array[ij15]; cj15 = cj15array[ij15]; sj15 = sj15array[ij15];
{
IkReal evalcond[4];
IkReal x50=IKsin(j15);
IkReal x51=IKcos(j15);
IkReal x52=((0.0707296823218818)*cj17);
IkReal x53=((1.0)*r01);
IkReal x54=((1.0)*r00);
IkReal x55=((0.997495519808809)*sj17);
evalcond[0]=((((-1.0)*x51*x54))+(((-1.0)*x50*x53)));
evalcond[1]=(((x50*x52))+(((-1.0)*x54))+(((-1.0)*x50*x55)));
evalcond[2]=((((-1.0)*x51*x52))+((x51*x55))+(((-1.0)*x53)));
evalcond[3]=(((r01*x51))+x52+(((-1.0)*x55))+(((-1.0)*x50*x54)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(3);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j15;
vinfos[0].indices[0] = _ij15[0];
vinfos[0].indices[1] = _ij15[1];
vinfos[0].maxsolutions = _nj15;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j16;
vinfos[1].indices[0] = _ij16[0];
vinfos[1].indices[1] = _ij16[1];
vinfos[1].maxsolutions = _nj16;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j17;
vinfos[2].indices[0] = _ij17[0];
vinfos[2].indices[1] = _ij17[1];
vinfos[2].maxsolutions = _nj17;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j15array[1], cj15array[1], sj15array[1];
bool j15valid[1]={false};
_nj15 = 1;
CheckValue<IkReal> x56 = IKatan2WithCheck(IkReal(r00),((-1.0)*r01),IKFAST_ATAN2_MAGTHRESH);
if(!x56.valid){
continue;
}
CheckValue<IkReal> x57=IKPowWithIntegerCheck(IKsign(((((-0.997495519808809)*sj17))+(((0.0707296823218818)*cj17)))),-1);
if(!x57.valid){
continue;
}
j15array[0]=((-1.5707963267949)+(x56.value)+(((1.5707963267949)*(x57.value))));
sj15array[0]=IKsin(j15array[0]);
cj15array[0]=IKcos(j15array[0]);
if( j15array[0] > IKPI )
{
    j15array[0]-=IK2PI;
}
else if( j15array[0] < -IKPI )
{    j15array[0]+=IK2PI;
}
j15valid[0] = true;
for(int ij15 = 0; ij15 < 1; ++ij15)
{
if( !j15valid[ij15] )
{
    continue;
}
_ij15[0] = ij15; _ij15[1] = -1;
for(int iij15 = ij15+1; iij15 < 1; ++iij15)
{
if( j15valid[iij15] && IKabs(cj15array[ij15]-cj15array[iij15]) < IKFAST_SOLUTION_THRESH && IKabs(sj15array[ij15]-sj15array[iij15]) < IKFAST_SOLUTION_THRESH )
{
    j15valid[iij15]=false; _ij15[1] = iij15; break; 
}
}
j15 = j15array[ij15]; cj15 = cj15array[ij15]; sj15 = sj15array[ij15];
{
IkReal evalcond[4];
IkReal x58=IKsin(j15);
IkReal x59=IKcos(j15);
IkReal x60=((0.0707296823218818)*cj17);
IkReal x61=((1.0)*r01);
IkReal x62=((1.0)*r00);
IkReal x63=((0.997495519808809)*sj17);
evalcond[0]=((((-1.0)*x59*x62))+(((-1.0)*x58*x61)));
evalcond[1]=(((x58*x60))+(((-1.0)*x58*x63))+(((-1.0)*x62)));
evalcond[2]=(((x59*x63))+(((-1.0)*x59*x60))+(((-1.0)*x61)));
evalcond[3]=(((r01*x59))+x60+(((-1.0)*x58*x62))+(((-1.0)*x63)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(3);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j15;
vinfos[0].indices[0] = _ij15[0];
vinfos[0].indices[1] = _ij15[1];
vinfos[0].maxsolutions = _nj15;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j16;
vinfos[1].indices[0] = _ij16[0];
vinfos[1].indices[1] = _ij16[1];
vinfos[1].maxsolutions = _nj16;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j17;
vinfos[2].indices[0] = _ij17[0];
vinfos[2].indices[1] = _ij17[1];
vinfos[2].maxsolutions = _nj17;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x64=((((0.0707296823218817)*sj17))+(((0.997495519808809)*cj17)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j16)))), 6.28318530717959)));
evalcond[1]=(r02+(((-1.0)*x64)));
evalcond[2]=((((-1.0)*r02))+x64);
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j15eval[3];
sj16=0;
cj16=-1.0;
j16=3.14159265358979;
j15eval[0]=((((14.1029266223667)*sj17))+(((-1.0)*cj17)));
j15eval[1]=IKsign(((((-0.0707296823218818)*cj17))+(((0.997495519808809)*sj17))));
j15eval[2]=((IKabs(r01))+(IKabs(r00)));
if( IKabs(j15eval[0]) < 0.0000010000000000  || IKabs(j15eval[1]) < 0.0000010000000000  || IKabs(j15eval[2]) < 0.0000010000000000  )
{
{
IkReal j15eval[3];
sj16=0;
cj16=-1.0;
j16=3.14159265358979;
IkReal x65=((707303176.795451)*cj17);
IkReal x66=((9975044802.11314)*sj17);
IkReal x67=((((-1.0)*(r00*r00)))+(((-1.0)*(r01*r01))));
j15eval[0]=x67;
j15eval[1]=((IKabs((((r00*x65))+(((-1.0)*r00*x66)))))+(IKabs((((r01*x66))+(((-1.0)*r01*x65))))));
j15eval[2]=IKsign(x67);
if( IKabs(j15eval[0]) < 0.0000010000000000  || IKabs(j15eval[1]) < 0.0000010000000000  || IKabs(j15eval[2]) < 0.0000010000000000  )
{
{
IkReal evalcond[3];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-0.0707887885677252)+j17)))), 6.28318530717959)));
evalcond[1]=((-1.00000000002649)+r02);
evalcond[2]=((1.00000000002649)+(((-1.0)*r02)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j15array[1], cj15array[1], sj15array[1];
bool j15valid[1]={false};
_nj15 = 1;
if( IKabs(((-429260169.745842)*r00)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((429260169.745842)*r01)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-429260169.745842)*r00))+IKsqr(((429260169.745842)*r01))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j15array[0]=IKatan2(((-429260169.745842)*r00), ((429260169.745842)*r01));
sj15array[0]=IKsin(j15array[0]);
cj15array[0]=IKcos(j15array[0]);
if( j15array[0] > IKPI )
{
    j15array[0]-=IK2PI;
}
else if( j15array[0] < -IKPI )
{    j15array[0]+=IK2PI;
}
j15valid[0] = true;
for(int ij15 = 0; ij15 < 1; ++ij15)
{
if( !j15valid[ij15] )
{
    continue;
}
_ij15[0] = ij15; _ij15[1] = -1;
for(int iij15 = ij15+1; iij15 < 1; ++iij15)
{
if( j15valid[iij15] && IKabs(cj15array[ij15]-cj15array[iij15]) < IKFAST_SOLUTION_THRESH && IKabs(sj15array[ij15]-sj15array[iij15]) < IKFAST_SOLUTION_THRESH )
{
    j15valid[iij15]=false; _ij15[1] = iij15; break; 
}
}
j15 = j15array[ij15]; cj15 = cj15array[ij15]; sj15 = sj15array[ij15];
{
IkReal evalcond[4];
IkReal x68=IKsin(j15);
IkReal x69=IKcos(j15);
IkReal x70=((1.0)*r01);
IkReal x71=((1.0)*r00);
evalcond[0]=((((-1.0)*x71))+(((-2.32958953678857e-9)*x68)));
evalcond[1]=((((-1.0)*x70))+(((2.32958953678857e-9)*x69)));
evalcond[2]=((((-1.0)*x69*x71))+(((-1.0)*x68*x70)));
evalcond[3]=((2.32958953678857e-9)+((r00*x68))+(((-1.0)*x69*x70)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(3);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j15;
vinfos[0].indices[0] = _ij15[0];
vinfos[0].indices[1] = _ij15[1];
vinfos[0].maxsolutions = _nj15;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j16;
vinfos[1].indices[0] = _ij16[0];
vinfos[1].indices[1] = _ij16[1];
vinfos[1].maxsolutions = _nj16;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j17;
vinfos[2].indices[0] = _ij17[0];
vinfos[2].indices[1] = _ij17[1];
vinfos[2].maxsolutions = _nj17;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.21238144215752)+j17)))), 6.28318530717959)));
evalcond[1]=((1.00000000002649)+r02);
evalcond[2]=((-1.00000000002649)+(((-1.0)*r02)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j15array[1], cj15array[1], sj15array[1];
bool j15valid[1]={false};
_nj15 = 1;
if( IKabs(((429260169.745842)*r00)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-429260169.745842)*r01)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((429260169.745842)*r00))+IKsqr(((-429260169.745842)*r01))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j15array[0]=IKatan2(((429260169.745842)*r00), ((-429260169.745842)*r01));
sj15array[0]=IKsin(j15array[0]);
cj15array[0]=IKcos(j15array[0]);
if( j15array[0] > IKPI )
{
    j15array[0]-=IK2PI;
}
else if( j15array[0] < -IKPI )
{    j15array[0]+=IK2PI;
}
j15valid[0] = true;
for(int ij15 = 0; ij15 < 1; ++ij15)
{
if( !j15valid[ij15] )
{
    continue;
}
_ij15[0] = ij15; _ij15[1] = -1;
for(int iij15 = ij15+1; iij15 < 1; ++iij15)
{
if( j15valid[iij15] && IKabs(cj15array[ij15]-cj15array[iij15]) < IKFAST_SOLUTION_THRESH && IKabs(sj15array[ij15]-sj15array[iij15]) < IKFAST_SOLUTION_THRESH )
{
    j15valid[iij15]=false; _ij15[1] = iij15; break; 
}
}
j15 = j15array[ij15]; cj15 = cj15array[ij15]; sj15 = sj15array[ij15];
{
IkReal evalcond[4];
IkReal x72=IKsin(j15);
IkReal x73=IKcos(j15);
IkReal x74=((1.0)*r01);
IkReal x75=((1.0)*r00);
evalcond[0]=((((-1.0)*x75))+(((2.32958953678857e-9)*x72)));
evalcond[1]=((((-1.0)*x74))+(((-2.32958953678857e-9)*x73)));
evalcond[2]=((((-1.0)*x72*x74))+(((-1.0)*x73*x75)));
evalcond[3]=((-2.32958953678857e-9)+(((-1.0)*x73*x74))+((r00*x72)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(3);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j15;
vinfos[0].indices[0] = _ij15[0];
vinfos[0].indices[1] = _ij15[1];
vinfos[0].maxsolutions = _nj15;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j16;
vinfos[1].indices[0] = _ij16[0];
vinfos[1].indices[1] = _ij16[1];
vinfos[1].maxsolutions = _nj16;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j17;
vinfos[2].indices[0] = _ij17[0];
vinfos[2].indices[1] = _ij17[1];
vinfos[2].maxsolutions = _nj17;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j15]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j15array[1], cj15array[1], sj15array[1];
bool j15valid[1]={false};
_nj15 = 1;
IkReal x76=((0.997495519808809)*sj17);
IkReal x77=((0.0707296823218818)*cj17);
CheckValue<IkReal> x78 = IKatan2WithCheck(IkReal(((((-1.0)*r00*x76))+((r00*x77)))),((((-1.0)*r01*x77))+((r01*x76))),IKFAST_ATAN2_MAGTHRESH);
if(!x78.valid){
continue;
}
CheckValue<IkReal> x79=IKPowWithIntegerCheck(IKsign(((((-1.0)*(r00*r00)))+(((-1.0)*(r01*r01))))),-1);
if(!x79.valid){
continue;
}
j15array[0]=((-1.5707963267949)+(x78.value)+(((1.5707963267949)*(x79.value))));
sj15array[0]=IKsin(j15array[0]);
cj15array[0]=IKcos(j15array[0]);
if( j15array[0] > IKPI )
{
    j15array[0]-=IK2PI;
}
else if( j15array[0] < -IKPI )
{    j15array[0]+=IK2PI;
}
j15valid[0] = true;
for(int ij15 = 0; ij15 < 1; ++ij15)
{
if( !j15valid[ij15] )
{
    continue;
}
_ij15[0] = ij15; _ij15[1] = -1;
for(int iij15 = ij15+1; iij15 < 1; ++iij15)
{
if( j15valid[iij15] && IKabs(cj15array[ij15]-cj15array[iij15]) < IKFAST_SOLUTION_THRESH && IKabs(sj15array[ij15]-sj15array[iij15]) < IKFAST_SOLUTION_THRESH )
{
    j15valid[iij15]=false; _ij15[1] = iij15; break; 
}
}
j15 = j15array[ij15]; cj15 = cj15array[ij15]; sj15 = sj15array[ij15];
{
IkReal evalcond[4];
IkReal x80=IKsin(j15);
IkReal x81=IKcos(j15);
IkReal x82=((1.0)*r01);
IkReal x83=((0.0707296823218818)*cj17);
IkReal x84=((1.0)*r00);
IkReal x85=((0.997495519808809)*sj17);
evalcond[0]=((((-1.0)*x81*x84))+(((-1.0)*x80*x82)));
evalcond[1]=((((-1.0)*x80*x83))+((x80*x85))+(((-1.0)*x84)));
evalcond[2]=((((-1.0)*x81*x85))+((x81*x83))+(((-1.0)*x82)));
evalcond[3]=((((-1.0)*x81*x82))+((r00*x80))+x83+(((-1.0)*x85)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(3);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j15;
vinfos[0].indices[0] = _ij15[0];
vinfos[0].indices[1] = _ij15[1];
vinfos[0].maxsolutions = _nj15;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j16;
vinfos[1].indices[0] = _ij16[0];
vinfos[1].indices[1] = _ij16[1];
vinfos[1].maxsolutions = _nj16;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j17;
vinfos[2].indices[0] = _ij17[0];
vinfos[2].indices[1] = _ij17[1];
vinfos[2].maxsolutions = _nj17;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j15array[1], cj15array[1], sj15array[1];
bool j15valid[1]={false};
_nj15 = 1;
CheckValue<IkReal> x86=IKPowWithIntegerCheck(IKsign(((((-0.0707296823218818)*cj17))+(((0.997495519808809)*sj17)))),-1);
if(!x86.valid){
continue;
}
CheckValue<IkReal> x87 = IKatan2WithCheck(IkReal(r00),((-1.0)*r01),IKFAST_ATAN2_MAGTHRESH);
if(!x87.valid){
continue;
}
j15array[0]=((-1.5707963267949)+(((1.5707963267949)*(x86.value)))+(x87.value));
sj15array[0]=IKsin(j15array[0]);
cj15array[0]=IKcos(j15array[0]);
if( j15array[0] > IKPI )
{
    j15array[0]-=IK2PI;
}
else if( j15array[0] < -IKPI )
{    j15array[0]+=IK2PI;
}
j15valid[0] = true;
for(int ij15 = 0; ij15 < 1; ++ij15)
{
if( !j15valid[ij15] )
{
    continue;
}
_ij15[0] = ij15; _ij15[1] = -1;
for(int iij15 = ij15+1; iij15 < 1; ++iij15)
{
if( j15valid[iij15] && IKabs(cj15array[ij15]-cj15array[iij15]) < IKFAST_SOLUTION_THRESH && IKabs(sj15array[ij15]-sj15array[iij15]) < IKFAST_SOLUTION_THRESH )
{
    j15valid[iij15]=false; _ij15[1] = iij15; break; 
}
}
j15 = j15array[ij15]; cj15 = cj15array[ij15]; sj15 = sj15array[ij15];
{
IkReal evalcond[4];
IkReal x88=IKsin(j15);
IkReal x89=IKcos(j15);
IkReal x90=((1.0)*r01);
IkReal x91=((0.0707296823218818)*cj17);
IkReal x92=((1.0)*r00);
IkReal x93=((0.997495519808809)*sj17);
evalcond[0]=((((-1.0)*x88*x90))+(((-1.0)*x89*x92)));
evalcond[1]=(((x88*x93))+(((-1.0)*x92))+(((-1.0)*x88*x91)));
evalcond[2]=(((x89*x91))+(((-1.0)*x90))+(((-1.0)*x89*x93)));
evalcond[3]=(((r00*x88))+x91+(((-1.0)*x93))+(((-1.0)*x89*x90)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(3);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j15;
vinfos[0].indices[0] = _ij15[0];
vinfos[0].indices[1] = _ij15[1];
vinfos[0].maxsolutions = _nj15;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j16;
vinfos[1].indices[0] = _ij16[0];
vinfos[1].indices[1] = _ij16[1];
vinfos[1].maxsolutions = _nj16;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j17;
vinfos[2].indices[0] = _ij17[0];
vinfos[2].indices[1] = _ij17[1];
vinfos[2].maxsolutions = _nj17;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x94=((0.997495519808809)*sj17);
IkReal x95=((0.0707296823218817)*cj17);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j16)))), 6.28318530717959)));
evalcond[1]=(x95+r02+(((-1.0)*x94)));
evalcond[2]=((((-1.0)*r02))+x94+(((-1.0)*x95)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j15eval[3];
sj16=1.0;
cj16=0;
j16=1.5707963267949;
j15eval[0]=((((-14.1029266223667)*cj17))+(((-1.0)*sj17)));
j15eval[1]=IKsign(((((-0.997495519808809)*cj17))+(((-0.0707296823218818)*sj17))));
j15eval[2]=((IKabs(r01))+(IKabs(r00)));
if( IKabs(j15eval[0]) < 0.0000010000000000  || IKabs(j15eval[1]) < 0.0000010000000000  || IKabs(j15eval[2]) < 0.0000010000000000  )
{
{
IkReal j15eval[3];
sj16=1.0;
cj16=0;
j16=1.5707963267949;
IkReal x96=((707303176.795451)*sj17);
IkReal x97=((9975044802.11314)*cj17);
IkReal x98=((r00*r00)+(r01*r01));
j15eval[0]=x98;
j15eval[1]=((IKabs(((((-1.0)*r00*x97))+(((-1.0)*r00*x96)))))+(IKabs((((r01*x97))+((r01*x96))))));
j15eval[2]=IKsign(x98);
if( IKabs(j15eval[0]) < 0.0000010000000000  || IKabs(j15eval[1]) < 0.0000010000000000  || IKabs(j15eval[2]) < 0.0000010000000000  )
{
{
IkReal evalcond[6];
bool bgotonextstatement = true;
do
{
IkReal x99=((0.997495519808809)*sj17);
IkReal x100=((0.0707296823218817)*cj17);
IkReal x101=((((0.0707296823218817)*sj17))+(((0.997495519808809)*cj17)));
evalcond[0]=((r00*r00)+(r01*r01));
evalcond[1]=0;
evalcond[2]=(x100+r02+(((-1.0)*x99)));
evalcond[3]=((-1.0)*x101);
evalcond[4]=((((-1.0)*r02))+(((-1.0)*x100))+x99);
evalcond[5]=x101;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j15eval[1];
sj16=1.0;
cj16=0;
j16=1.5707963267949;
r00=0;
r01=0;
j15eval[0]=IKabs(((((-14.1029266223667)*cj17))+(((-1.0)*sj17))));
if( IKabs(j15eval[0]) < 0.0000000100000000  )
{
continue; // 3 cases reached

} else
{
IkReal op[2+1], zeror[2];
int numroots;
IkReal x102=((14.1029266223667)*cj17);
op[0]=((((-1.0)*x102))+(((-1.0)*sj17)));
op[1]=0;
op[2]=(x102+sj17);
polyroots2(op,zeror,numroots);
IkReal j15array[2], cj15array[2], sj15array[2], tempj15array[1];
int numsolutions = 0;
for(int ij15 = 0; ij15 < numroots; ++ij15)
{
IkReal htj15 = zeror[ij15];
tempj15array[0]=((2.0)*(atan(htj15)));
for(int kj15 = 0; kj15 < 1; ++kj15)
{
j15array[numsolutions] = tempj15array[kj15];
if( j15array[numsolutions] > IKPI )
{
    j15array[numsolutions]-=IK2PI;
}
else if( j15array[numsolutions] < -IKPI )
{
    j15array[numsolutions]+=IK2PI;
}
sj15array[numsolutions] = IKsin(j15array[numsolutions]);
cj15array[numsolutions] = IKcos(j15array[numsolutions]);
numsolutions++;
}
}
bool j15valid[2]={true,true};
_nj15 = 2;
for(int ij15 = 0; ij15 < numsolutions; ++ij15)
    {
if( !j15valid[ij15] )
{
    continue;
}
    j15 = j15array[ij15]; cj15 = cj15array[ij15]; sj15 = sj15array[ij15];
htj15 = IKtan(j15/2);

_ij15[0] = ij15; _ij15[1] = -1;
for(int iij15 = ij15+1; iij15 < numsolutions; ++iij15)
{
if( j15valid[iij15] && IKabs(cj15array[ij15]-cj15array[iij15]) < IKFAST_SOLUTION_THRESH && IKabs(sj15array[ij15]-sj15array[iij15]) < IKFAST_SOLUTION_THRESH )
{
    j15valid[iij15]=false; _ij15[1] = iij15; break; 
}
}
{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(3);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j15;
vinfos[0].indices[0] = _ij15[0];
vinfos[0].indices[1] = _ij15[1];
vinfos[0].maxsolutions = _nj15;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j16;
vinfos[1].indices[0] = _ij16[0];
vinfos[1].indices[1] = _ij16[1];
vinfos[1].maxsolutions = _nj16;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j17;
vinfos[2].indices[0] = _ij17[0];
vinfos[2].indices[1] = _ij17[1];
vinfos[2].maxsolutions = _nj17;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
    }

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.64158511536262)+j17)))), 6.28318530717959)));
evalcond[1]=((-1.00000000002649)+r02);
evalcond[2]=((1.00000000002649)+(((-1.0)*r02)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j15array[1], cj15array[1], sj15array[1];
bool j15valid[1]={false};
_nj15 = 1;
if( IKabs(((-429260169.745842)*r00)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((429260169.745842)*r01)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-429260169.745842)*r00))+IKsqr(((429260169.745842)*r01))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j15array[0]=IKatan2(((-429260169.745842)*r00), ((429260169.745842)*r01));
sj15array[0]=IKsin(j15array[0]);
cj15array[0]=IKcos(j15array[0]);
if( j15array[0] > IKPI )
{
    j15array[0]-=IK2PI;
}
else if( j15array[0] < -IKPI )
{    j15array[0]+=IK2PI;
}
j15valid[0] = true;
for(int ij15 = 0; ij15 < 1; ++ij15)
{
if( !j15valid[ij15] )
{
    continue;
}
_ij15[0] = ij15; _ij15[1] = -1;
for(int iij15 = ij15+1; iij15 < 1; ++iij15)
{
if( j15valid[iij15] && IKabs(cj15array[ij15]-cj15array[iij15]) < IKFAST_SOLUTION_THRESH && IKabs(sj15array[ij15]-sj15array[iij15]) < IKFAST_SOLUTION_THRESH )
{
    j15valid[iij15]=false; _ij15[1] = iij15; break; 
}
}
j15 = j15array[ij15]; cj15 = cj15array[ij15]; sj15 = sj15array[ij15];
{
IkReal evalcond[4];
IkReal x103=IKsin(j15);
IkReal x104=IKcos(j15);
IkReal x105=((1.0)*r01);
IkReal x106=((1.0)*r00);
evalcond[0]=((((-2.32958953678857e-9)*x103))+(((-1.0)*x106)));
evalcond[1]=((((-1.0)*x105))+(((2.32958953678857e-9)*x104)));
evalcond[2]=((((-1.0)*x104*x106))+(((-1.0)*x103*x105)));
evalcond[3]=((-2.32958953678857e-9)+((r01*x104))+(((-1.0)*x103*x106)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(3);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j15;
vinfos[0].indices[0] = _ij15[0];
vinfos[0].indices[1] = _ij15[1];
vinfos[0].maxsolutions = _nj15;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j16;
vinfos[1].indices[0] = _ij16[0];
vinfos[1].indices[1] = _ij16[1];
vinfos[1].maxsolutions = _nj16;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j17;
vinfos[2].indices[0] = _ij17[0];
vinfos[2].indices[1] = _ij17[1];
vinfos[2].maxsolutions = _nj17;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-4.78317776895241)+j17)))), 6.28318530717959)));
evalcond[1]=((1.00000000002649)+r02);
evalcond[2]=((-1.00000000002649)+(((-1.0)*r02)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j15array[1], cj15array[1], sj15array[1];
bool j15valid[1]={false};
_nj15 = 1;
if( IKabs(((429260169.745842)*r00)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-429260169.745842)*r01)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((429260169.745842)*r00))+IKsqr(((-429260169.745842)*r01))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j15array[0]=IKatan2(((429260169.745842)*r00), ((-429260169.745842)*r01));
sj15array[0]=IKsin(j15array[0]);
cj15array[0]=IKcos(j15array[0]);
if( j15array[0] > IKPI )
{
    j15array[0]-=IK2PI;
}
else if( j15array[0] < -IKPI )
{    j15array[0]+=IK2PI;
}
j15valid[0] = true;
for(int ij15 = 0; ij15 < 1; ++ij15)
{
if( !j15valid[ij15] )
{
    continue;
}
_ij15[0] = ij15; _ij15[1] = -1;
for(int iij15 = ij15+1; iij15 < 1; ++iij15)
{
if( j15valid[iij15] && IKabs(cj15array[ij15]-cj15array[iij15]) < IKFAST_SOLUTION_THRESH && IKabs(sj15array[ij15]-sj15array[iij15]) < IKFAST_SOLUTION_THRESH )
{
    j15valid[iij15]=false; _ij15[1] = iij15; break; 
}
}
j15 = j15array[ij15]; cj15 = cj15array[ij15]; sj15 = sj15array[ij15];
{
IkReal evalcond[4];
IkReal x107=IKsin(j15);
IkReal x108=IKcos(j15);
IkReal x109=((1.0)*r01);
IkReal x110=((1.0)*r00);
evalcond[0]=((((-1.0)*x110))+(((2.32958953678857e-9)*x107)));
evalcond[1]=((((-2.32958953678857e-9)*x108))+(((-1.0)*x109)));
evalcond[2]=((((-1.0)*x107*x109))+(((-1.0)*x108*x110)));
evalcond[3]=((2.32958953678857e-9)+(((-1.0)*x107*x110))+((r01*x108)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(3);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j15;
vinfos[0].indices[0] = _ij15[0];
vinfos[0].indices[1] = _ij15[1];
vinfos[0].maxsolutions = _nj15;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j16;
vinfos[1].indices[0] = _ij16[0];
vinfos[1].indices[1] = _ij16[1];
vinfos[1].maxsolutions = _nj16;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j17;
vinfos[2].indices[0] = _ij17[0];
vinfos[2].indices[1] = _ij17[1];
vinfos[2].maxsolutions = _nj17;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j15]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}

} else
{
{
IkReal j15array[1], cj15array[1], sj15array[1];
bool j15valid[1]={false};
_nj15 = 1;
IkReal x111=((0.997495519808809)*cj17);
IkReal x112=((0.0707296823218818)*sj17);
CheckValue<IkReal> x113=IKPowWithIntegerCheck(IKsign(((r00*r00)+(r01*r01))),-1);
if(!x113.valid){
continue;
}
CheckValue<IkReal> x114 = IKatan2WithCheck(IkReal(((((-1.0)*r00*x112))+(((-1.0)*r00*x111)))),(((r01*x112))+((r01*x111))),IKFAST_ATAN2_MAGTHRESH);
if(!x114.valid){
continue;
}
j15array[0]=((-1.5707963267949)+(((1.5707963267949)*(x113.value)))+(x114.value));
sj15array[0]=IKsin(j15array[0]);
cj15array[0]=IKcos(j15array[0]);
if( j15array[0] > IKPI )
{
    j15array[0]-=IK2PI;
}
else if( j15array[0] < -IKPI )
{    j15array[0]+=IK2PI;
}
j15valid[0] = true;
for(int ij15 = 0; ij15 < 1; ++ij15)
{
if( !j15valid[ij15] )
{
    continue;
}
_ij15[0] = ij15; _ij15[1] = -1;
for(int iij15 = ij15+1; iij15 < 1; ++iij15)
{
if( j15valid[iij15] && IKabs(cj15array[ij15]-cj15array[iij15]) < IKFAST_SOLUTION_THRESH && IKabs(sj15array[ij15]-sj15array[iij15]) < IKFAST_SOLUTION_THRESH )
{
    j15valid[iij15]=false; _ij15[1] = iij15; break; 
}
}
j15 = j15array[ij15]; cj15 = cj15array[ij15]; sj15 = sj15array[ij15];
{
IkReal evalcond[4];
IkReal x115=IKsin(j15);
IkReal x116=IKcos(j15);
IkReal x117=((0.997495519808809)*cj17);
IkReal x118=((0.0707296823218818)*sj17);
IkReal x119=((1.0)*r01);
IkReal x120=((1.0)*r00);
evalcond[0]=((((-1.0)*x116*x120))+(((-1.0)*x115*x119)));
evalcond[1]=((((-1.0)*x115*x117))+(((-1.0)*x115*x118))+(((-1.0)*x120)));
evalcond[2]=((((-1.0)*x119))+((x116*x118))+((x116*x117)));
evalcond[3]=((((-1.0)*x115*x120))+(((-1.0)*x117))+(((-1.0)*x118))+((r01*x116)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(3);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j15;
vinfos[0].indices[0] = _ij15[0];
vinfos[0].indices[1] = _ij15[1];
vinfos[0].maxsolutions = _nj15;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j16;
vinfos[1].indices[0] = _ij16[0];
vinfos[1].indices[1] = _ij16[1];
vinfos[1].maxsolutions = _nj16;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j17;
vinfos[2].indices[0] = _ij17[0];
vinfos[2].indices[1] = _ij17[1];
vinfos[2].maxsolutions = _nj17;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j15array[1], cj15array[1], sj15array[1];
bool j15valid[1]={false};
_nj15 = 1;
CheckValue<IkReal> x121=IKPowWithIntegerCheck(IKsign(((((-0.997495519808809)*cj17))+(((-0.0707296823218818)*sj17)))),-1);
if(!x121.valid){
continue;
}
CheckValue<IkReal> x122 = IKatan2WithCheck(IkReal(r00),((-1.0)*r01),IKFAST_ATAN2_MAGTHRESH);
if(!x122.valid){
continue;
}
j15array[0]=((-1.5707963267949)+(((1.5707963267949)*(x121.value)))+(x122.value));
sj15array[0]=IKsin(j15array[0]);
cj15array[0]=IKcos(j15array[0]);
if( j15array[0] > IKPI )
{
    j15array[0]-=IK2PI;
}
else if( j15array[0] < -IKPI )
{    j15array[0]+=IK2PI;
}
j15valid[0] = true;
for(int ij15 = 0; ij15 < 1; ++ij15)
{
if( !j15valid[ij15] )
{
    continue;
}
_ij15[0] = ij15; _ij15[1] = -1;
for(int iij15 = ij15+1; iij15 < 1; ++iij15)
{
if( j15valid[iij15] && IKabs(cj15array[ij15]-cj15array[iij15]) < IKFAST_SOLUTION_THRESH && IKabs(sj15array[ij15]-sj15array[iij15]) < IKFAST_SOLUTION_THRESH )
{
    j15valid[iij15]=false; _ij15[1] = iij15; break; 
}
}
j15 = j15array[ij15]; cj15 = cj15array[ij15]; sj15 = sj15array[ij15];
{
IkReal evalcond[4];
IkReal x123=IKsin(j15);
IkReal x124=IKcos(j15);
IkReal x125=((0.997495519808809)*cj17);
IkReal x126=((0.0707296823218818)*sj17);
IkReal x127=((1.0)*r01);
IkReal x128=((1.0)*r00);
evalcond[0]=((((-1.0)*x123*x127))+(((-1.0)*x124*x128)));
evalcond[1]=((((-1.0)*x123*x126))+(((-1.0)*x123*x125))+(((-1.0)*x128)));
evalcond[2]=((((-1.0)*x127))+((x124*x125))+((x124*x126)));
evalcond[3]=((((-1.0)*x123*x128))+((r01*x124))+(((-1.0)*x125))+(((-1.0)*x126)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(3);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j15;
vinfos[0].indices[0] = _ij15[0];
vinfos[0].indices[1] = _ij15[1];
vinfos[0].maxsolutions = _nj15;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j16;
vinfos[1].indices[0] = _ij16[0];
vinfos[1].indices[1] = _ij16[1];
vinfos[1].maxsolutions = _nj16;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j17;
vinfos[2].indices[0] = _ij17[0];
vinfos[2].indices[1] = _ij17[1];
vinfos[2].maxsolutions = _nj17;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x129=((((-0.997495519808809)*sj17))+(((-1.0)*r02))+(((0.0707296823218817)*cj17)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j16)))), 6.28318530717959)));
evalcond[1]=x129;
evalcond[2]=x129;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j15eval[3];
sj16=-1.0;
cj16=0;
j16=-1.5707963267949;
j15eval[0]=(sj17+(((14.1029266223667)*cj17)));
j15eval[1]=IKsign(((((0.0707296823218818)*sj17))+(((0.997495519808809)*cj17))));
j15eval[2]=((IKabs(r01))+(IKabs(r00)));
if( IKabs(j15eval[0]) < 0.0000010000000000  || IKabs(j15eval[1]) < 0.0000010000000000  || IKabs(j15eval[2]) < 0.0000010000000000  )
{
{
IkReal j15eval[3];
sj16=-1.0;
cj16=0;
j16=-1.5707963267949;
IkReal x130=((9975044802.11314)*cj17);
IkReal x131=((707303176.795451)*sj17);
IkReal x132=((((-1.0)*(r00*r00)))+(((-1.0)*(r01*r01))));
j15eval[0]=x132;
j15eval[1]=((IKabs((((r01*x131))+((r01*x130)))))+(IKabs(((((-1.0)*r00*x131))+(((-1.0)*r00*x130))))));
j15eval[2]=IKsign(x132);
if( IKabs(j15eval[0]) < 0.0000010000000000  || IKabs(j15eval[1]) < 0.0000010000000000  || IKabs(j15eval[2]) < 0.0000010000000000  )
{
{
IkReal evalcond[3];
bool bgotonextstatement = true;
do
{
IkReal x133=((1.00000000002649)+(((-1.0)*r02)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.50000753822717)+j17)))), 6.28318530717959)));
evalcond[1]=x133;
evalcond[2]=x133;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j15array[1], cj15array[1], sj15array[1];
bool j15valid[1]={false};
_nj15 = 1;
if( IKabs(((-429260169.745842)*r00)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((429260169.745842)*r01)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-429260169.745842)*r00))+IKsqr(((429260169.745842)*r01))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j15array[0]=IKatan2(((-429260169.745842)*r00), ((429260169.745842)*r01));
sj15array[0]=IKsin(j15array[0]);
cj15array[0]=IKcos(j15array[0]);
if( j15array[0] > IKPI )
{
    j15array[0]-=IK2PI;
}
else if( j15array[0] < -IKPI )
{    j15array[0]+=IK2PI;
}
j15valid[0] = true;
for(int ij15 = 0; ij15 < 1; ++ij15)
{
if( !j15valid[ij15] )
{
    continue;
}
_ij15[0] = ij15; _ij15[1] = -1;
for(int iij15 = ij15+1; iij15 < 1; ++iij15)
{
if( j15valid[iij15] && IKabs(cj15array[ij15]-cj15array[iij15]) < IKFAST_SOLUTION_THRESH && IKabs(sj15array[ij15]-sj15array[iij15]) < IKFAST_SOLUTION_THRESH )
{
    j15valid[iij15]=false; _ij15[1] = iij15; break; 
}
}
j15 = j15array[ij15]; cj15 = cj15array[ij15]; sj15 = sj15array[ij15];
{
IkReal evalcond[4];
IkReal x134=IKsin(j15);
IkReal x135=IKcos(j15);
IkReal x136=((1.0)*r01);
IkReal x137=((1.0)*r00);
evalcond[0]=((((-2.32958953678857e-9)*x134))+(((-1.0)*x137)));
evalcond[1]=((((2.32958953678857e-9)*x135))+(((-1.0)*x136)));
evalcond[2]=((((-1.0)*x135*x137))+(((-1.0)*x134*x136)));
evalcond[3]=((2.32958953678857e-9)+(((-1.0)*x135*x136))+((r00*x134)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(3);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j15;
vinfos[0].indices[0] = _ij15[0];
vinfos[0].indices[1] = _ij15[1];
vinfos[0].maxsolutions = _nj15;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j16;
vinfos[1].indices[0] = _ij16[0];
vinfos[1].indices[1] = _ij16[1];
vinfos[1].maxsolutions = _nj16;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j17;
vinfos[2].indices[0] = _ij17[0];
vinfos[2].indices[1] = _ij17[1];
vinfos[2].maxsolutions = _nj17;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x138=((-1.00000000002649)+(((-1.0)*r02)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.64158511536262)+j17)))), 6.28318530717959)));
evalcond[1]=x138;
evalcond[2]=x138;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j15array[1], cj15array[1], sj15array[1];
bool j15valid[1]={false};
_nj15 = 1;
if( IKabs(((429260169.745842)*r00)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-429260169.745842)*r01)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((429260169.745842)*r00))+IKsqr(((-429260169.745842)*r01))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j15array[0]=IKatan2(((429260169.745842)*r00), ((-429260169.745842)*r01));
sj15array[0]=IKsin(j15array[0]);
cj15array[0]=IKcos(j15array[0]);
if( j15array[0] > IKPI )
{
    j15array[0]-=IK2PI;
}
else if( j15array[0] < -IKPI )
{    j15array[0]+=IK2PI;
}
j15valid[0] = true;
for(int ij15 = 0; ij15 < 1; ++ij15)
{
if( !j15valid[ij15] )
{
    continue;
}
_ij15[0] = ij15; _ij15[1] = -1;
for(int iij15 = ij15+1; iij15 < 1; ++iij15)
{
if( j15valid[iij15] && IKabs(cj15array[ij15]-cj15array[iij15]) < IKFAST_SOLUTION_THRESH && IKabs(sj15array[ij15]-sj15array[iij15]) < IKFAST_SOLUTION_THRESH )
{
    j15valid[iij15]=false; _ij15[1] = iij15; break; 
}
}
j15 = j15array[ij15]; cj15 = cj15array[ij15]; sj15 = sj15array[ij15];
{
IkReal evalcond[4];
IkReal x139=IKsin(j15);
IkReal x140=IKcos(j15);
IkReal x141=((1.0)*r01);
IkReal x142=((1.0)*r00);
evalcond[0]=((((-1.0)*x142))+(((2.32958953678857e-9)*x139)));
evalcond[1]=((((-1.0)*x141))+(((-2.32958953678857e-9)*x140)));
evalcond[2]=((((-1.0)*x140*x142))+(((-1.0)*x139*x141)));
evalcond[3]=((-2.32958953678857e-9)+(((-1.0)*x140*x141))+((r00*x139)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(3);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j15;
vinfos[0].indices[0] = _ij15[0];
vinfos[0].indices[1] = _ij15[1];
vinfos[0].maxsolutions = _nj15;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j16;
vinfos[1].indices[0] = _ij16[0];
vinfos[1].indices[1] = _ij16[1];
vinfos[1].maxsolutions = _nj16;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j17;
vinfos[2].indices[0] = _ij17[0];
vinfos[2].indices[1] = _ij17[1];
vinfos[2].maxsolutions = _nj17;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j15]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j15array[1], cj15array[1], sj15array[1];
bool j15valid[1]={false};
_nj15 = 1;
IkReal x143=((0.0707296823218818)*sj17);
IkReal x144=((0.997495519808809)*cj17);
CheckValue<IkReal> x145=IKPowWithIntegerCheck(IKsign(((((-1.0)*(r00*r00)))+(((-1.0)*(r01*r01))))),-1);
if(!x145.valid){
continue;
}
CheckValue<IkReal> x146 = IKatan2WithCheck(IkReal(((((-1.0)*r00*x143))+(((-1.0)*r00*x144)))),(((r01*x143))+((r01*x144))),IKFAST_ATAN2_MAGTHRESH);
if(!x146.valid){
continue;
}
j15array[0]=((-1.5707963267949)+(((1.5707963267949)*(x145.value)))+(x146.value));
sj15array[0]=IKsin(j15array[0]);
cj15array[0]=IKcos(j15array[0]);
if( j15array[0] > IKPI )
{
    j15array[0]-=IK2PI;
}
else if( j15array[0] < -IKPI )
{    j15array[0]+=IK2PI;
}
j15valid[0] = true;
for(int ij15 = 0; ij15 < 1; ++ij15)
{
if( !j15valid[ij15] )
{
    continue;
}
_ij15[0] = ij15; _ij15[1] = -1;
for(int iij15 = ij15+1; iij15 < 1; ++iij15)
{
if( j15valid[iij15] && IKabs(cj15array[ij15]-cj15array[iij15]) < IKFAST_SOLUTION_THRESH && IKabs(sj15array[ij15]-sj15array[iij15]) < IKFAST_SOLUTION_THRESH )
{
    j15valid[iij15]=false; _ij15[1] = iij15; break; 
}
}
j15 = j15array[ij15]; cj15 = cj15array[ij15]; sj15 = sj15array[ij15];
{
IkReal evalcond[4];
IkReal x147=IKsin(j15);
IkReal x148=IKcos(j15);
IkReal x149=((1.0)*r01);
IkReal x150=((0.997495519808809)*cj17);
IkReal x151=((0.0707296823218818)*sj17);
IkReal x152=((1.0)*r00);
evalcond[0]=((((-1.0)*x147*x149))+(((-1.0)*x148*x152)));
evalcond[1]=((((-1.0)*x152))+((x147*x150))+((x147*x151)));
evalcond[2]=((((-1.0)*x149))+(((-1.0)*x148*x150))+(((-1.0)*x148*x151)));
evalcond[3]=((((-1.0)*x150))+(((-1.0)*x151))+((r00*x147))+(((-1.0)*x148*x149)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(3);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j15;
vinfos[0].indices[0] = _ij15[0];
vinfos[0].indices[1] = _ij15[1];
vinfos[0].maxsolutions = _nj15;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j16;
vinfos[1].indices[0] = _ij16[0];
vinfos[1].indices[1] = _ij16[1];
vinfos[1].maxsolutions = _nj16;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j17;
vinfos[2].indices[0] = _ij17[0];
vinfos[2].indices[1] = _ij17[1];
vinfos[2].maxsolutions = _nj17;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j15array[1], cj15array[1], sj15array[1];
bool j15valid[1]={false};
_nj15 = 1;
CheckValue<IkReal> x153 = IKatan2WithCheck(IkReal(r00),((-1.0)*r01),IKFAST_ATAN2_MAGTHRESH);
if(!x153.valid){
continue;
}
CheckValue<IkReal> x154=IKPowWithIntegerCheck(IKsign(((((0.0707296823218818)*sj17))+(((0.997495519808809)*cj17)))),-1);
if(!x154.valid){
continue;
}
j15array[0]=((-1.5707963267949)+(x153.value)+(((1.5707963267949)*(x154.value))));
sj15array[0]=IKsin(j15array[0]);
cj15array[0]=IKcos(j15array[0]);
if( j15array[0] > IKPI )
{
    j15array[0]-=IK2PI;
}
else if( j15array[0] < -IKPI )
{    j15array[0]+=IK2PI;
}
j15valid[0] = true;
for(int ij15 = 0; ij15 < 1; ++ij15)
{
if( !j15valid[ij15] )
{
    continue;
}
_ij15[0] = ij15; _ij15[1] = -1;
for(int iij15 = ij15+1; iij15 < 1; ++iij15)
{
if( j15valid[iij15] && IKabs(cj15array[ij15]-cj15array[iij15]) < IKFAST_SOLUTION_THRESH && IKabs(sj15array[ij15]-sj15array[iij15]) < IKFAST_SOLUTION_THRESH )
{
    j15valid[iij15]=false; _ij15[1] = iij15; break; 
}
}
j15 = j15array[ij15]; cj15 = cj15array[ij15]; sj15 = sj15array[ij15];
{
IkReal evalcond[4];
IkReal x155=IKsin(j15);
IkReal x156=IKcos(j15);
IkReal x157=((1.0)*r01);
IkReal x158=((0.997495519808809)*cj17);
IkReal x159=((0.0707296823218818)*sj17);
IkReal x160=((1.0)*r00);
evalcond[0]=((((-1.0)*x155*x157))+(((-1.0)*x156*x160)));
evalcond[1]=((((-1.0)*x160))+((x155*x158))+((x155*x159)));
evalcond[2]=((((-1.0)*x157))+(((-1.0)*x156*x159))+(((-1.0)*x156*x158)));
evalcond[3]=((((-1.0)*x158))+(((-1.0)*x159))+((r00*x155))+(((-1.0)*x156*x157)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(3);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j15;
vinfos[0].indices[0] = _ij15[0];
vinfos[0].indices[1] = _ij15[1];
vinfos[0].maxsolutions = _nj15;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j16;
vinfos[1].indices[0] = _ij16[0];
vinfos[1].indices[1] = _ij16[1];
vinfos[1].maxsolutions = _nj16;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j17;
vinfos[2].indices[0] = _ij17[0];
vinfos[2].indices[1] = _ij17[1];
vinfos[2].maxsolutions = _nj17;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j15]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}

} else
{
{
IkReal j15array[1], cj15array[1], sj15array[1];
bool j15valid[1]={false};
_nj15 = 1;
IkReal x161=(cj16*r02);
IkReal x162=((0.0707296823218818)*sj17);
IkReal x163=((0.997495519808809)*cj17);
CheckValue<IkReal> x164 = IKatan2WithCheck(IkReal(((((-1.0)*r00*x161))+(((-1.0)*r00*x162))+(((-1.0)*r00*x163)))),(((r01*x163))+((r01*x161))+((r01*x162))),IKFAST_ATAN2_MAGTHRESH);
if(!x164.valid){
continue;
}
CheckValue<IkReal> x165=IKPowWithIntegerCheck(IKsign((((sj16*(r00*r00)))+((sj16*(r01*r01))))),-1);
if(!x165.valid){
continue;
}
j15array[0]=((-1.5707963267949)+(x164.value)+(((1.5707963267949)*(x165.value))));
sj15array[0]=IKsin(j15array[0]);
cj15array[0]=IKcos(j15array[0]);
if( j15array[0] > IKPI )
{
    j15array[0]-=IK2PI;
}
else if( j15array[0] < -IKPI )
{    j15array[0]+=IK2PI;
}
j15valid[0] = true;
for(int ij15 = 0; ij15 < 1; ++ij15)
{
if( !j15valid[ij15] )
{
    continue;
}
_ij15[0] = ij15; _ij15[1] = -1;
for(int iij15 = ij15+1; iij15 < 1; ++iij15)
{
if( j15valid[iij15] && IKabs(cj15array[ij15]-cj15array[iij15]) < IKFAST_SOLUTION_THRESH && IKabs(sj15array[ij15]-sj15array[iij15]) < IKFAST_SOLUTION_THRESH )
{
    j15valid[iij15]=false; _ij15[1] = iij15; break; 
}
}
j15 = j15array[ij15]; cj15 = cj15array[ij15]; sj15 = sj15array[ij15];
{
IkReal evalcond[6];
IkReal x166=IKcos(j15);
IkReal x167=IKsin(j15);
IkReal x168=((1.0)*r01);
IkReal x169=((0.0707296823218818)*sj17);
IkReal x170=((0.997495519808809)*sj17);
IkReal x171=((1.0)*r00);
IkReal x172=((0.997495519808809)*cj17);
IkReal x173=((0.0707296823218818)*cj17);
IkReal x174=((1.0)*cj16);
IkReal x175=(sj16*x167);
IkReal x176=(r00*x167);
IkReal x177=(sj16*x166);
IkReal x178=(cj16*x167);
IkReal x179=(cj16*x166);
evalcond[0]=((((-1.0)*x166*x171))+(((-1.0)*x167*x168)));
evalcond[1]=(((r02*sj16))+((r01*x179))+(((-1.0)*x170))+x173+(((-1.0)*x171*x178)));
evalcond[2]=((((-1.0)*x169))+((r01*x177))+(((-1.0)*x172))+(((-1.0)*r02*x174))+(((-1.0)*x171*x175)));
evalcond[3]=((((-1.0)*x166*x168))+((cj16*x170))+x176+((sj16*x172))+((sj16*x169))+(((-1.0)*cj16*x173)));
evalcond[4]=((((-1.0)*x171))+((x173*x178))+(((-1.0)*x170*x178))+(((-1.0)*x169*x175))+(((-1.0)*x172*x175)));
evalcond[5]=((((-1.0)*x168))+((x169*x177))+((x172*x177))+((x170*x179))+(((-1.0)*x173*x179)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(3);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j15;
vinfos[0].indices[0] = _ij15[0];
vinfos[0].indices[1] = _ij15[1];
vinfos[0].maxsolutions = _nj15;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j16;
vinfos[1].indices[0] = _ij16[0];
vinfos[1].indices[1] = _ij16[1];
vinfos[1].maxsolutions = _nj16;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j17;
vinfos[2].indices[0] = _ij17[0];
vinfos[2].indices[1] = _ij17[1];
vinfos[2].maxsolutions = _nj17;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j15array[1], cj15array[1], sj15array[1];
bool j15valid[1]={false};
_nj15 = 1;
IkReal x180=((0.997495519808809)*sj17);
IkReal x181=((0.0707296823218818)*cj17);
IkReal x182=(r02*sj16);
CheckValue<IkReal> x183=IKPowWithIntegerCheck(IKsign((((cj16*(r01*r01)))+((cj16*(r00*r00))))),-1);
if(!x183.valid){
continue;
}
CheckValue<IkReal> x184 = IKatan2WithCheck(IkReal(((((-1.0)*r00*x180))+((r00*x182))+((r00*x181)))),((((-1.0)*r01*x181))+((r01*x180))+(((-1.0)*r01*x182))),IKFAST_ATAN2_MAGTHRESH);
if(!x184.valid){
continue;
}
j15array[0]=((-1.5707963267949)+(((1.5707963267949)*(x183.value)))+(x184.value));
sj15array[0]=IKsin(j15array[0]);
cj15array[0]=IKcos(j15array[0]);
if( j15array[0] > IKPI )
{
    j15array[0]-=IK2PI;
}
else if( j15array[0] < -IKPI )
{    j15array[0]+=IK2PI;
}
j15valid[0] = true;
for(int ij15 = 0; ij15 < 1; ++ij15)
{
if( !j15valid[ij15] )
{
    continue;
}
_ij15[0] = ij15; _ij15[1] = -1;
for(int iij15 = ij15+1; iij15 < 1; ++iij15)
{
if( j15valid[iij15] && IKabs(cj15array[ij15]-cj15array[iij15]) < IKFAST_SOLUTION_THRESH && IKabs(sj15array[ij15]-sj15array[iij15]) < IKFAST_SOLUTION_THRESH )
{
    j15valid[iij15]=false; _ij15[1] = iij15; break; 
}
}
j15 = j15array[ij15]; cj15 = cj15array[ij15]; sj15 = sj15array[ij15];
{
IkReal evalcond[6];
IkReal x185=IKcos(j15);
IkReal x186=IKsin(j15);
IkReal x187=((1.0)*r01);
IkReal x188=((0.0707296823218818)*sj17);
IkReal x189=((0.997495519808809)*sj17);
IkReal x190=((1.0)*r00);
IkReal x191=((0.997495519808809)*cj17);
IkReal x192=((0.0707296823218818)*cj17);
IkReal x193=((1.0)*cj16);
IkReal x194=(sj16*x186);
IkReal x195=(r00*x186);
IkReal x196=(sj16*x185);
IkReal x197=(cj16*x186);
IkReal x198=(cj16*x185);
evalcond[0]=((((-1.0)*x186*x187))+(((-1.0)*x185*x190)));
evalcond[1]=(((r02*sj16))+((r01*x198))+(((-1.0)*x189))+(((-1.0)*x190*x197))+x192);
evalcond[2]=(((r01*x196))+(((-1.0)*x188))+(((-1.0)*x190*x194))+(((-1.0)*x191))+(((-1.0)*r02*x193)));
evalcond[3]=(((cj16*x189))+x195+((sj16*x191))+(((-1.0)*x185*x187))+((sj16*x188))+(((-1.0)*cj16*x192)));
evalcond[4]=((((-1.0)*x188*x194))+(((-1.0)*x191*x194))+(((-1.0)*x189*x197))+(((-1.0)*x190))+((x192*x197)));
evalcond[5]=((((-1.0)*x192*x198))+(((-1.0)*x187))+((x188*x196))+((x189*x198))+((x191*x196)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(3);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j15;
vinfos[0].indices[0] = _ij15[0];
vinfos[0].indices[1] = _ij15[1];
vinfos[0].maxsolutions = _nj15;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j16;
vinfos[1].indices[0] = _ij16[0];
vinfos[1].indices[1] = _ij16[1];
vinfos[1].maxsolutions = _nj16;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j17;
vinfos[2].indices[0] = _ij17[0];
vinfos[2].indices[1] = _ij17[1];
vinfos[2].maxsolutions = _nj17;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j15array[1], cj15array[1], sj15array[1];
bool j15valid[1]={false};
_nj15 = 1;
CheckValue<IkReal> x199=IKPowWithIntegerCheck(IKsign(((((0.0707296823218818)*cj16*cj17))+(((-0.0707296823218818)*sj16*sj17))+(((-0.997495519808809)*cj17*sj16))+(((-0.997495519808809)*cj16*sj17)))),-1);
if(!x199.valid){
continue;
}
CheckValue<IkReal> x200 = IKatan2WithCheck(IkReal(r00),((-1.0)*r01),IKFAST_ATAN2_MAGTHRESH);
if(!x200.valid){
continue;
}
j15array[0]=((-1.5707963267949)+(((1.5707963267949)*(x199.value)))+(x200.value));
sj15array[0]=IKsin(j15array[0]);
cj15array[0]=IKcos(j15array[0]);
if( j15array[0] > IKPI )
{
    j15array[0]-=IK2PI;
}
else if( j15array[0] < -IKPI )
{    j15array[0]+=IK2PI;
}
j15valid[0] = true;
for(int ij15 = 0; ij15 < 1; ++ij15)
{
if( !j15valid[ij15] )
{
    continue;
}
_ij15[0] = ij15; _ij15[1] = -1;
for(int iij15 = ij15+1; iij15 < 1; ++iij15)
{
if( j15valid[iij15] && IKabs(cj15array[ij15]-cj15array[iij15]) < IKFAST_SOLUTION_THRESH && IKabs(sj15array[ij15]-sj15array[iij15]) < IKFAST_SOLUTION_THRESH )
{
    j15valid[iij15]=false; _ij15[1] = iij15; break; 
}
}
j15 = j15array[ij15]; cj15 = cj15array[ij15]; sj15 = sj15array[ij15];
{
IkReal evalcond[6];
IkReal x201=IKcos(j15);
IkReal x202=IKsin(j15);
IkReal x203=((1.0)*r01);
IkReal x204=((0.0707296823218818)*sj17);
IkReal x205=((0.997495519808809)*sj17);
IkReal x206=((1.0)*r00);
IkReal x207=((0.997495519808809)*cj17);
IkReal x208=((0.0707296823218818)*cj17);
IkReal x209=((1.0)*cj16);
IkReal x210=(sj16*x202);
IkReal x211=(r00*x202);
IkReal x212=(sj16*x201);
IkReal x213=(cj16*x202);
IkReal x214=(cj16*x201);
evalcond[0]=((((-1.0)*x201*x206))+(((-1.0)*x202*x203)));
evalcond[1]=(((r02*sj16))+(((-1.0)*x206*x213))+(((-1.0)*x205))+x208+((r01*x214)));
evalcond[2]=((((-1.0)*x206*x210))+(((-1.0)*r02*x209))+(((-1.0)*x207))+(((-1.0)*x204))+((r01*x212)));
evalcond[3]=((((-1.0)*x201*x203))+x211+((sj16*x204))+((sj16*x207))+((cj16*x205))+(((-1.0)*cj16*x208)));
evalcond[4]=(((x208*x213))+(((-1.0)*x207*x210))+(((-1.0)*x204*x210))+(((-1.0)*x205*x213))+(((-1.0)*x206)));
evalcond[5]=(((x204*x212))+((x207*x212))+((x205*x214))+(((-1.0)*x203))+(((-1.0)*x208*x214)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(3);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j15;
vinfos[0].indices[0] = _ij15[0];
vinfos[0].indices[1] = _ij15[1];
vinfos[0].maxsolutions = _nj15;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j16;
vinfos[1].indices[0] = _ij16[0];
vinfos[1].indices[1] = _ij16[1];
vinfos[1].maxsolutions = _nj16;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j17;
vinfos[2].indices[0] = _ij17[0];
vinfos[2].indices[1] = _ij17[1];
vinfos[2].maxsolutions = _nj17;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
}
}

}

}

} else
{
{
IkReal j15array[2], cj15array[2], sj15array[2];
bool j15valid[2]={false};
_nj15 = 2;
CheckValue<IkReal> x216 = IKatan2WithCheck(IkReal(((-1.0)*r00)),((-1.0)*r01),IKFAST_ATAN2_MAGTHRESH);
if(!x216.valid){
continue;
}
IkReal x215=x216.value;
j15array[0]=((-1.0)*x215);
sj15array[0]=IKsin(j15array[0]);
cj15array[0]=IKcos(j15array[0]);
j15array[1]=((3.14159265358979)+(((-1.0)*x215)));
sj15array[1]=IKsin(j15array[1]);
cj15array[1]=IKcos(j15array[1]);
if( j15array[0] > IKPI )
{
    j15array[0]-=IK2PI;
}
else if( j15array[0] < -IKPI )
{    j15array[0]+=IK2PI;
}
j15valid[0] = true;
if( j15array[1] > IKPI )
{
    j15array[1]-=IK2PI;
}
else if( j15array[1] < -IKPI )
{    j15array[1]+=IK2PI;
}
j15valid[1] = true;
for(int ij15 = 0; ij15 < 2; ++ij15)
{
if( !j15valid[ij15] )
{
    continue;
}
_ij15[0] = ij15; _ij15[1] = -1;
for(int iij15 = ij15+1; iij15 < 2; ++iij15)
{
if( j15valid[iij15] && IKabs(cj15array[ij15]-cj15array[iij15]) < IKFAST_SOLUTION_THRESH && IKabs(sj15array[ij15]-sj15array[iij15]) < IKFAST_SOLUTION_THRESH )
{
    j15valid[iij15]=false; _ij15[1] = iij15; break; 
}
}
j15 = j15array[ij15]; cj15 = cj15array[ij15]; sj15 = sj15array[ij15];

{
IkReal j16eval[3];
IkReal x217=cj17*cj17;
IkReal x218=(cj15*r01);
IkReal x219=(r02*sj17);
IkReal x220=(cj17*sj17);
IkReal x221=(cj17*r02);
IkReal x222=(r00*sj15);
IkReal x223=((14.1029266223667)*cj17);
IkReal x224=((0.997495519808809)*cj17);
IkReal x225=(sj17*x222);
j16eval[0]=((((14.1029266223667)*x219))+((x222*x223))+(((-1.0)*sj17*x218))+x225+(((-1.0)*x218*x223))+(((-1.0)*x221)));
j16eval[1]=IKsign(((((0.0707296823218818)*x225))+((x222*x224))+(((0.997495519808809)*x219))+(((-1.0)*x218*x224))+(((-0.0707296823218818)*sj17*x218))+(((-0.0707296823218818)*x221))));
j16eval[2]=((IKabs(((-0.00500268796135431)+(((-0.141105082467155)*x220))+(((-0.989994624077291)*x217))+(r02*r02))))+(IKabs(((-0.0705525412335773)+(((-0.989994624077291)*x220))+(((-1.0)*r02*x222))+((r02*x218))+(((0.141105082467155)*x217))))));
if( IKabs(j16eval[0]) < 0.0000010000000000  || IKabs(j16eval[1]) < 0.0000010000000000  || IKabs(j16eval[2]) < 0.0000010000000000  )
{
{
IkReal j16eval[3];
IkReal x226=cj17*cj17;
IkReal x227=(cj15*r01);
IkReal x228=(cj17*r02);
IkReal x229=(r00*sj15);
IkReal x230=((0.0707296823218818)*cj17);
IkReal x231=((14.1029266223667)*sj17);
IkReal x232=(r02*sj17);
IkReal x233=((0.997495519808809)*sj17);
IkReal x234=(cj17*sj17);
j16eval[0]=((((-1.0)*cj17*x227))+((cj17*x229))+(((14.1029266223667)*x228))+x232+((x227*x231))+(((-1.0)*x229*x231)));
j16eval[1]=((IKabs(((0.0705525412335773)+(((-0.141105082467155)*x226))+(((-1.0)*r02*x229))+(((0.989994624077291)*x234))+((r02*x227)))))+(IKabs(((0.994997312038646)+(((-1.0)*(r02*r02)))+(((-0.141105082467155)*x234))+(((-0.989994624077291)*x226))))));
j16eval[2]=IKsign((((x229*x230))+(((-1.0)*x227*x230))+(((0.0707296823218818)*x232))+((x227*x233))+(((0.997495519808809)*x228))+(((-1.0)*x229*x233))));
if( IKabs(j16eval[0]) < 0.0000010000000000  || IKabs(j16eval[1]) < 0.0000010000000000  || IKabs(j16eval[2]) < 0.0000010000000000  )
{
{
IkReal j16eval[3];
IkReal x235=cj15*cj15;
IkReal x236=cj17*cj17;
IkReal x237=(sj15*sj17);
IkReal x238=(cj17*r00);
IkReal x239=((1.0)*r02);
IkReal x240=(cj17*sj15);
IkReal x241=(cj15*r01);
IkReal x242=(r00*sj17);
IkReal x243=(sj15*x236);
IkReal x244=(x235*x242);
j16eval[0]=((((-1.0)*x244))+(((-1.0)*x237*x241))+(((14.1029266223667)*r02*x237))+(((-14.1029266223667)*x240*x241))+x242+(((14.1029266223667)*x238))+(((-1.0)*x239*x240))+(((-14.1029266223667)*x235*x238)));
j16eval[1]=IKsign(((((-0.0707296823218818)*r02*x240))+(((-0.997495519808809)*x235*x238))+(((-0.997495519808809)*x240*x241))+(((-0.0707296823218818)*x244))+(((0.997495519808809)*x238))+(((0.0707296823218818)*x242))+(((-0.0707296823218818)*x237*x241))+(((0.997495519808809)*r02*x237))));
j16eval[2]=((IKabs(((((-0.141105082467155)*cj17*x237))+((r00*x241))+(((-0.989994624077291)*x243))+(((-1.0)*sj15*(r00*r00)))+(((0.994997312038646)*sj15)))))+(IKabs(((((-0.0705525412335773)*sj15))+(((0.141105082467155)*x243))+(((-1.0)*r00*x239))+(((-0.989994624077291)*cj17*x237))))));
if( IKabs(j16eval[0]) < 0.0000010000000000  || IKabs(j16eval[1]) < 0.0000010000000000  || IKabs(j16eval[2]) < 0.0000010000000000  )
{
{
IkReal evalcond[2];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j15))), 6.28318530717959)));
evalcond[1]=((-1.0)*r00);
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j16eval[3];
sj15=0;
cj15=1.0;
j15=0;
IkReal x245=cj17*cj17;
IkReal x246=(cj17*sj17);
IkReal x247=(cj17*r02);
IkReal x248=(r02*sj17);
IkReal x249=(r01*sj17);
IkReal x250=(cj17*r01);
j16eval[0]=((((-1.0)*x249))+(((-1.0)*x247))+(((-14.1029266223667)*x250))+(((14.1029266223667)*x248)));
j16eval[1]=((IKabs(((-0.0705525412335773)+(((0.141105082467155)*x245))+((r01*r02))+(((-0.989994624077291)*x246)))))+(IKabs(((-0.00500268796135431)+(((-0.141105082467155)*x246))+(r02*r02)+(((-0.989994624077291)*x245))))));
j16eval[2]=IKsign(((((-0.997495519808809)*x250))+(((0.997495519808809)*x248))+(((-0.0707296823218818)*x247))+(((-0.0707296823218818)*x249))));
if( IKabs(j16eval[0]) < 0.0000010000000000  || IKabs(j16eval[1]) < 0.0000010000000000  || IKabs(j16eval[2]) < 0.0000010000000000  )
{
{
IkReal j16eval[3];
sj15=0;
cj15=1.0;
j15=0;
IkReal x251=cj17*cj17;
IkReal x252=(r02*sj17);
IkReal x253=(r01*sj17);
IkReal x254=(cj17*sj17);
IkReal x255=(cj17*r01);
IkReal x256=(cj17*r02);
j16eval[0]=((((-14.1029266223667)*x252))+(((14.1029266223667)*x255))+x256+x253);
j16eval[1]=IKsign(((((-0.997495519808809)*x252))+(((0.0707296823218818)*x253))+(((0.0707296823218818)*x256))+(((0.997495519808809)*x255))));
j16eval[2]=((IKabs(((0.0705525412335773)+(((0.989994624077291)*x254))+(((-0.141105082467155)*x251))+(((-1.0)*r01*r02)))))+(IKabs(((-0.994997312038646)+(((0.989994624077291)*x251))+(((0.141105082467155)*x254))+(r01*r01)))));
if( IKabs(j16eval[0]) < 0.0000010000000000  || IKabs(j16eval[1]) < 0.0000010000000000  || IKabs(j16eval[2]) < 0.0000010000000000  )
{
{
IkReal j16eval[3];
sj15=0;
cj15=1.0;
j15=0;
IkReal x257=cj17*cj17;
IkReal x258=(r02*sj17);
IkReal x259=(cj17*r01);
IkReal x260=(r01*sj17);
IkReal x261=(cj17*r02);
IkReal x262=(cj17*sj17);
j16eval[0]=(x258+(((14.1029266223667)*x260))+(((14.1029266223667)*x261))+(((-1.0)*x259)));
j16eval[1]=((IKabs(((0.0705525412335773)+(((0.989994624077291)*x262))+(((-0.141105082467155)*x257))+((r01*r02)))))+(IKabs(((0.994997312038646)+(((-0.141105082467155)*x262))+(((-1.0)*(r02*r02)))+(((-0.989994624077291)*x257))))));
j16eval[2]=IKsign(((((0.0707296823218818)*x258))+(((0.997495519808809)*x260))+(((0.997495519808809)*x261))+(((-0.0707296823218818)*x259))));
if( IKabs(j16eval[0]) < 0.0000010000000000  || IKabs(j16eval[1]) < 0.0000010000000000  || IKabs(j16eval[2]) < 0.0000010000000000  )
{
{
IkReal evalcond[2];
bool bgotonextstatement = true;
do
{
IkReal x263=((((-1.0)*r01))+(((14.1029266223667)*r02)));
IkReal x264=(r02+(((14.1029266223667)*r01)));
IkReal x266 = ((x263*x263)+(x264*x264));
if(IKabs(x266)==0){
continue;
}
IkReal x265=pow(x266,-0.5);
CheckValue<IkReal> x267 = IKatan2WithCheck(IkReal(x263),x264,IKFAST_ATAN2_MAGTHRESH);
if(!x267.valid){
continue;
}
IkReal gconst0=((-1.0)*(x267.value));
IkReal gconst1=((-1.0)*x263*x265);
IkReal gconst2=(x264*x265);
IkReal x268=j17;
CheckValue<IkReal> x271 = IKatan2WithCheck(IkReal(((((-1.0)*r01))+(((14.1029266223667)*r02)))),(r02+(((14.1029266223667)*r01))),IKFAST_ATAN2_MAGTHRESH);
if(!x271.valid){
continue;
}
IkReal x269=x271.value;
IkReal x270=x269;
if(((((j17*x268))+((j17*x270))+((x269*x270))+((x268*x269)))) < -0.00001)
continue;
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKsqrt((((j17*x268))+((j17*x270))+((x269*x270))+((x268*x269)))))), 6.28318530717959)));
evalcond[1]=((-1.0)*r00);
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j16eval[1];
IkReal x272=((1.0)*r01);
IkReal x273=((((-1.0)*x272))+(((14.1029266223667)*r02)));
IkReal x274=(r02+(((14.1029266223667)*r01)));
IkReal x276 = ((x273*x273)+(x274*x274));
if(IKabs(x276)==0){
continue;
}
IkReal x275=pow(x276,-0.5);
sj15=0;
cj15=1.0;
j15=0;
sj17=gconst1;
cj17=gconst2;
CheckValue<IkReal> x277 = IKatan2WithCheck(IkReal(((((14.1029262584782)*r02))+(((-1.0)*x272)))),((((14.1029262584782)*r01))+r02),IKFAST_ATAN2_MAGTHRESH);
if(!x277.valid){
continue;
}
j17=((-1.0)*(x277.value));
CheckValue<IkReal> x278 = IKatan2WithCheck(IkReal(x273),x274,IKFAST_ATAN2_MAGTHRESH);
if(!x278.valid){
continue;
}
IkReal gconst0=((-1.0)*(x278.value));
IkReal gconst1=((-1.0)*x273*x275);
IkReal gconst2=(x274*x275);
IkReal x279=r01*r01;
IkReal x280=r02*r02;
CheckValue<IkReal> x284=IKPowWithIntegerCheck((x279+x280),-1);
if(!x284.valid){
continue;
}
IkReal x281=x284.value;
IkReal x282=(r02*x281);
IkReal x283=(x279*x281);
j16eval[0]=((IKabs((((r01*x282))+((x282*(r01*r01*r01)))+((r01*x282*(r02*r02))))))+(IKabs(((((-1.0)*x283))+((x281*(x280*x280)))+((x280*x283))))));
if( IKabs(j16eval[0]) < 0.0000010000000000  )
{
{
IkReal j16eval[1];
IkReal x285=((1.0)*r01);
IkReal x286=((((-1.0)*x285))+(((14.1029266223667)*r02)));
IkReal x287=(r02+(((14.1029266223667)*r01)));
IkReal x289 = ((x287*x287)+(x286*x286));
if(IKabs(x289)==0){
continue;
}
IkReal x288=pow(x289,-0.5);
sj15=0;
cj15=1.0;
j15=0;
sj17=gconst1;
cj17=gconst2;
CheckValue<IkReal> x290 = IKatan2WithCheck(IkReal(((((14.1029262584782)*r02))+(((-1.0)*x285)))),((((14.1029262584782)*r01))+r02),IKFAST_ATAN2_MAGTHRESH);
if(!x290.valid){
continue;
}
j17=((-1.0)*(x290.value));
CheckValue<IkReal> x291 = IKatan2WithCheck(IkReal(x286),x287,IKFAST_ATAN2_MAGTHRESH);
if(!x291.valid){
continue;
}
IkReal gconst0=((-1.0)*(x291.value));
IkReal gconst1=((-1.0)*x286*x288);
IkReal gconst2=(x287*x288);
IkReal x292=r01*r01;
IkReal x293=r02*r02;
IkReal x294=((1.0)*x293);
CheckValue<IkReal> x300=IKPowWithIntegerCheck((x292+x293),-1);
if(!x300.valid){
continue;
}
IkReal x295=x300.value;
CheckValue<IkReal> x301=IKPowWithIntegerCheck(((((-1.0)*x292))+(((-1.0)*x294))),-1);
if(!x301.valid){
continue;
}
IkReal x296=x301.value;
IkReal x297=((1.0)*x296);
IkReal x298=(r02*x297);
IkReal x299=(r01*x297);
j16eval[0]=((IKabs((((x292*x293*x295))+(((-1.0)*x294*x295))+((x295*(x292*x292))))))+(IKabs(((((-1.0)*x298*(r01*r01*r01)))+(((-1.0)*r01*x298*(r02*r02)))+(((-1.0)*r01*x298))))));
if( IKabs(j16eval[0]) < 0.0000010000000000  )
{
{
IkReal j16eval[2];
IkReal x302=((1.0)*r01);
IkReal x303=((((14.1029266223667)*r02))+(((-1.0)*x302)));
IkReal x304=(r02+(((14.1029266223667)*r01)));
IkReal x306 = ((x303*x303)+(x304*x304));
if(IKabs(x306)==0){
continue;
}
IkReal x305=pow(x306,-0.5);
sj15=0;
cj15=1.0;
j15=0;
sj17=gconst1;
cj17=gconst2;
CheckValue<IkReal> x307 = IKatan2WithCheck(IkReal(((((14.1029262584782)*r02))+(((-1.0)*x302)))),((((14.1029262584782)*r01))+r02),IKFAST_ATAN2_MAGTHRESH);
if(!x307.valid){
continue;
}
j17=((-1.0)*(x307.value));
CheckValue<IkReal> x308 = IKatan2WithCheck(IkReal(x303),x304,IKFAST_ATAN2_MAGTHRESH);
if(!x308.valid){
continue;
}
IkReal gconst0=((-1.0)*(x308.value));
IkReal gconst1=((-1.0)*x303*x305);
IkReal gconst2=(x304*x305);
IkReal x309=((((-1.0)*(r02*r02)))+(((-1.0)*(r01*r01))));
j16eval[0]=x309;
j16eval[1]=IKsign(x309);
if( IKabs(j16eval[0]) < 0.0000010000000000  || IKabs(j16eval[1]) < 0.0000010000000000  )
{
continue; // no branches [j16]

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x310=((0.997495519808809)*r02);
IkReal x311=((0.0707296823218818)*r02);
IkReal x312=((0.0707296823218818)*r01);
IkReal x313=((0.997495519808809)*r01);
CheckValue<IkReal> x314=IKPowWithIntegerCheck(IKsign(((((-1.0)*(r02*r02)))+(((-1.0)*(r01*r01))))),-1);
if(!x314.valid){
continue;
}
CheckValue<IkReal> x315 = IKatan2WithCheck(IkReal(((((-1.0)*gconst2*x313))+(((-1.0)*gconst1*x312))+(((-1.0)*gconst1*x310))+((gconst2*x311)))),((((-1.0)*gconst1*x313))+((gconst2*x312))+((gconst2*x310))+((gconst1*x311))),IKFAST_ATAN2_MAGTHRESH);
if(!x315.valid){
continue;
}
j16array[0]=((-1.5707963267949)+(((1.5707963267949)*(x314.value)))+(x315.value));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[4];
IkReal x316=IKsin(j16);
IkReal x317=IKcos(j16);
IkReal x318=((1.0)*r02);
IkReal x319=((0.0707296823218818)*gconst2);
IkReal x320=((0.0707296823218818)*gconst1);
IkReal x321=((0.0707296823218818)*x316);
IkReal x322=((0.997495519808809)*x316);
IkReal x323=((0.997495519808809)*x317);
evalcond[0]=(((r02*x316))+x319+((r01*x317))+(((-0.997495519808809)*gconst1)));
evalcond[1]=((((-1.0)*x320))+((r01*x316))+(((-0.997495519808809)*gconst2))+(((-1.0)*x317*x318)));
evalcond[2]=(((gconst1*x322))+(((-1.0)*x317*x320))+(((-1.0)*x318))+(((-1.0)*gconst2*x323))+(((-1.0)*x316*x319)));
evalcond[3]=(((gconst1*x323))+(((-1.0)*r01))+((gconst2*x322))+((x316*x320))+(((-1.0)*x317*x319)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(3);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j15;
vinfos[0].indices[0] = _ij15[0];
vinfos[0].indices[1] = _ij15[1];
vinfos[0].maxsolutions = _nj15;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j16;
vinfos[1].indices[0] = _ij16[0];
vinfos[1].indices[1] = _ij16[1];
vinfos[1].maxsolutions = _nj16;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j17;
vinfos[2].indices[0] = _ij17[0];
vinfos[2].indices[1] = _ij17[1];
vinfos[2].maxsolutions = _nj17;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x324=gconst1*gconst1;
IkReal x325=gconst2*gconst2;
IkReal x326=(gconst1*gconst2);
CheckValue<IkReal> x327=IKPowWithIntegerCheck(IKsign(((((-0.997495519808809)*gconst1*r02))+(((0.997495519808809)*gconst2*r01))+(((0.0707296823218818)*gconst1*r01))+(((0.0707296823218818)*gconst2*r02)))),-1);
if(!x327.valid){
continue;
}
CheckValue<IkReal> x328 = IKatan2WithCheck(IkReal(((((-0.00500268796135431)*x325))+(((-0.994997312038646)*x324))+(((0.141105082467155)*x326))+(r01*r01))),((((0.989994624077291)*x326))+(((-0.0705525412335773)*x325))+(((0.0705525412335773)*x324))+(((-1.0)*r01*r02))),IKFAST_ATAN2_MAGTHRESH);
if(!x328.valid){
continue;
}
j16array[0]=((-1.5707963267949)+(((1.5707963267949)*(x327.value)))+(x328.value));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[4];
IkReal x329=IKsin(j16);
IkReal x330=IKcos(j16);
IkReal x331=((1.0)*r02);
IkReal x332=((0.0707296823218818)*gconst2);
IkReal x333=((0.0707296823218818)*gconst1);
IkReal x334=((0.0707296823218818)*x329);
IkReal x335=((0.997495519808809)*x329);
IkReal x336=((0.997495519808809)*x330);
evalcond[0]=(((r01*x330))+((r02*x329))+x332+(((-0.997495519808809)*gconst1)));
evalcond[1]=(((r01*x329))+(((-1.0)*x330*x331))+(((-0.997495519808809)*gconst2))+(((-1.0)*x333)));
evalcond[2]=((((-1.0)*gconst2*x336))+((gconst1*x335))+(((-1.0)*x329*x332))+(((-1.0)*x330*x333))+(((-1.0)*x331)));
evalcond[3]=(((gconst1*x336))+(((-1.0)*r01))+(((-1.0)*x330*x332))+((x329*x333))+((gconst2*x335)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(3);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j15;
vinfos[0].indices[0] = _ij15[0];
vinfos[0].indices[1] = _ij15[1];
vinfos[0].maxsolutions = _nj15;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j16;
vinfos[1].indices[0] = _ij16[0];
vinfos[1].indices[1] = _ij16[1];
vinfos[1].maxsolutions = _nj16;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j17;
vinfos[2].indices[0] = _ij17[0];
vinfos[2].indices[1] = _ij17[1];
vinfos[2].maxsolutions = _nj17;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x337=gconst2*gconst2;
IkReal x338=gconst1*gconst1;
IkReal x339=(gconst1*gconst2);
CheckValue<IkReal> x340 = IKatan2WithCheck(IkReal(((((-0.994997312038646)*x337))+(((-0.00500268796135431)*x338))+(r02*r02)+(((-0.141105082467155)*x339)))),((((-0.989994624077291)*x339))+(((-0.0705525412335773)*x338))+((r01*r02))+(((0.0705525412335773)*x337))),IKFAST_ATAN2_MAGTHRESH);
if(!x340.valid){
continue;
}
CheckValue<IkReal> x341=IKPowWithIntegerCheck(IKsign(((((-0.0707296823218818)*gconst2*r02))+(((-0.997495519808809)*gconst2*r01))+(((-0.0707296823218818)*gconst1*r01))+(((0.997495519808809)*gconst1*r02)))),-1);
if(!x341.valid){
continue;
}
j16array[0]=((-1.5707963267949)+(x340.value)+(((1.5707963267949)*(x341.value))));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[4];
IkReal x342=IKsin(j16);
IkReal x343=IKcos(j16);
IkReal x344=((1.0)*r02);
IkReal x345=((0.0707296823218818)*gconst2);
IkReal x346=((0.0707296823218818)*gconst1);
IkReal x347=((0.0707296823218818)*x342);
IkReal x348=((0.997495519808809)*x342);
IkReal x349=((0.997495519808809)*x343);
evalcond[0]=(((r01*x343))+x345+(((-0.997495519808809)*gconst1))+((r02*x342)));
evalcond[1]=(((r01*x342))+(((-0.997495519808809)*gconst2))+(((-1.0)*x343*x344))+(((-1.0)*x346)));
evalcond[2]=((((-1.0)*x343*x346))+(((-1.0)*gconst2*x349))+(((-1.0)*x344))+((gconst1*x348))+(((-1.0)*x342*x345)));
evalcond[3]=((((-1.0)*r01))+(((-1.0)*x343*x345))+((gconst1*x349))+((gconst2*x348))+((x342*x346)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(3);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j15;
vinfos[0].indices[0] = _ij15[0];
vinfos[0].indices[1] = _ij15[1];
vinfos[0].maxsolutions = _nj15;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j16;
vinfos[1].indices[0] = _ij16[0];
vinfos[1].indices[1] = _ij16[1];
vinfos[1].maxsolutions = _nj16;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j17;
vinfos[2].indices[0] = _ij17[0];
vinfos[2].indices[1] = _ij17[1];
vinfos[2].maxsolutions = _nj17;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x350=((((-1.0)*r01))+(((14.1029266223667)*r02)));
IkReal x351=(r02+(((14.1029266223667)*r01)));
IkReal x353 = ((x350*x350)+(x351*x351));
if(IKabs(x353)==0){
continue;
}
IkReal x352=pow(x353,-0.5);
CheckValue<IkReal> x354 = IKatan2WithCheck(IkReal(x350),x351,IKFAST_ATAN2_MAGTHRESH);
if(!x354.valid){
continue;
}
IkReal gconst3=((3.14159265358979)+(((-1.0)*(x354.value))));
IkReal gconst4=((1.0)*x350*x352);
IkReal gconst5=((-1.0)*x351*x352);
IkReal x355=j17;
CheckValue<IkReal> x358 = IKatan2WithCheck(IkReal(((((-1.0)*r01))+(((14.1029266223667)*r02)))),(r02+(((14.1029266223667)*r01))),IKFAST_ATAN2_MAGTHRESH);
if(!x358.valid){
continue;
}
IkReal x356=x358.value;
IkReal x357=x356;
if((((9.86960440108936)+((x356*x357))+((x355*x356))+((j17*x355))+((j17*x357))+(((-3.14159265358979)*x356))+(((-3.14159265358979)*x357))+(((-3.14159265358979)*x355))+(((-3.14159265358979)*j17)))) < -0.00001)
continue;
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKsqrt(((9.86960440108936)+((x356*x357))+((x355*x356))+((j17*x355))+((j17*x357))+(((-3.14159265358979)*x356))+(((-3.14159265358979)*x357))+(((-3.14159265358979)*x355))+(((-3.14159265358979)*j17)))))), 6.28318530717959)));
evalcond[1]=((-1.0)*r00);
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x359=gconst5*gconst5;
IkReal x360=gconst4*gconst4;
IkReal x361=(gconst4*gconst5);
CheckValue<IkReal> x362=IKPowWithIntegerCheck(IKsign(((((-0.0707296823218818)*gconst5*r02))+(((-0.0707296823218818)*gconst4*r01))+(((0.997495519808809)*gconst4*r02))+(((-0.997495519808809)*gconst5*r01)))),-1);
if(!x362.valid){
continue;
}
CheckValue<IkReal> x363 = IKatan2WithCheck(IkReal(((((-0.00500268796135431)*x360))+(((-0.994997312038646)*x359))+(((-0.141105082467155)*x361))+(r02*r02))),((((-0.989994624077291)*x361))+((r01*r02))+(((-0.0705525412335773)*x360))+(((0.0705525412335773)*x359))),IKFAST_ATAN2_MAGTHRESH);
if(!x363.valid){
continue;
}
j16array[0]=((-1.5707963267949)+(((1.5707963267949)*(x362.value)))+(x363.value));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[4];
IkReal x364=IKsin(j16);
IkReal x365=IKcos(j16);
IkReal x366=((0.0707296823218818)*gconst4);
IkReal x367=((1.0)*r02);
IkReal x368=((0.0707296823218818)*gconst5);
IkReal x369=((0.997495519808809)*gconst4);
IkReal x370=((0.997495519808809)*gconst5);
IkReal x371=((0.997495519808809)*x364);
evalcond[0]=(((r01*x365))+(((-1.0)*x369))+x368+((r02*x364)));
evalcond[1]=(((r01*x364))+(((-1.0)*x366))+(((-1.0)*x370))+(((-1.0)*x365*x367)));
evalcond[2]=(((x364*x369))+(((-1.0)*x367))+(((-1.0)*x364*x368))+(((-1.0)*x365*x366))+(((-1.0)*x365*x370)));
evalcond[3]=(((x364*x366))+((x364*x370))+(((-1.0)*r01))+((x365*x369))+(((-1.0)*x365*x368)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(3);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j15;
vinfos[0].indices[0] = _ij15[0];
vinfos[0].indices[1] = _ij15[1];
vinfos[0].maxsolutions = _nj15;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j16;
vinfos[1].indices[0] = _ij16[0];
vinfos[1].indices[1] = _ij16[1];
vinfos[1].maxsolutions = _nj16;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j17;
vinfos[2].indices[0] = _ij17[0];
vinfos[2].indices[1] = _ij17[1];
vinfos[2].maxsolutions = _nj17;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x372=((((-14.1029266223667)*r02))+r01);
IkReal x373=(r02+(((14.1029266223667)*r01)));
IkReal x375 = ((x373*x373)+(x372*x372));
if(IKabs(x375)==0){
continue;
}
IkReal x374=pow(x375,-0.5);
CheckValue<IkReal> x376 = IKatan2WithCheck(IkReal(x373),x372,IKFAST_ATAN2_MAGTHRESH);
if(!x376.valid){
continue;
}
IkReal gconst6=((-1.0)*(x376.value));
IkReal gconst7=((-1.0)*x373*x374);
IkReal gconst8=(x372*x374);
IkReal x377=j17;
CheckValue<IkReal> x380 = IKatan2WithCheck(IkReal((r02+(((14.1029266223667)*r01)))),((((-14.1029266223667)*r02))+r01),IKFAST_ATAN2_MAGTHRESH);
if(!x380.valid){
continue;
}
IkReal x378=x380.value;
IkReal x379=x378;
if(((((j17*x379))+((j17*x377))+((x378*x379))+((x377*x378)))) < -0.00001)
continue;
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKsqrt((((j17*x379))+((j17*x377))+((x378*x379))+((x377*x378)))))), 6.28318530717959)));
evalcond[1]=((-1.0)*r00);
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j16eval[1];
IkReal x381=((((-14.1029266223667)*r02))+r01);
IkReal x382=(r02+(((14.1029266223667)*r01)));
IkReal x383=x374;
sj15=0;
cj15=1.0;
j15=0;
sj17=gconst7;
cj17=gconst8;
CheckValue<IkReal> x384 = IKatan2WithCheck(IkReal(((((14.1029262584782)*r01))+r02)),(r01+(((-14.1029262584782)*r02))),IKFAST_ATAN2_MAGTHRESH);
if(!x384.valid){
continue;
}
j17=((-1.0)*(x384.value));
CheckValue<IkReal> x385 = IKatan2WithCheck(IkReal(x382),x381,IKFAST_ATAN2_MAGTHRESH);
if(!x385.valid){
continue;
}
IkReal gconst6=((-1.0)*(x385.value));
IkReal gconst7=((-1.0)*x382*x383);
IkReal gconst8=(x381*x383);
IkReal x386=r01*r01;
IkReal x387=r02*r02;
CheckValue<IkReal> x391=IKPowWithIntegerCheck((x386+x387),-1);
if(!x391.valid){
continue;
}
IkReal x388=x391.value;
IkReal x389=(r02*x388);
IkReal x390=(x387*x388);
j16eval[0]=((IKabs((((r01*x389*(r02*r02)))+((x389*(r01*r01*r01)))+((r01*x389)))))+(IKabs(((((-1.0)*x390))+((x386*x390))+((x388*(x386*x386)))))));
if( IKabs(j16eval[0]) < 0.0000010000000000  )
{
{
IkReal j16eval[1];
IkReal x392=((((-14.1029266223667)*r02))+r01);
IkReal x393=(r02+(((14.1029266223667)*r01)));
IkReal x394=x374;
sj15=0;
cj15=1.0;
j15=0;
sj17=gconst7;
cj17=gconst8;
CheckValue<IkReal> x395 = IKatan2WithCheck(IkReal(((((14.1029262584782)*r01))+r02)),(r01+(((-14.1029262584782)*r02))),IKFAST_ATAN2_MAGTHRESH);
if(!x395.valid){
continue;
}
j17=((-1.0)*(x395.value));
CheckValue<IkReal> x396 = IKatan2WithCheck(IkReal(x393),x392,IKFAST_ATAN2_MAGTHRESH);
if(!x396.valid){
continue;
}
IkReal gconst6=((-1.0)*(x396.value));
IkReal gconst7=((-1.0)*x393*x394);
IkReal gconst8=(x392*x394);
IkReal x397=r01*r01;
IkReal x398=r02*r02;
CheckValue<IkReal> x402=IKPowWithIntegerCheck((x397+x398),-1);
if(!x402.valid){
continue;
}
IkReal x399=x402.value;
IkReal x400=(r02*x399);
IkReal x401=(x397*x399);
j16eval[0]=((IKabs((((r01*x400*(r02*r02)))+((r01*x400))+((x400*(r01*r01*r01))))))+(IKabs(((((-1.0)*x398*x401))+x401+(((-1.0)*x399*(x398*x398)))))));
if( IKabs(j16eval[0]) < 0.0000010000000000  )
{
{
IkReal j16eval[2];
IkReal x403=((((-14.1029266223667)*r02))+r01);
IkReal x404=(r02+(((14.1029266223667)*r01)));
IkReal x405=x374;
sj15=0;
cj15=1.0;
j15=0;
sj17=gconst7;
cj17=gconst8;
CheckValue<IkReal> x406 = IKatan2WithCheck(IkReal(((((14.1029262584782)*r01))+r02)),(r01+(((-14.1029262584782)*r02))),IKFAST_ATAN2_MAGTHRESH);
if(!x406.valid){
continue;
}
j17=((-1.0)*(x406.value));
CheckValue<IkReal> x407 = IKatan2WithCheck(IkReal(x404),x403,IKFAST_ATAN2_MAGTHRESH);
if(!x407.valid){
continue;
}
IkReal gconst6=((-1.0)*(x407.value));
IkReal gconst7=((-1.0)*x404*x405);
IkReal gconst8=(x403*x405);
IkReal x408=((((-1.0)*(r02*r02)))+(((-1.0)*(r01*r01))));
j16eval[0]=x408;
j16eval[1]=IKsign(x408);
if( IKabs(j16eval[0]) < 0.0000010000000000  || IKabs(j16eval[1]) < 0.0000010000000000  )
{
continue; // no branches [j16]

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x409=((0.997495519808809)*r01);
IkReal x410=((0.0707296823218818)*r02);
IkReal x411=((0.997495519808809)*r02);
IkReal x412=((0.0707296823218818)*r01);
CheckValue<IkReal> x413 = IKatan2WithCheck(IkReal(((((-1.0)*gconst8*x409))+((gconst8*x410))+(((-1.0)*gconst7*x411))+(((-1.0)*gconst7*x412)))),(((gconst7*x410))+((gconst8*x411))+((gconst8*x412))+(((-1.0)*gconst7*x409))),IKFAST_ATAN2_MAGTHRESH);
if(!x413.valid){
continue;
}
CheckValue<IkReal> x414=IKPowWithIntegerCheck(IKsign(((((-1.0)*(r02*r02)))+(((-1.0)*(r01*r01))))),-1);
if(!x414.valid){
continue;
}
j16array[0]=((-1.5707963267949)+(x413.value)+(((1.5707963267949)*(x414.value))));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[4];
IkReal x415=IKsin(j16);
IkReal x416=IKcos(j16);
IkReal x417=((1.0)*r02);
IkReal x418=((0.0707296823218818)*gconst8);
IkReal x419=((0.997495519808809)*gconst8);
IkReal x420=(gconst7*x416);
IkReal x421=(gconst7*x415);
evalcond[0]=(((r01*x416))+x418+(((-0.997495519808809)*gconst7))+((r02*x415)));
evalcond[1]=((((-0.0707296823218818)*gconst7))+((r01*x415))+(((-1.0)*x416*x417))+(((-1.0)*x419)));
evalcond[2]=((((0.997495519808809)*x421))+(((-1.0)*x416*x419))+(((-0.0707296823218818)*x420))+(((-1.0)*x415*x418))+(((-1.0)*x417)));
evalcond[3]=((((0.997495519808809)*x420))+((x415*x419))+(((-1.0)*r01))+(((0.0707296823218818)*x421))+(((-1.0)*x416*x418)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(3);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j15;
vinfos[0].indices[0] = _ij15[0];
vinfos[0].indices[1] = _ij15[1];
vinfos[0].maxsolutions = _nj15;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j16;
vinfos[1].indices[0] = _ij16[0];
vinfos[1].indices[1] = _ij16[1];
vinfos[1].maxsolutions = _nj16;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j17;
vinfos[2].indices[0] = _ij17[0];
vinfos[2].indices[1] = _ij17[1];
vinfos[2].maxsolutions = _nj17;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x422=gconst8*gconst8;
IkReal x423=gconst7*gconst7;
IkReal x424=(gconst7*gconst8);
CheckValue<IkReal> x425 = IKatan2WithCheck(IkReal(((((0.989994624077291)*x424))+(((-0.0705525412335773)*x422))+((r01*r02))+(((0.0705525412335773)*x423)))),((((-1.0)*(r02*r02)))+(((-0.141105082467155)*x424))+(((0.00500268796135431)*x422))+(((0.994997312038646)*x423))),IKFAST_ATAN2_MAGTHRESH);
if(!x425.valid){
continue;
}
CheckValue<IkReal> x426=IKPowWithIntegerCheck(IKsign(((((0.0707296823218818)*gconst7*r02))+(((0.997495519808809)*gconst8*r02))+(((0.997495519808809)*gconst7*r01))+(((-0.0707296823218818)*gconst8*r01)))),-1);
if(!x426.valid){
continue;
}
j16array[0]=((-1.5707963267949)+(x425.value)+(((1.5707963267949)*(x426.value))));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[4];
IkReal x427=IKsin(j16);
IkReal x428=IKcos(j16);
IkReal x429=((1.0)*r02);
IkReal x430=((0.0707296823218818)*gconst8);
IkReal x431=((0.997495519808809)*gconst8);
IkReal x432=(gconst7*x428);
IkReal x433=(gconst7*x427);
evalcond[0]=(((r02*x427))+((r01*x428))+x430+(((-0.997495519808809)*gconst7)));
evalcond[1]=((((-1.0)*x431))+(((-0.0707296823218818)*gconst7))+((r01*x427))+(((-1.0)*x428*x429)));
evalcond[2]=((((-1.0)*x427*x430))+(((-1.0)*x429))+(((-0.0707296823218818)*x432))+(((-1.0)*x428*x431))+(((0.997495519808809)*x433)));
evalcond[3]=((((0.0707296823218818)*x433))+(((-1.0)*r01))+(((-1.0)*x428*x430))+(((0.997495519808809)*x432))+((x427*x431)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(3);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j15;
vinfos[0].indices[0] = _ij15[0];
vinfos[0].indices[1] = _ij15[1];
vinfos[0].maxsolutions = _nj15;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j16;
vinfos[1].indices[0] = _ij16[0];
vinfos[1].indices[1] = _ij16[1];
vinfos[1].maxsolutions = _nj16;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j17;
vinfos[2].indices[0] = _ij17[0];
vinfos[2].indices[1] = _ij17[1];
vinfos[2].maxsolutions = _nj17;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x434=gconst8*gconst8;
IkReal x435=gconst7*gconst7;
IkReal x436=(gconst7*gconst8);
CheckValue<IkReal> x437=IKPowWithIntegerCheck(IKsign(((((0.0707296823218818)*gconst7*r02))+(((0.997495519808809)*gconst8*r02))+(((0.997495519808809)*gconst7*r01))+(((-0.0707296823218818)*gconst8*r01)))),-1);
if(!x437.valid){
continue;
}
CheckValue<IkReal> x438 = IKatan2WithCheck(IkReal(((((0.0705525412335773)*x435))+(((0.989994624077291)*x436))+((r01*r02))+(((-0.0705525412335773)*x434)))),((((-0.00500268796135431)*x435))+(((-0.994997312038646)*x434))+(((-0.141105082467155)*x436))+(r01*r01)),IKFAST_ATAN2_MAGTHRESH);
if(!x438.valid){
continue;
}
j16array[0]=((-1.5707963267949)+(((1.5707963267949)*(x437.value)))+(x438.value));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[4];
IkReal x439=IKsin(j16);
IkReal x440=IKcos(j16);
IkReal x441=((1.0)*r02);
IkReal x442=((0.0707296823218818)*gconst8);
IkReal x443=((0.997495519808809)*gconst8);
IkReal x444=(gconst7*x440);
IkReal x445=(gconst7*x439);
evalcond[0]=(((r02*x439))+x442+(((-0.997495519808809)*gconst7))+((r01*x440)));
evalcond[1]=((((-1.0)*x443))+(((-0.0707296823218818)*gconst7))+((r01*x439))+(((-1.0)*x440*x441)));
evalcond[2]=((((-1.0)*x441))+(((-1.0)*x439*x442))+(((-0.0707296823218818)*x444))+(((0.997495519808809)*x445))+(((-1.0)*x440*x443)));
evalcond[3]=(((x439*x443))+(((0.0707296823218818)*x445))+(((-1.0)*r01))+(((0.997495519808809)*x444))+(((-1.0)*x440*x442)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(3);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j15;
vinfos[0].indices[0] = _ij15[0];
vinfos[0].indices[1] = _ij15[1];
vinfos[0].maxsolutions = _nj15;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j16;
vinfos[1].indices[0] = _ij16[0];
vinfos[1].indices[1] = _ij16[1];
vinfos[1].maxsolutions = _nj16;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j17;
vinfos[2].indices[0] = _ij17[0];
vinfos[2].indices[1] = _ij17[1];
vinfos[2].maxsolutions = _nj17;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x446=((((-14.1029266223667)*r02))+r01);
IkReal x447=(r02+(((14.1029266223667)*r01)));
IkReal x449 = ((x446*x446)+(x447*x447));
if(IKabs(x449)==0){
continue;
}
IkReal x448=pow(x449,-0.5);
CheckValue<IkReal> x450 = IKatan2WithCheck(IkReal(x447),x446,IKFAST_ATAN2_MAGTHRESH);
if(!x450.valid){
continue;
}
IkReal gconst9=((3.14159265358979)+(((-1.0)*(x450.value))));
IkReal gconst10=((1.0)*x447*x448);
IkReal gconst11=((-1.0)*x446*x448);
IkReal x451=j17;
CheckValue<IkReal> x454 = IKatan2WithCheck(IkReal((r02+(((14.1029266223667)*r01)))),((((-14.1029266223667)*r02))+r01),IKFAST_ATAN2_MAGTHRESH);
if(!x454.valid){
continue;
}
IkReal x452=x454.value;
IkReal x453=x452;
if((((9.86960440108936)+((x452*x453))+((j17*x453))+((j17*x451))+(((-3.14159265358979)*x451))+(((-3.14159265358979)*x453))+(((-3.14159265358979)*x452))+((x451*x452))+(((-3.14159265358979)*j17)))) < -0.00001)
continue;
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKsqrt(((9.86960440108936)+((x452*x453))+((j17*x453))+((j17*x451))+(((-3.14159265358979)*x451))+(((-3.14159265358979)*x453))+(((-3.14159265358979)*x452))+((x451*x452))+(((-3.14159265358979)*j17)))))), 6.28318530717959)));
evalcond[1]=((-1.0)*r00);
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x455=gconst11*gconst11;
IkReal x456=gconst10*gconst10;
IkReal x457=(gconst10*gconst11);
CheckValue<IkReal> x458=IKPowWithIntegerCheck(IKsign(((((0.997495519808809)*gconst10*r02))+(((-0.997495519808809)*gconst11*r01))+(((-0.0707296823218818)*gconst11*r02))+(((-0.0707296823218818)*gconst10*r01)))),-1);
if(!x458.valid){
continue;
}
CheckValue<IkReal> x459 = IKatan2WithCheck(IkReal(((((-0.00500268796135431)*x456))+(((-0.141105082467155)*x457))+(((-0.994997312038646)*x455))+(r02*r02))),((((-0.989994624077291)*x457))+(((0.0705525412335773)*x455))+((r01*r02))+(((-0.0705525412335773)*x456))),IKFAST_ATAN2_MAGTHRESH);
if(!x459.valid){
continue;
}
j16array[0]=((-1.5707963267949)+(((1.5707963267949)*(x458.value)))+(x459.value));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[4];
IkReal x460=IKsin(j16);
IkReal x461=IKcos(j16);
IkReal x462=((1.0)*r02);
IkReal x463=((0.997495519808809)*gconst11);
IkReal x464=((0.997495519808809)*gconst10);
IkReal x465=((0.0707296823218818)*gconst11);
IkReal x466=((0.0707296823218818)*gconst10);
evalcond[0]=((((-1.0)*x464))+x465+((r02*x460))+((r01*x461)));
evalcond[1]=((((-1.0)*x466))+(((-1.0)*x463))+(((-1.0)*x461*x462))+((r01*x460)));
evalcond[2]=((((-1.0)*x460*x465))+(((-1.0)*x462))+((x460*x464))+(((-1.0)*x461*x463))+(((-1.0)*x461*x466)));
evalcond[3]=(((x461*x464))+(((-1.0)*r01))+((x460*x463))+((x460*x466))+(((-1.0)*x461*x465)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(3);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j15;
vinfos[0].indices[0] = _ij15[0];
vinfos[0].indices[1] = _ij15[1];
vinfos[0].maxsolutions = _nj15;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j16;
vinfos[1].indices[0] = _ij16[0];
vinfos[1].indices[1] = _ij16[1];
vinfos[1].maxsolutions = _nj16;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j17;
vinfos[2].indices[0] = _ij17[0];
vinfos[2].indices[1] = _ij17[1];
vinfos[2].maxsolutions = _nj17;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x467=((((-1.0)*r01))+(((14.1029266223667)*r02)));
IkReal x468=((((-1.0)*r02))+(((-14.1029266223667)*r01)));
IkReal x470 = ((x468*x468)+(x467*x467));
if(IKabs(x470)==0){
continue;
}
IkReal x469=pow(x470,-0.5);
CheckValue<IkReal> x471 = IKatan2WithCheck(IkReal(x468),x467,IKFAST_ATAN2_MAGTHRESH);
if(!x471.valid){
continue;
}
IkReal gconst12=((-1.0)*(x471.value));
IkReal gconst13=((-1.0)*x468*x469);
IkReal gconst14=(x467*x469);
IkReal x472=j17;
CheckValue<IkReal> x475 = IKatan2WithCheck(IkReal(((((-1.0)*r02))+(((-14.1029266223667)*r01)))),((((-1.0)*r01))+(((14.1029266223667)*r02))),IKFAST_ATAN2_MAGTHRESH);
if(!x475.valid){
continue;
}
IkReal x473=x475.value;
IkReal x474=x473;
if(((((x472*x473))+((x473*x474))+((j17*x474))+((j17*x472)))) < -0.00001)
continue;
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKsqrt((((x472*x473))+((x473*x474))+((j17*x474))+((j17*x472)))))), 6.28318530717959)));
evalcond[1]=((-1.0)*r00);
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x476=gconst13*gconst13;
IkReal x477=gconst14*gconst14;
IkReal x478=(gconst13*gconst14);
CheckValue<IkReal> x479 = IKatan2WithCheck(IkReal(((((0.989994624077291)*x478))+(((0.0705525412335773)*x476))+((r01*r02))+(((-0.0705525412335773)*x477)))),((((-0.141105082467155)*x478))+(((-0.994997312038646)*x477))+(r01*r01)+(((-0.00500268796135431)*x476))),IKFAST_ATAN2_MAGTHRESH);
if(!x479.valid){
continue;
}
CheckValue<IkReal> x480=IKPowWithIntegerCheck(IKsign(((((0.997495519808809)*gconst14*r02))+(((0.997495519808809)*gconst13*r01))+(((-0.0707296823218818)*gconst14*r01))+(((0.0707296823218818)*gconst13*r02)))),-1);
if(!x480.valid){
continue;
}
j16array[0]=((-1.5707963267949)+(x479.value)+(((1.5707963267949)*(x480.value))));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[4];
IkReal x481=IKsin(j16);
IkReal x482=IKcos(j16);
IkReal x483=((1.0)*r02);
IkReal x484=((0.997495519808809)*gconst13);
IkReal x485=((0.0707296823218818)*gconst13);
IkReal x486=((0.997495519808809)*gconst14);
IkReal x487=((0.0707296823218818)*gconst14);
evalcond[0]=((((-1.0)*x484))+((r02*x481))+x487+((r01*x482)));
evalcond[1]=((((-1.0)*x485))+(((-1.0)*x486))+((r01*x481))+(((-1.0)*x482*x483)));
evalcond[2]=((((-1.0)*x483))+(((-1.0)*x481*x487))+((x481*x484))+(((-1.0)*x482*x485))+(((-1.0)*x482*x486)));
evalcond[3]=((((-1.0)*r01))+((x481*x485))+((x481*x486))+((x482*x484))+(((-1.0)*x482*x487)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(3);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j15;
vinfos[0].indices[0] = _ij15[0];
vinfos[0].indices[1] = _ij15[1];
vinfos[0].maxsolutions = _nj15;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j16;
vinfos[1].indices[0] = _ij16[0];
vinfos[1].indices[1] = _ij16[1];
vinfos[1].maxsolutions = _nj16;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j17;
vinfos[2].indices[0] = _ij17[0];
vinfos[2].indices[1] = _ij17[1];
vinfos[2].maxsolutions = _nj17;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x488=((((-1.0)*r01))+(((14.1029266223667)*r02)));
IkReal x489=((((-1.0)*r02))+(((-14.1029266223667)*r01)));
IkReal x491 = ((x488*x488)+(x489*x489));
if(IKabs(x491)==0){
continue;
}
IkReal x490=pow(x491,-0.5);
CheckValue<IkReal> x492 = IKatan2WithCheck(IkReal(x489),x488,IKFAST_ATAN2_MAGTHRESH);
if(!x492.valid){
continue;
}
IkReal gconst15=((3.14159265358979)+(((-1.0)*(x492.value))));
IkReal gconst16=((1.0)*x489*x490);
IkReal gconst17=((-1.0)*x488*x490);
IkReal x493=j17;
CheckValue<IkReal> x496 = IKatan2WithCheck(IkReal(((((-1.0)*r02))+(((-14.1029266223667)*r01)))),((((-1.0)*r01))+(((14.1029266223667)*r02))),IKFAST_ATAN2_MAGTHRESH);
if(!x496.valid){
continue;
}
IkReal x494=x496.value;
IkReal x495=x494;
if((((9.86960440108936)+((x493*x494))+((x494*x495))+(((-3.14159265358979)*x493))+(((-3.14159265358979)*x495))+(((-3.14159265358979)*x494))+((j17*x493))+((j17*x495))+(((-3.14159265358979)*j17)))) < -0.00001)
continue;
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKsqrt(((9.86960440108936)+((x493*x494))+((x494*x495))+(((-3.14159265358979)*x493))+(((-3.14159265358979)*x495))+(((-3.14159265358979)*x494))+((j17*x493))+((j17*x495))+(((-3.14159265358979)*j17)))))), 6.28318530717959)));
evalcond[1]=((-1.0)*r00);
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x497=gconst17*gconst17;
IkReal x498=gconst16*gconst16;
IkReal x499=(gconst16*gconst17);
CheckValue<IkReal> x500 = IKatan2WithCheck(IkReal(((((-0.141105082467155)*x499))+(((-0.00500268796135431)*x498))+(((-0.994997312038646)*x497))+(r02*r02))),((((-0.989994624077291)*x499))+(((-0.0705525412335773)*x498))+((r01*r02))+(((0.0705525412335773)*x497))),IKFAST_ATAN2_MAGTHRESH);
if(!x500.valid){
continue;
}
CheckValue<IkReal> x501=IKPowWithIntegerCheck(IKsign(((((0.997495519808809)*gconst16*r02))+(((-0.997495519808809)*gconst17*r01))+(((-0.0707296823218818)*gconst16*r01))+(((-0.0707296823218818)*gconst17*r02)))),-1);
if(!x501.valid){
continue;
}
j16array[0]=((-1.5707963267949)+(x500.value)+(((1.5707963267949)*(x501.value))));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[4];
IkReal x502=IKsin(j16);
IkReal x503=IKcos(j16);
IkReal x504=((1.0)*r02);
IkReal x505=((0.997495519808809)*gconst16);
IkReal x506=((0.997495519808809)*gconst17);
IkReal x507=((0.0707296823218818)*gconst17);
IkReal x508=((0.0707296823218818)*gconst16);
IkReal x509=((0.0707296823218818)*x502);
evalcond[0]=((((-1.0)*x505))+((r01*x503))+x507+((r02*x502)));
evalcond[1]=((((-1.0)*x508))+(((-1.0)*x506))+(((-1.0)*x503*x504))+((r01*x502)));
evalcond[2]=((((-1.0)*x504))+(((-1.0)*x502*x507))+(((-1.0)*x503*x508))+(((-1.0)*x503*x506))+((x502*x505)));
evalcond[3]=((((-1.0)*r01))+(((-1.0)*x503*x507))+((x503*x505))+((x502*x506))+((x502*x508)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(3);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j15;
vinfos[0].indices[0] = _ij15[0];
vinfos[0].indices[1] = _ij15[1];
vinfos[0].maxsolutions = _nj15;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j16;
vinfos[1].indices[0] = _ij16[0];
vinfos[1].indices[1] = _ij16[1];
vinfos[1].maxsolutions = _nj16;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j17;
vinfos[2].indices[0] = _ij17[0];
vinfos[2].indices[1] = _ij17[1];
vinfos[2].maxsolutions = _nj17;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j16]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x510=cj17*cj17;
IkReal x511=(cj17*sj17);
CheckValue<IkReal> x512 = IKatan2WithCheck(IkReal(((0.0705525412335773)+(((-0.141105082467155)*x510))+(((0.989994624077291)*x511))+((r01*r02)))),((0.994997312038646)+(((-0.989994624077291)*x510))+(((-0.141105082467155)*x511))+(((-1.0)*(r02*r02)))),IKFAST_ATAN2_MAGTHRESH);
if(!x512.valid){
continue;
}
CheckValue<IkReal> x513=IKPowWithIntegerCheck(IKsign(((((0.997495519808809)*cj17*r02))+(((0.0707296823218818)*r02*sj17))+(((-0.0707296823218818)*cj17*r01))+(((0.997495519808809)*r01*sj17)))),-1);
if(!x513.valid){
continue;
}
j16array[0]=((-1.5707963267949)+(x512.value)+(((1.5707963267949)*(x513.value))));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[4];
IkReal x514=IKsin(j16);
IkReal x515=IKcos(j16);
IkReal x516=((1.0)*r02);
IkReal x517=((0.997495519808809)*cj17);
IkReal x518=((0.0707296823218818)*cj17);
IkReal x519=((0.997495519808809)*sj17);
IkReal x520=((0.0707296823218818)*sj17);
evalcond[0]=(((r01*x515))+((r02*x514))+x518+(((-1.0)*x519)));
evalcond[1]=(((r01*x514))+(((-1.0)*x520))+(((-1.0)*x515*x516))+(((-1.0)*x517)));
evalcond[2]=((((-1.0)*x514*x518))+((x514*x519))+(((-1.0)*x515*x520))+(((-1.0)*x515*x517))+(((-1.0)*x516)));
evalcond[3]=((((-1.0)*r01))+((x514*x517))+(((-1.0)*x515*x518))+((x514*x520))+((x515*x519)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(3);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j15;
vinfos[0].indices[0] = _ij15[0];
vinfos[0].indices[1] = _ij15[1];
vinfos[0].maxsolutions = _nj15;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j16;
vinfos[1].indices[0] = _ij16[0];
vinfos[1].indices[1] = _ij16[1];
vinfos[1].maxsolutions = _nj16;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j17;
vinfos[2].indices[0] = _ij17[0];
vinfos[2].indices[1] = _ij17[1];
vinfos[2].maxsolutions = _nj17;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x521=cj17*cj17;
IkReal x522=(cj17*sj17);
CheckValue<IkReal> x523=IKPowWithIntegerCheck(IKsign(((((-0.997495519808809)*r02*sj17))+(((0.997495519808809)*cj17*r01))+(((0.0707296823218818)*r01*sj17))+(((0.0707296823218818)*cj17*r02)))),-1);
if(!x523.valid){
continue;
}
CheckValue<IkReal> x524 = IKatan2WithCheck(IkReal(((-0.994997312038646)+(((0.141105082467155)*x522))+(((0.989994624077291)*x521))+(r01*r01))),((0.0705525412335773)+(((-0.141105082467155)*x521))+(((0.989994624077291)*x522))+(((-1.0)*r01*r02))),IKFAST_ATAN2_MAGTHRESH);
if(!x524.valid){
continue;
}
j16array[0]=((-1.5707963267949)+(((1.5707963267949)*(x523.value)))+(x524.value));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[4];
IkReal x525=IKsin(j16);
IkReal x526=IKcos(j16);
IkReal x527=((1.0)*r02);
IkReal x528=((0.997495519808809)*cj17);
IkReal x529=((0.0707296823218818)*cj17);
IkReal x530=((0.997495519808809)*sj17);
IkReal x531=((0.0707296823218818)*sj17);
evalcond[0]=(((r02*x525))+(((-1.0)*x530))+x529+((r01*x526)));
evalcond[1]=((((-1.0)*x526*x527))+(((-1.0)*x531))+(((-1.0)*x528))+((r01*x525)));
evalcond[2]=((((-1.0)*x526*x531))+(((-1.0)*x525*x529))+(((-1.0)*x526*x528))+(((-1.0)*x527))+((x525*x530)));
evalcond[3]=((((-1.0)*x526*x529))+((x526*x530))+(((-1.0)*r01))+((x525*x528))+((x525*x531)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(3);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j15;
vinfos[0].indices[0] = _ij15[0];
vinfos[0].indices[1] = _ij15[1];
vinfos[0].maxsolutions = _nj15;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j16;
vinfos[1].indices[0] = _ij16[0];
vinfos[1].indices[1] = _ij16[1];
vinfos[1].maxsolutions = _nj16;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j17;
vinfos[2].indices[0] = _ij17[0];
vinfos[2].indices[1] = _ij17[1];
vinfos[2].maxsolutions = _nj17;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x532=cj17*cj17;
IkReal x533=(cj17*sj17);
CheckValue<IkReal> x534=IKPowWithIntegerCheck(IKsign(((((0.997495519808809)*r02*sj17))+(((-0.997495519808809)*cj17*r01))+(((-0.0707296823218818)*r01*sj17))+(((-0.0707296823218818)*cj17*r02)))),-1);
if(!x534.valid){
continue;
}
CheckValue<IkReal> x535 = IKatan2WithCheck(IkReal(((-0.00500268796135431)+(((-0.989994624077291)*x532))+(((-0.141105082467155)*x533))+(r02*r02))),((-0.0705525412335773)+(((-0.989994624077291)*x533))+(((0.141105082467155)*x532))+((r01*r02))),IKFAST_ATAN2_MAGTHRESH);
if(!x535.valid){
continue;
}
j16array[0]=((-1.5707963267949)+(((1.5707963267949)*(x534.value)))+(x535.value));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[4];
IkReal x536=IKsin(j16);
IkReal x537=IKcos(j16);
IkReal x538=((1.0)*r02);
IkReal x539=((0.997495519808809)*cj17);
IkReal x540=((0.0707296823218818)*cj17);
IkReal x541=((0.997495519808809)*sj17);
IkReal x542=((0.0707296823218818)*sj17);
evalcond[0]=(((r02*x536))+(((-1.0)*x541))+x540+((r01*x537)));
evalcond[1]=((((-1.0)*x537*x538))+(((-1.0)*x539))+(((-1.0)*x542))+((r01*x536)));
evalcond[2]=((((-1.0)*x537*x542))+(((-1.0)*x537*x539))+(((-1.0)*x538))+((x536*x541))+(((-1.0)*x536*x540)));
evalcond[3]=((((-1.0)*x537*x540))+(((-1.0)*r01))+((x536*x542))+((x536*x539))+((x537*x541)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(3);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j15;
vinfos[0].indices[0] = _ij15[0];
vinfos[0].indices[1] = _ij15[1];
vinfos[0].maxsolutions = _nj15;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j16;
vinfos[1].indices[0] = _ij16[0];
vinfos[1].indices[1] = _ij16[1];
vinfos[1].maxsolutions = _nj16;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j17;
vinfos[2].indices[0] = _ij17[0];
vinfos[2].indices[1] = _ij17[1];
vinfos[2].maxsolutions = _nj17;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j15)))), 6.28318530717959)));
evalcond[1]=r00;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j16eval[3];
sj15=0;
cj15=-1.0;
j15=3.14159265358979;
IkReal x543=cj17*cj17;
IkReal x544=(r02*sj17);
IkReal x545=(cj17*sj17);
IkReal x546=(r01*sj17);
IkReal x547=(cj17*r01);
IkReal x548=(cj17*r02);
j16eval[0]=((((-1.0)*x546))+(((-14.1029266223667)*x547))+(((-14.1029266223667)*x544))+x548);
j16eval[1]=((IKabs(((0.0705525412335773)+(((-0.141105082467155)*x543))+(((0.989994624077291)*x545))+((r01*r02)))))+(IKabs(((-0.994997312038646)+(((0.141105082467155)*x545))+(((0.989994624077291)*x543))+(r01*r01)))));
j16eval[2]=IKsign(((((0.0707296823218818)*x548))+(((-0.997495519808809)*x547))+(((-0.997495519808809)*x544))+(((-0.0707296823218818)*x546))));
if( IKabs(j16eval[0]) < 0.0000010000000000  || IKabs(j16eval[1]) < 0.0000010000000000  || IKabs(j16eval[2]) < 0.0000010000000000  )
{
{
IkReal j16eval[3];
sj15=0;
cj15=-1.0;
j15=3.14159265358979;
IkReal x549=cj17*cj17;
IkReal x550=(r02*sj17);
IkReal x551=(cj17*r01);
IkReal x552=(r01*sj17);
IkReal x553=(cj17*r02);
IkReal x554=(cj17*sj17);
j16eval[0]=((((-1.0)*x551))+(((-1.0)*x550))+(((14.1029266223667)*x552))+(((-14.1029266223667)*x553)));
j16eval[1]=((IKabs(((-0.994997312038646)+(((0.141105082467155)*x554))+(((0.989994624077291)*x549))+(r02*r02))))+(IKabs(((-0.0705525412335773)+(((0.141105082467155)*x549))+(((-0.989994624077291)*x554))+((r01*r02))))));
j16eval[2]=IKsign(((((0.997495519808809)*x552))+(((-0.997495519808809)*x553))+(((-0.0707296823218818)*x550))+(((-0.0707296823218818)*x551))));
if( IKabs(j16eval[0]) < 0.0000010000000000  || IKabs(j16eval[1]) < 0.0000010000000000  || IKabs(j16eval[2]) < 0.0000010000000000  )
{
{
IkReal j16eval[3];
sj15=0;
cj15=-1.0;
j15=3.14159265358979;
IkReal x555=cj17*cj17;
IkReal x556=(cj17*sj17);
IkReal x557=(r02*sj17);
IkReal x558=(cj17*r01);
IkReal x559=(r01*sj17);
IkReal x560=(cj17*r02);
j16eval[0]=((((-1.0)*x557))+(((-1.0)*x558))+(((14.1029266223667)*x559))+(((-14.1029266223667)*x560)));
j16eval[1]=((IKabs(((-0.0705525412335773)+(((0.141105082467155)*x555))+(((-0.989994624077291)*x556))+((r01*r02)))))+(IKabs(((0.00500268796135431)+(((0.141105082467155)*x556))+(((0.989994624077291)*x555))+(((-1.0)*(r01*r01)))))));
j16eval[2]=IKsign(((((-0.997495519808809)*x560))+(((0.997495519808809)*x559))+(((-0.0707296823218818)*x558))+(((-0.0707296823218818)*x557))));
if( IKabs(j16eval[0]) < 0.0000010000000000  || IKabs(j16eval[1]) < 0.0000010000000000  || IKabs(j16eval[2]) < 0.0000010000000000  )
{
{
IkReal evalcond[2];
bool bgotonextstatement = true;
do
{
IkReal x561=((((-1.0)*r02))+(((14.1029266223667)*r01)));
IkReal x562=((((-1.0)*r01))+(((-14.1029266223667)*r02)));
IkReal x564 = ((x562*x562)+(x561*x561));
if(IKabs(x564)==0){
continue;
}
IkReal x563=pow(x564,-0.5);
CheckValue<IkReal> x565 = IKatan2WithCheck(IkReal(x562),x561,IKFAST_ATAN2_MAGTHRESH);
if(!x565.valid){
continue;
}
IkReal gconst18=((-1.0)*(x565.value));
IkReal gconst19=((-1.0)*x562*x563);
IkReal gconst20=(x561*x563);
IkReal x566=j17;
CheckValue<IkReal> x569 = IKatan2WithCheck(IkReal(((((-1.0)*r01))+(((-14.1029266223667)*r02)))),((((-1.0)*r02))+(((14.1029266223667)*r01))),IKFAST_ATAN2_MAGTHRESH);
if(!x569.valid){
continue;
}
IkReal x567=x569.value;
IkReal x568=x567;
if(((((x566*x567))+((j17*x566))+((j17*x568))+((x567*x568)))) < -0.00001)
continue;
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKsqrt((((x566*x567))+((j17*x566))+((j17*x568))+((x567*x568)))))), 6.28318530717959)));
evalcond[1]=r00;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j16eval[2];
IkReal x570=((1.0)*r01);
IkReal x571=((1.0)*r02);
IkReal x572=((((-1.0)*x571))+(((14.1029266223667)*r01)));
IkReal x573=x562;
IkReal x575 = ((x573*x573)+(x572*x572));
if(IKabs(x575)==0){
continue;
}
IkReal x574=pow(x575,-0.5);
sj15=0;
cj15=-1.0;
j15=3.14159265358979;
sj17=gconst19;
cj17=gconst20;
CheckValue<IkReal> x576 = IKatan2WithCheck(IkReal(((((-1.0)*x570))+(((-14.1029262584782)*r02)))),((((14.1029262584782)*r01))+(((-1.0)*x571))),IKFAST_ATAN2_MAGTHRESH);
if(!x576.valid){
continue;
}
j17=((-1.0)*(x576.value));
CheckValue<IkReal> x577 = IKatan2WithCheck(IkReal(x573),x572,IKFAST_ATAN2_MAGTHRESH);
if(!x577.valid){
continue;
}
IkReal gconst18=((-1.0)*(x577.value));
IkReal gconst19=((-1.0)*x573*x574);
IkReal gconst20=(x572*x574);
IkReal x578=((r01*r01)+(r02*r02));
j16eval[0]=x578;
j16eval[1]=IKsign(x578);
if( IKabs(j16eval[0]) < 0.0000010000000000  || IKabs(j16eval[1]) < 0.0000010000000000  )
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x579=gconst19*gconst19;
IkReal x580=gconst20*gconst20;
IkReal x581=(gconst19*gconst20);
CheckValue<IkReal> x582=IKPowWithIntegerCheck(IKsign(((((-0.0707296823218818)*gconst19*r01))+(((-0.997495519808809)*gconst19*r02))+(((-0.997495519808809)*gconst20*r01))+(((0.0707296823218818)*gconst20*r02)))),-1);
if(!x582.valid){
continue;
}
CheckValue<IkReal> x583 = IKatan2WithCheck(IkReal(((((-0.00500268796135431)*x580))+(r01*r01)+(((0.141105082467155)*x581))+(((-0.994997312038646)*x579)))),((((0.0705525412335773)*x579))+(((0.989994624077291)*x581))+((r01*r02))+(((-0.0705525412335773)*x580))),IKFAST_ATAN2_MAGTHRESH);
if(!x583.valid){
continue;
}
j16array[0]=((-1.5707963267949)+(((1.5707963267949)*(x582.value)))+(x583.value));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[4];
IkReal x584=IKsin(j16);
IkReal x585=IKcos(j16);
IkReal x586=((0.0707296823218818)*gconst19);
IkReal x587=((1.0)*r02);
IkReal x588=((0.997495519808809)*gconst19);
IkReal x589=((0.0707296823218818)*gconst20);
IkReal x590=((0.997495519808809)*gconst20);
IkReal x591=((1.0)*r01);
IkReal x592=((0.997495519808809)*x584);
evalcond[0]=(((r02*x584))+(((-1.0)*x585*x591))+x589+(((-1.0)*x588)));
evalcond[1]=((((-1.0)*x590))+(((-1.0)*x585*x587))+(((-1.0)*x584*x591))+(((-1.0)*x586)));
evalcond[2]=(((x584*x586))+((x585*x588))+(((-1.0)*x585*x589))+((x584*x590))+r01);
evalcond[3]=(((x584*x588))+(((-1.0)*x584*x589))+(((-1.0)*x585*x590))+(((-1.0)*x585*x586))+(((-1.0)*x587)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(3);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j15;
vinfos[0].indices[0] = _ij15[0];
vinfos[0].indices[1] = _ij15[1];
vinfos[0].maxsolutions = _nj15;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j16;
vinfos[1].indices[0] = _ij16[0];
vinfos[1].indices[1] = _ij16[1];
vinfos[1].maxsolutions = _nj16;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j17;
vinfos[2].indices[0] = _ij17[0];
vinfos[2].indices[1] = _ij17[1];
vinfos[2].maxsolutions = _nj17;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x593=(gconst20*r02);
IkReal x594=((0.0707296823218818)*r01);
IkReal x595=(gconst19*r02);
IkReal x596=((0.997495519808809)*r01);
CheckValue<IkReal> x597 = IKatan2WithCheck(IkReal(((((-1.0)*gconst20*x596))+(((-0.0707296823218818)*x593))+(((-1.0)*gconst19*x594))+(((0.997495519808809)*x595)))),((((-0.0707296823218818)*x595))+((gconst20*x594))+(((-1.0)*gconst19*x596))+(((-0.997495519808809)*x593))),IKFAST_ATAN2_MAGTHRESH);
if(!x597.valid){
continue;
}
CheckValue<IkReal> x598=IKPowWithIntegerCheck(IKsign(((r01*r01)+(r02*r02))),-1);
if(!x598.valid){
continue;
}
j16array[0]=((-1.5707963267949)+(x597.value)+(((1.5707963267949)*(x598.value))));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[4];
IkReal x599=IKsin(j16);
IkReal x600=IKcos(j16);
IkReal x601=((0.0707296823218818)*gconst19);
IkReal x602=((1.0)*r02);
IkReal x603=((0.997495519808809)*gconst19);
IkReal x604=((0.0707296823218818)*gconst20);
IkReal x605=((0.997495519808809)*gconst20);
IkReal x606=((1.0)*r01);
IkReal x607=((0.997495519808809)*x599);
evalcond[0]=(((r02*x599))+(((-1.0)*x600*x606))+x604+(((-1.0)*x603)));
evalcond[1]=((((-1.0)*x599*x606))+(((-1.0)*x600*x602))+(((-1.0)*x601))+(((-1.0)*x605)));
evalcond[2]=(((x600*x603))+(((-1.0)*x600*x604))+r01+((x599*x605))+((x599*x601)));
evalcond[3]=((((-1.0)*x599*x604))+(((-1.0)*x600*x601))+(((-1.0)*x600*x605))+(((-1.0)*x602))+((x599*x603)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(3);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j15;
vinfos[0].indices[0] = _ij15[0];
vinfos[0].indices[1] = _ij15[1];
vinfos[0].maxsolutions = _nj15;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j16;
vinfos[1].indices[0] = _ij16[0];
vinfos[1].indices[1] = _ij16[1];
vinfos[1].maxsolutions = _nj16;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j17;
vinfos[2].indices[0] = _ij17[0];
vinfos[2].indices[1] = _ij17[1];
vinfos[2].maxsolutions = _nj17;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x608=((((-1.0)*r02))+(((14.1029266223667)*r01)));
IkReal x609=((((-1.0)*r01))+(((-14.1029266223667)*r02)));
IkReal x611 = ((x608*x608)+(x609*x609));
if(IKabs(x611)==0){
continue;
}
IkReal x610=pow(x611,-0.5);
CheckValue<IkReal> x612 = IKatan2WithCheck(IkReal(x609),x608,IKFAST_ATAN2_MAGTHRESH);
if(!x612.valid){
continue;
}
IkReal gconst21=((3.14159265358979)+(((-1.0)*(x612.value))));
IkReal gconst22=((1.0)*x609*x610);
IkReal gconst23=((-1.0)*x608*x610);
IkReal x613=j17;
CheckValue<IkReal> x616 = IKatan2WithCheck(IkReal(((((-1.0)*r01))+(((-14.1029266223667)*r02)))),((((-1.0)*r02))+(((14.1029266223667)*r01))),IKFAST_ATAN2_MAGTHRESH);
if(!x616.valid){
continue;
}
IkReal x614=x616.value;
IkReal x615=x614;
if((((9.86960440108936)+((j17*x615))+((j17*x613))+((x613*x614))+((x614*x615))+(((-3.14159265358979)*j17))+(((-3.14159265358979)*x613))+(((-3.14159265358979)*x615))+(((-3.14159265358979)*x614)))) < -0.00001)
continue;
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKsqrt(((9.86960440108936)+((j17*x615))+((j17*x613))+((x613*x614))+((x614*x615))+(((-3.14159265358979)*j17))+(((-3.14159265358979)*x613))+(((-3.14159265358979)*x615))+(((-3.14159265358979)*x614)))))), 6.28318530717959)));
evalcond[1]=r00;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j16eval[2];
IkReal x617=((1.0)*r01);
IkReal x618=((1.0)*r02);
IkReal x619=((((-1.0)*x618))+(((14.1029266223667)*r01)));
IkReal x620=x609;
IkReal x622 = ((x619*x619)+(x620*x620));
if(IKabs(x622)==0){
continue;
}
IkReal x621=pow(x622,-0.5);
sj15=0;
cj15=-1.0;
j15=3.14159265358979;
sj17=gconst22;
cj17=gconst23;
CheckValue<IkReal> x623 = IKatan2WithCheck(IkReal(((((-1.0)*x617))+(((-14.1029262584782)*r02)))),((((14.1029262584782)*r01))+(((-1.0)*x618))),IKFAST_ATAN2_MAGTHRESH);
if(!x623.valid){
continue;
}
j17=((3.14159265)+(((-1.0)*(x623.value))));
CheckValue<IkReal> x624 = IKatan2WithCheck(IkReal(x620),x619,IKFAST_ATAN2_MAGTHRESH);
if(!x624.valid){
continue;
}
IkReal gconst21=((3.14159265358979)+(((-1.0)*(x624.value))));
IkReal gconst22=((1.0)*x620*x621);
IkReal gconst23=((-1.0)*x619*x621);
IkReal x625=((r01*r01)+(r02*r02));
j16eval[0]=x625;
j16eval[1]=IKsign(x625);
if( IKabs(j16eval[0]) < 0.0000010000000000  || IKabs(j16eval[1]) < 0.0000010000000000  )
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x626=gconst22*gconst22;
IkReal x627=gconst23*gconst23;
IkReal x628=(gconst22*gconst23);
CheckValue<IkReal> x629 = IKatan2WithCheck(IkReal(((((0.141105082467155)*x628))+(((-0.994997312038646)*x626))+(r01*r01)+(((-0.00500268796135431)*x627)))),((((0.989994624077291)*x628))+(((-0.0705525412335773)*x627))+((r01*r02))+(((0.0705525412335773)*x626))),IKFAST_ATAN2_MAGTHRESH);
if(!x629.valid){
continue;
}
CheckValue<IkReal> x630=IKPowWithIntegerCheck(IKsign(((((-0.997495519808809)*gconst22*r02))+(((-0.0707296823218818)*gconst22*r01))+(((0.0707296823218818)*gconst23*r02))+(((-0.997495519808809)*gconst23*r01)))),-1);
if(!x630.valid){
continue;
}
j16array[0]=((-1.5707963267949)+(x629.value)+(((1.5707963267949)*(x630.value))));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[4];
IkReal x631=IKsin(j16);
IkReal x632=IKcos(j16);
IkReal x633=((1.0)*r02);
IkReal x634=((0.997495519808809)*gconst23);
IkReal x635=((0.0707296823218818)*gconst22);
IkReal x636=((0.0707296823218818)*gconst23);
IkReal x637=((1.0)*r01);
IkReal x638=((0.997495519808809)*gconst22);
IkReal x639=(gconst23*x631);
evalcond[0]=(((r02*x631))+(((-1.0)*x638))+x636+(((-1.0)*x632*x637)));
evalcond[1]=((((-1.0)*x631*x637))+(((-1.0)*x635))+(((-1.0)*x634))+(((-1.0)*x632*x633)));
evalcond[2]=(r01+((x632*x638))+((x631*x635))+((x631*x634))+(((-1.0)*x632*x636)));
evalcond[3]=((((-1.0)*x631*x636))+(((-1.0)*x633))+((x631*x638))+(((-1.0)*x632*x634))+(((-1.0)*x632*x635)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(3);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j15;
vinfos[0].indices[0] = _ij15[0];
vinfos[0].indices[1] = _ij15[1];
vinfos[0].maxsolutions = _nj15;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j16;
vinfos[1].indices[0] = _ij16[0];
vinfos[1].indices[1] = _ij16[1];
vinfos[1].maxsolutions = _nj16;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j17;
vinfos[2].indices[0] = _ij17[0];
vinfos[2].indices[1] = _ij17[1];
vinfos[2].maxsolutions = _nj17;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x640=(gconst23*r02);
IkReal x641=((0.997495519808809)*r01);
IkReal x642=(gconst22*r02);
IkReal x643=((0.0707296823218818)*r01);
CheckValue<IkReal> x644 = IKatan2WithCheck(IkReal(((((-1.0)*gconst22*x643))+(((0.997495519808809)*x642))+(((-0.0707296823218818)*x640))+(((-1.0)*gconst23*x641)))),(((gconst23*x643))+(((-1.0)*gconst22*x641))+(((-0.0707296823218818)*x642))+(((-0.997495519808809)*x640))),IKFAST_ATAN2_MAGTHRESH);
if(!x644.valid){
continue;
}
CheckValue<IkReal> x645=IKPowWithIntegerCheck(IKsign(((r01*r01)+(r02*r02))),-1);
if(!x645.valid){
continue;
}
j16array[0]=((-1.5707963267949)+(x644.value)+(((1.5707963267949)*(x645.value))));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[4];
IkReal x646=IKsin(j16);
IkReal x647=IKcos(j16);
IkReal x648=((1.0)*r02);
IkReal x649=((0.997495519808809)*gconst23);
IkReal x650=((0.0707296823218818)*gconst22);
IkReal x651=((0.0707296823218818)*gconst23);
IkReal x652=((1.0)*r01);
IkReal x653=((0.997495519808809)*gconst22);
IkReal x654=(gconst23*x646);
evalcond[0]=((((-1.0)*x647*x652))+((r02*x646))+(((-1.0)*x653))+x651);
evalcond[1]=((((-1.0)*x647*x648))+(((-1.0)*x646*x652))+(((-1.0)*x650))+(((-1.0)*x649)));
evalcond[2]=(((x647*x653))+((x646*x650))+(((-1.0)*x647*x651))+r01+((x646*x649)));
evalcond[3]=(((x646*x653))+(((-1.0)*x647*x649))+(((-1.0)*x646*x651))+(((-1.0)*x647*x650))+(((-1.0)*x648)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(3);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j15;
vinfos[0].indices[0] = _ij15[0];
vinfos[0].indices[1] = _ij15[1];
vinfos[0].maxsolutions = _nj15;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j16;
vinfos[1].indices[0] = _ij16[0];
vinfos[1].indices[1] = _ij16[1];
vinfos[1].maxsolutions = _nj16;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j17;
vinfos[2].indices[0] = _ij17[0];
vinfos[2].indices[1] = _ij17[1];
vinfos[2].maxsolutions = _nj17;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x655=((((-14.1029266223667)*r01))+r02);
IkReal x656=((((-1.0)*r01))+(((-14.1029266223667)*r02)));
IkReal x658 = ((x656*x656)+(x655*x655));
if(IKabs(x658)==0){
continue;
}
IkReal x657=pow(x658,-0.5);
CheckValue<IkReal> x659 = IKatan2WithCheck(IkReal(x655),x656,IKFAST_ATAN2_MAGTHRESH);
if(!x659.valid){
continue;
}
IkReal gconst30=((-1.0)*(x659.value));
IkReal gconst31=((-1.0)*x655*x657);
IkReal gconst32=(x656*x657);
IkReal x660=j17;
CheckValue<IkReal> x663 = IKatan2WithCheck(IkReal(((((-14.1029266223667)*r01))+r02)),((((-1.0)*r01))+(((-14.1029266223667)*r02))),IKFAST_ATAN2_MAGTHRESH);
if(!x663.valid){
continue;
}
IkReal x661=x663.value;
IkReal x662=x661;
if(((((j17*x660))+((j17*x662))+((x660*x661))+((x661*x662)))) < -0.00001)
continue;
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKsqrt((((j17*x660))+((j17*x662))+((x660*x661))+((x661*x662)))))), 6.28318530717959)));
evalcond[1]=r00;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j16eval[2];
IkReal x664=((1.0)*r01);
IkReal x665=((((-14.1029266223667)*r01))+r02);
IkReal x666=x656;
IkReal x668 = ((x665*x665)+(x666*x666));
if(IKabs(x668)==0){
continue;
}
IkReal x667=pow(x668,-0.5);
sj15=0;
cj15=-1.0;
j15=3.14159265358979;
sj17=gconst31;
cj17=gconst32;
CheckValue<IkReal> x669 = IKatan2WithCheck(IkReal((r02+(((-14.1029262584782)*r01)))),((((-1.0)*x664))+(((-14.1029262584782)*r02))),IKFAST_ATAN2_MAGTHRESH);
if(!x669.valid){
continue;
}
j17=((-1.0)*(x669.value));
CheckValue<IkReal> x670 = IKatan2WithCheck(IkReal(x665),x666,IKFAST_ATAN2_MAGTHRESH);
if(!x670.valid){
continue;
}
IkReal gconst30=((-1.0)*(x670.value));
IkReal gconst31=((-1.0)*x665*x667);
IkReal gconst32=(x666*x667);
IkReal x671=((r01*r01)+(r02*r02));
j16eval[0]=x671;
j16eval[1]=IKsign(x671);
if( IKabs(j16eval[0]) < 0.0000010000000000  || IKabs(j16eval[1]) < 0.0000010000000000  )
{
{
IkReal j16eval[1];
IkReal x672=((1.0)*r01);
IkReal x673=((((-14.1029266223667)*r01))+r02);
IkReal x674=x656;
IkReal x676 = ((x673*x673)+(x674*x674));
if(IKabs(x676)==0){
continue;
}
IkReal x675=pow(x676,-0.5);
sj15=0;
cj15=-1.0;
j15=3.14159265358979;
sj17=gconst31;
cj17=gconst32;
CheckValue<IkReal> x677 = IKatan2WithCheck(IkReal((r02+(((-14.1029262584782)*r01)))),((((-14.1029262584782)*r02))+(((-1.0)*x672))),IKFAST_ATAN2_MAGTHRESH);
if(!x677.valid){
continue;
}
j17=((-1.0)*(x677.value));
CheckValue<IkReal> x678 = IKatan2WithCheck(IkReal(x673),x674,IKFAST_ATAN2_MAGTHRESH);
if(!x678.valid){
continue;
}
IkReal gconst30=((-1.0)*(x678.value));
IkReal gconst31=((-1.0)*x673*x675);
IkReal gconst32=(x674*x675);
IkReal x679=r01*r01;
IkReal x680=r02*r02;
CheckValue<IkReal> x684=IKPowWithIntegerCheck((x679+x680),-1);
if(!x684.valid){
continue;
}
IkReal x681=x684.value;
IkReal x682=(r02*x681);
IkReal x683=(x679*x681);
j16eval[0]=((IKabs((((r01*x682))+((r01*x682*(r02*r02)))+((x682*(r01*r01*r01))))))+(IKabs((((x681*(x680*x680)))+((x680*x683))+(((-1.0)*x683))))));
if( IKabs(j16eval[0]) < 0.0000010000000000  )
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x685=((0.997495519808809)*gconst31);
IkReal x686=((0.0707296823218818)*gconst31);
IkReal x687=(gconst32*r02);
IkReal x688=(gconst32*r01);
CheckValue<IkReal> x689 = IKatan2WithCheck(IkReal(((((-0.0707296823218818)*x687))+(((-0.997495519808809)*x688))+(((-1.0)*r01*x686))+((r02*x685)))),((((0.0707296823218818)*x688))+(((-0.997495519808809)*x687))+(((-1.0)*r02*x686))+(((-1.0)*r01*x685))),IKFAST_ATAN2_MAGTHRESH);
if(!x689.valid){
continue;
}
CheckValue<IkReal> x690=IKPowWithIntegerCheck(IKsign(((gconst32*gconst32)+(gconst31*gconst31))),-1);
if(!x690.valid){
continue;
}
j16array[0]=((-1.5707963267949)+(x689.value)+(((1.5707963267949)*(x690.value))));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[4];
IkReal x691=IKsin(j16);
IkReal x692=IKcos(j16);
IkReal x693=((1.0)*r02);
IkReal x694=((0.0707296823218818)*gconst31);
IkReal x695=((1.0)*r01);
IkReal x696=((0.0707296823218818)*gconst32);
IkReal x697=((0.997495519808809)*gconst31);
IkReal x698=((0.997495519808809)*gconst32);
IkReal x699=(gconst32*x691);
evalcond[0]=(((r02*x691))+(((-1.0)*x692*x695))+x696+(((-1.0)*x697)));
evalcond[1]=((((-1.0)*x692*x693))+(((-1.0)*x694))+(((-1.0)*x698))+(((-1.0)*x691*x695)));
evalcond[2]=(((x691*x694))+((x691*x698))+((x692*x697))+(((-1.0)*x692*x696))+r01);
evalcond[3]=(((x691*x697))+(((-1.0)*x692*x698))+(((-1.0)*x692*x694))+(((-1.0)*x693))+(((-1.0)*x691*x696)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(3);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j15;
vinfos[0].indices[0] = _ij15[0];
vinfos[0].indices[1] = _ij15[1];
vinfos[0].maxsolutions = _nj15;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j16;
vinfos[1].indices[0] = _ij16[0];
vinfos[1].indices[1] = _ij16[1];
vinfos[1].maxsolutions = _nj16;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j17;
vinfos[2].indices[0] = _ij17[0];
vinfos[2].indices[1] = _ij17[1];
vinfos[2].maxsolutions = _nj17;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x700=gconst32*gconst32;
IkReal x701=gconst31*gconst31;
IkReal x702=(gconst31*gconst32);
CheckValue<IkReal> x703 = IKatan2WithCheck(IkReal(((((0.0705525412335773)*x700))+(((-0.0705525412335773)*x701))+((r01*r02))+(((-0.989994624077291)*x702)))),((((0.141105082467155)*x702))+(((-0.00500268796135431)*x700))+(r02*r02)+(((-0.994997312038646)*x701))),IKFAST_ATAN2_MAGTHRESH);
if(!x703.valid){
continue;
}
CheckValue<IkReal> x704=IKPowWithIntegerCheck(IKsign(((((-0.0707296823218818)*gconst32*r01))+(((-0.0707296823218818)*gconst31*r02))+(((-0.997495519808809)*gconst32*r02))+(((0.997495519808809)*gconst31*r01)))),-1);
if(!x704.valid){
continue;
}
j16array[0]=((-1.5707963267949)+(x703.value)+(((1.5707963267949)*(x704.value))));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[4];
IkReal x705=IKsin(j16);
IkReal x706=IKcos(j16);
IkReal x707=((1.0)*r02);
IkReal x708=((0.0707296823218818)*gconst31);
IkReal x709=((1.0)*r01);
IkReal x710=((0.0707296823218818)*gconst32);
IkReal x711=((0.997495519808809)*gconst31);
IkReal x712=((0.997495519808809)*gconst32);
IkReal x713=(gconst32*x705);
evalcond[0]=((((-1.0)*x706*x709))+(((-1.0)*x711))+x710+((r02*x705)));
evalcond[1]=((((-1.0)*x706*x707))+(((-1.0)*x712))+(((-1.0)*x708))+(((-1.0)*x705*x709)));
evalcond[2]=((((-1.0)*x706*x710))+((x706*x711))+r01+((x705*x708))+((x705*x712)));
evalcond[3]=((((-1.0)*x706*x708))+(((-1.0)*x706*x712))+(((-1.0)*x707))+(((-1.0)*x705*x710))+((x705*x711)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(3);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j15;
vinfos[0].indices[0] = _ij15[0];
vinfos[0].indices[1] = _ij15[1];
vinfos[0].maxsolutions = _nj15;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j16;
vinfos[1].indices[0] = _ij16[0];
vinfos[1].indices[1] = _ij16[1];
vinfos[1].maxsolutions = _nj16;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j17;
vinfos[2].indices[0] = _ij17[0];
vinfos[2].indices[1] = _ij17[1];
vinfos[2].maxsolutions = _nj17;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x714=((0.997495519808809)*gconst31);
IkReal x715=((0.0707296823218818)*gconst31);
IkReal x716=(gconst32*r02);
IkReal x717=(gconst32*r01);
CheckValue<IkReal> x718 = IKatan2WithCheck(IkReal(((((-0.0707296823218818)*x716))+(((-1.0)*r01*x715))+(((-0.997495519808809)*x717))+((r02*x714)))),((((-1.0)*r02*x715))+(((-1.0)*r01*x714))+(((-0.997495519808809)*x716))+(((0.0707296823218818)*x717))),IKFAST_ATAN2_MAGTHRESH);
if(!x718.valid){
continue;
}
CheckValue<IkReal> x719=IKPowWithIntegerCheck(IKsign(((r01*r01)+(r02*r02))),-1);
if(!x719.valid){
continue;
}
j16array[0]=((-1.5707963267949)+(x718.value)+(((1.5707963267949)*(x719.value))));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[4];
IkReal x720=IKsin(j16);
IkReal x721=IKcos(j16);
IkReal x722=((1.0)*r02);
IkReal x723=((0.0707296823218818)*gconst31);
IkReal x724=((1.0)*r01);
IkReal x725=((0.0707296823218818)*gconst32);
IkReal x726=((0.997495519808809)*gconst31);
IkReal x727=((0.997495519808809)*gconst32);
IkReal x728=(gconst32*x720);
evalcond[0]=((((-1.0)*x726))+(((-1.0)*x721*x724))+((r02*x720))+x725);
evalcond[1]=((((-1.0)*x727))+(((-1.0)*x723))+(((-1.0)*x721*x722))+(((-1.0)*x720*x724)));
evalcond[2]=(((x721*x726))+((x720*x723))+((x720*x727))+(((-1.0)*x721*x725))+r01);
evalcond[3]=(((x720*x726))+(((-1.0)*x722))+(((-1.0)*x721*x723))+(((-1.0)*x721*x727))+(((-1.0)*x720*x725)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(3);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j15;
vinfos[0].indices[0] = _ij15[0];
vinfos[0].indices[1] = _ij15[1];
vinfos[0].maxsolutions = _nj15;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j16;
vinfos[1].indices[0] = _ij16[0];
vinfos[1].indices[1] = _ij16[1];
vinfos[1].maxsolutions = _nj16;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j17;
vinfos[2].indices[0] = _ij17[0];
vinfos[2].indices[1] = _ij17[1];
vinfos[2].maxsolutions = _nj17;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x729=((((-14.1029266223667)*r01))+r02);
IkReal x730=((((-1.0)*r01))+(((-14.1029266223667)*r02)));
IkReal x732 = ((x730*x730)+(x729*x729));
if(IKabs(x732)==0){
continue;
}
IkReal x731=pow(x732,-0.5);
CheckValue<IkReal> x733 = IKatan2WithCheck(IkReal(x729),x730,IKFAST_ATAN2_MAGTHRESH);
if(!x733.valid){
continue;
}
IkReal gconst33=((3.14159265358979)+(((-1.0)*(x733.value))));
IkReal gconst34=((1.0)*x729*x731);
IkReal gconst35=((-1.0)*x730*x731);
IkReal x734=j17;
CheckValue<IkReal> x737 = IKatan2WithCheck(IkReal(((((-14.1029266223667)*r01))+r02)),((((-1.0)*r01))+(((-14.1029266223667)*r02))),IKFAST_ATAN2_MAGTHRESH);
if(!x737.valid){
continue;
}
IkReal x735=x737.value;
IkReal x736=x735;
if((((9.86960440108936)+((x735*x736))+((x734*x735))+(((-3.14159265358979)*x735))+(((-3.14159265358979)*x736))+(((-3.14159265358979)*x734))+(((-3.14159265358979)*j17))+((j17*x734))+((j17*x736)))) < -0.00001)
continue;
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKsqrt(((9.86960440108936)+((x735*x736))+((x734*x735))+(((-3.14159265358979)*x735))+(((-3.14159265358979)*x736))+(((-3.14159265358979)*x734))+(((-3.14159265358979)*j17))+((j17*x734))+((j17*x736)))))), 6.28318530717959)));
evalcond[1]=r00;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j16eval[2];
IkReal x738=((1.0)*r01);
IkReal x739=((((-14.1029266223667)*r01))+r02);
IkReal x740=x730;
IkReal x742 = ((x739*x739)+(x740*x740));
if(IKabs(x742)==0){
continue;
}
IkReal x741=pow(x742,-0.5);
sj15=0;
cj15=-1.0;
j15=3.14159265358979;
sj17=gconst34;
cj17=gconst35;
CheckValue<IkReal> x743 = IKatan2WithCheck(IkReal((r02+(((-14.1029262584782)*r01)))),((((-1.0)*x738))+(((-14.1029262584782)*r02))),IKFAST_ATAN2_MAGTHRESH);
if(!x743.valid){
continue;
}
j17=((3.14159265)+(((-1.0)*(x743.value))));
CheckValue<IkReal> x744 = IKatan2WithCheck(IkReal(x739),x740,IKFAST_ATAN2_MAGTHRESH);
if(!x744.valid){
continue;
}
IkReal gconst33=((3.14159265358979)+(((-1.0)*(x744.value))));
IkReal gconst34=((1.0)*x739*x741);
IkReal gconst35=((-1.0)*x740*x741);
IkReal x745=((r01*r01)+(r02*r02));
j16eval[0]=x745;
j16eval[1]=IKsign(x745);
if( IKabs(j16eval[0]) < 0.0000010000000000  || IKabs(j16eval[1]) < 0.0000010000000000  )
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x746=gconst34*gconst34;
IkReal x747=gconst35*gconst35;
IkReal x748=(gconst34*gconst35);
CheckValue<IkReal> x749 = IKatan2WithCheck(IkReal(((((-0.994997312038646)*x746))+(((-0.00500268796135431)*x747))+(r01*r01)+(((0.141105082467155)*x748)))),(((r01*r02))+(((0.0705525412335773)*x746))+(((0.989994624077291)*x748))+(((-0.0705525412335773)*x747))),IKFAST_ATAN2_MAGTHRESH);
if(!x749.valid){
continue;
}
CheckValue<IkReal> x750=IKPowWithIntegerCheck(IKsign(((((-0.997495519808809)*gconst34*r02))+(((-0.997495519808809)*gconst35*r01))+(((0.0707296823218818)*gconst35*r02))+(((-0.0707296823218818)*gconst34*r01)))),-1);
if(!x750.valid){
continue;
}
j16array[0]=((-1.5707963267949)+(x749.value)+(((1.5707963267949)*(x750.value))));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[4];
IkReal x751=IKsin(j16);
IkReal x752=IKcos(j16);
IkReal x753=((1.0)*r02);
IkReal x754=((0.997495519808809)*gconst34);
IkReal x755=((0.0707296823218818)*gconst35);
IkReal x756=((0.0707296823218818)*gconst34);
IkReal x757=((1.0)*r01);
IkReal x758=((0.997495519808809)*gconst35);
IkReal x759=(gconst34*x751);
evalcond[0]=(((r02*x751))+(((-1.0)*x752*x757))+x755+(((-1.0)*x754)));
evalcond[1]=((((-1.0)*x751*x757))+(((-1.0)*x752*x753))+(((-1.0)*x756))+(((-1.0)*x758)));
evalcond[2]=(((x752*x754))+((x751*x758))+((x751*x756))+r01+(((-1.0)*x752*x755)));
evalcond[3]=(((x751*x754))+(((-1.0)*x751*x755))+(((-1.0)*x752*x758))+(((-1.0)*x752*x756))+(((-1.0)*x753)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(3);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j15;
vinfos[0].indices[0] = _ij15[0];
vinfos[0].indices[1] = _ij15[1];
vinfos[0].maxsolutions = _nj15;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j16;
vinfos[1].indices[0] = _ij16[0];
vinfos[1].indices[1] = _ij16[1];
vinfos[1].maxsolutions = _nj16;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j17;
vinfos[2].indices[0] = _ij17[0];
vinfos[2].indices[1] = _ij17[1];
vinfos[2].maxsolutions = _nj17;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x760=(gconst34*r02);
IkReal x761=((0.997495519808809)*r01);
IkReal x762=(gconst35*r02);
IkReal x763=((0.0707296823218818)*r01);
CheckValue<IkReal> x764 = IKatan2WithCheck(IkReal(((((0.997495519808809)*x760))+(((-0.0707296823218818)*x762))+(((-1.0)*gconst34*x763))+(((-1.0)*gconst35*x761)))),((((-0.997495519808809)*x762))+(((-0.0707296823218818)*x760))+((gconst35*x763))+(((-1.0)*gconst34*x761))),IKFAST_ATAN2_MAGTHRESH);
if(!x764.valid){
continue;
}
CheckValue<IkReal> x765=IKPowWithIntegerCheck(IKsign(((r01*r01)+(r02*r02))),-1);
if(!x765.valid){
continue;
}
j16array[0]=((-1.5707963267949)+(x764.value)+(((1.5707963267949)*(x765.value))));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[4];
IkReal x766=IKsin(j16);
IkReal x767=IKcos(j16);
IkReal x768=((1.0)*r02);
IkReal x769=((0.997495519808809)*gconst34);
IkReal x770=((0.0707296823218818)*gconst35);
IkReal x771=((0.0707296823218818)*gconst34);
IkReal x772=((1.0)*r01);
IkReal x773=((0.997495519808809)*gconst35);
IkReal x774=(gconst34*x766);
evalcond[0]=((((-1.0)*x769))+(((-1.0)*x767*x772))+((r02*x766))+x770);
evalcond[1]=((((-1.0)*x767*x768))+(((-1.0)*x766*x772))+(((-1.0)*x771))+(((-1.0)*x773)));
evalcond[2]=((((-1.0)*x767*x770))+((x766*x773))+((x766*x771))+r01+((x767*x769)));
evalcond[3]=((((-1.0)*x768))+(((-1.0)*x767*x771))+(((-1.0)*x767*x773))+(((-1.0)*x766*x770))+((x766*x769)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(3);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j15;
vinfos[0].indices[0] = _ij15[0];
vinfos[0].indices[1] = _ij15[1];
vinfos[0].maxsolutions = _nj15;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j16;
vinfos[1].indices[0] = _ij16[0];
vinfos[1].indices[1] = _ij16[1];
vinfos[1].maxsolutions = _nj16;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j17;
vinfos[2].indices[0] = _ij17[0];
vinfos[2].indices[1] = _ij17[1];
vinfos[2].maxsolutions = _nj17;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j16]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x775=cj17*cj17;
IkReal x776=(cj17*sj17);
CheckValue<IkReal> x777=IKPowWithIntegerCheck(IKsign(((((-0.0707296823218818)*r02*sj17))+(((-0.997495519808809)*cj17*r02))+(((-0.0707296823218818)*cj17*r01))+(((0.997495519808809)*r01*sj17)))),-1);
if(!x777.valid){
continue;
}
CheckValue<IkReal> x778 = IKatan2WithCheck(IkReal(((-0.0705525412335773)+(((-0.989994624077291)*x776))+((r01*r02))+(((0.141105082467155)*x775)))),((0.00500268796135431)+(((-1.0)*(r01*r01)))+(((0.141105082467155)*x776))+(((0.989994624077291)*x775))),IKFAST_ATAN2_MAGTHRESH);
if(!x778.valid){
continue;
}
j16array[0]=((-1.5707963267949)+(((1.5707963267949)*(x777.value)))+(x778.value));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[4];
IkReal x779=IKsin(j16);
IkReal x780=IKcos(j16);
IkReal x781=((1.0)*r02);
IkReal x782=((0.0707296823218818)*cj17);
IkReal x783=((1.0)*r01);
IkReal x784=((0.997495519808809)*sj17);
IkReal x785=((0.997495519808809)*cj17);
IkReal x786=((0.0707296823218818)*sj17);
evalcond[0]=((((-1.0)*x784))+x782+(((-1.0)*x780*x783))+((r02*x779)));
evalcond[1]=((((-1.0)*x786))+(((-1.0)*x785))+(((-1.0)*x780*x781))+(((-1.0)*x779*x783)));
evalcond[2]=(((x779*x786))+((x779*x785))+r01+((x780*x784))+(((-1.0)*x780*x782)));
evalcond[3]=((((-1.0)*x781))+((x779*x784))+(((-1.0)*x780*x786))+(((-1.0)*x780*x785))+(((-1.0)*x779*x782)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(3);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j15;
vinfos[0].indices[0] = _ij15[0];
vinfos[0].indices[1] = _ij15[1];
vinfos[0].maxsolutions = _nj15;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j16;
vinfos[1].indices[0] = _ij16[0];
vinfos[1].indices[1] = _ij16[1];
vinfos[1].maxsolutions = _nj16;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j17;
vinfos[2].indices[0] = _ij17[0];
vinfos[2].indices[1] = _ij17[1];
vinfos[2].maxsolutions = _nj17;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x787=cj17*cj17;
IkReal x788=(cj17*sj17);
CheckValue<IkReal> x789 = IKatan2WithCheck(IkReal(((-0.0705525412335773)+(((0.141105082467155)*x787))+(((-0.989994624077291)*x788))+((r01*r02)))),((-0.994997312038646)+(((0.989994624077291)*x787))+(((0.141105082467155)*x788))+(r02*r02)),IKFAST_ATAN2_MAGTHRESH);
if(!x789.valid){
continue;
}
CheckValue<IkReal> x790=IKPowWithIntegerCheck(IKsign(((((-0.0707296823218818)*r02*sj17))+(((-0.997495519808809)*cj17*r02))+(((-0.0707296823218818)*cj17*r01))+(((0.997495519808809)*r01*sj17)))),-1);
if(!x790.valid){
continue;
}
j16array[0]=((-1.5707963267949)+(x789.value)+(((1.5707963267949)*(x790.value))));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[4];
IkReal x791=IKsin(j16);
IkReal x792=IKcos(j16);
IkReal x793=((1.0)*r02);
IkReal x794=((0.0707296823218818)*cj17);
IkReal x795=((1.0)*r01);
IkReal x796=((0.997495519808809)*sj17);
IkReal x797=((0.997495519808809)*cj17);
IkReal x798=((0.0707296823218818)*sj17);
evalcond[0]=((((-1.0)*x796))+(((-1.0)*x792*x795))+((r02*x791))+x794);
evalcond[1]=((((-1.0)*x797))+(((-1.0)*x798))+(((-1.0)*x792*x793))+(((-1.0)*x791*x795)));
evalcond[2]=((((-1.0)*x792*x794))+((x792*x796))+r01+((x791*x797))+((x791*x798)));
evalcond[3]=((((-1.0)*x793))+(((-1.0)*x792*x797))+(((-1.0)*x792*x798))+(((-1.0)*x791*x794))+((x791*x796)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(3);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j15;
vinfos[0].indices[0] = _ij15[0];
vinfos[0].indices[1] = _ij15[1];
vinfos[0].maxsolutions = _nj15;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j16;
vinfos[1].indices[0] = _ij16[0];
vinfos[1].indices[1] = _ij16[1];
vinfos[1].maxsolutions = _nj16;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j17;
vinfos[2].indices[0] = _ij17[0];
vinfos[2].indices[1] = _ij17[1];
vinfos[2].maxsolutions = _nj17;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x799=cj17*cj17;
IkReal x800=(cj17*sj17);
CheckValue<IkReal> x801=IKPowWithIntegerCheck(IKsign(((((-0.997495519808809)*r02*sj17))+(((0.0707296823218818)*cj17*r02))+(((-0.997495519808809)*cj17*r01))+(((-0.0707296823218818)*r01*sj17)))),-1);
if(!x801.valid){
continue;
}
CheckValue<IkReal> x802 = IKatan2WithCheck(IkReal(((-0.994997312038646)+(((0.989994624077291)*x799))+(r01*r01)+(((0.141105082467155)*x800)))),((0.0705525412335773)+(((0.989994624077291)*x800))+((r01*r02))+(((-0.141105082467155)*x799))),IKFAST_ATAN2_MAGTHRESH);
if(!x802.valid){
continue;
}
j16array[0]=((-1.5707963267949)+(((1.5707963267949)*(x801.value)))+(x802.value));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[4];
IkReal x803=IKsin(j16);
IkReal x804=IKcos(j16);
IkReal x805=((1.0)*r02);
IkReal x806=((0.0707296823218818)*cj17);
IkReal x807=((1.0)*r01);
IkReal x808=((0.997495519808809)*sj17);
IkReal x809=((0.997495519808809)*cj17);
IkReal x810=((0.0707296823218818)*sj17);
evalcond[0]=((((-1.0)*x804*x807))+((r02*x803))+x806+(((-1.0)*x808)));
evalcond[1]=((((-1.0)*x804*x805))+(((-1.0)*x810))+(((-1.0)*x803*x807))+(((-1.0)*x809)));
evalcond[2]=(((x804*x808))+(((-1.0)*x804*x806))+((x803*x809))+r01+((x803*x810)));
evalcond[3]=((((-1.0)*x804*x809))+((x803*x808))+(((-1.0)*x803*x806))+(((-1.0)*x804*x810))+(((-1.0)*x805)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(3);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j15;
vinfos[0].indices[0] = _ij15[0];
vinfos[0].indices[1] = _ij15[1];
vinfos[0].maxsolutions = _nj15;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j16;
vinfos[1].indices[0] = _ij16[0];
vinfos[1].indices[1] = _ij16[1];
vinfos[1].maxsolutions = _nj16;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j17;
vinfos[2].indices[0] = _ij17[0];
vinfos[2].indices[1] = _ij17[1];
vinfos[2].maxsolutions = _nj17;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j16]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x811=cj15*cj15;
IkReal x812=cj17*cj17;
IkReal x813=(cj15*r01);
IkReal x814=((0.0707296823218818)*sj17);
IkReal x815=((0.141105082467155)*sj15);
IkReal x816=(cj17*sj17);
IkReal x817=(r02*sj15);
IkReal x818=((0.989994624077291)*sj15);
IkReal x819=((0.997495519808809)*cj17);
IkReal x820=(r00*x811);
CheckValue<IkReal> x821=IKPowWithIntegerCheck(IKsign(((((-1.0)*sj15*x813*x819))+(((-1.0)*sj15*x813*x814))+(((-1.0)*x814*x820))+(((-0.0707296823218818)*cj17*x817))+(((-1.0)*x819*x820))+((r00*x819))+((r00*x814))+(((0.997495519808809)*sj17*x817)))),-1);
if(!x821.valid){
continue;
}
CheckValue<IkReal> x822 = IKatan2WithCheck(IkReal(((((-1.0)*x812*x818))+((r00*x813))+(((-1.0)*x815*x816))+(((-1.0)*sj15*(r00*r00)))+(((0.994997312038646)*sj15)))),((((-1.0)*r00*r02))+(((-1.0)*x816*x818))+((x812*x815))+(((-0.0705525412335773)*sj15))),IKFAST_ATAN2_MAGTHRESH);
if(!x822.valid){
continue;
}
j16array[0]=((-1.5707963267949)+(((1.5707963267949)*(x821.value)))+(x822.value));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[6];
IkReal x823=IKcos(j16);
IkReal x824=IKsin(j16);
IkReal x825=((0.997495519808809)*sj17);
IkReal x826=((1.0)*r01);
IkReal x827=((0.997495519808809)*cj17);
IkReal x828=((0.0707296823218818)*cj17);
IkReal x829=((1.0)*r00);
IkReal x830=((0.0707296823218818)*sj17);
IkReal x831=((1.0)*r02);
IkReal x832=(sj15*x824);
IkReal x833=(cj15*x823);
IkReal x834=(cj15*x824);
IkReal x835=(sj15*x823);
IkReal x836=(x824*x830);
evalcond[0]=((((-1.0)*x825))+((r01*x833))+x828+((r02*x824))+(((-1.0)*x829*x835)));
evalcond[1]=((((-1.0)*x827))+(((-1.0)*x823*x831))+((r01*x834))+(((-1.0)*x830))+(((-1.0)*x829*x832)));
evalcond[2]=(((x824*x825))+(((-1.0)*x823*x830))+(((-1.0)*x823*x827))+(((-1.0)*x824*x828))+(((-1.0)*x831)));
evalcond[3]=(((x824*x827))+(((-1.0)*x823*x828))+((r00*sj15))+((x823*x825))+(((-1.0)*cj15*x826))+x836);
evalcond[4]=((((-1.0)*x827*x832))+(((-1.0)*x829))+(((-1.0)*x830*x832))+(((-1.0)*x825*x835))+((x828*x835)));
evalcond[5]=((((-1.0)*x828*x833))+(((-1.0)*x826))+((x827*x834))+((x830*x834))+((x825*x833)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(3);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j15;
vinfos[0].indices[0] = _ij15[0];
vinfos[0].indices[1] = _ij15[1];
vinfos[0].maxsolutions = _nj15;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j16;
vinfos[1].indices[0] = _ij16[0];
vinfos[1].indices[1] = _ij16[1];
vinfos[1].maxsolutions = _nj16;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j17;
vinfos[2].indices[0] = _ij17[0];
vinfos[2].indices[1] = _ij17[1];
vinfos[2].maxsolutions = _nj17;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x837=cj17*cj17;
IkReal x838=(cj17*sj17);
IkReal x839=(cj15*r01);
IkReal x840=(r00*sj15);
IkReal x841=((0.0707296823218818)*cj17);
IkReal x842=((0.997495519808809)*sj17);
CheckValue<IkReal> x843 = IKatan2WithCheck(IkReal(((0.0705525412335773)+(((-0.141105082467155)*x837))+((r02*x839))+(((-1.0)*r02*x840))+(((0.989994624077291)*x838)))),((0.994997312038646)+(((-0.989994624077291)*x837))+(((-0.141105082467155)*x838))+(((-1.0)*(r02*r02)))),IKFAST_ATAN2_MAGTHRESH);
if(!x843.valid){
continue;
}
CheckValue<IkReal> x844=IKPowWithIntegerCheck(IKsign(((((0.997495519808809)*cj17*r02))+((x840*x841))+((x839*x842))+(((-1.0)*x840*x842))+(((0.0707296823218818)*r02*sj17))+(((-1.0)*x839*x841)))),-1);
if(!x844.valid){
continue;
}
j16array[0]=((-1.5707963267949)+(x843.value)+(((1.5707963267949)*(x844.value))));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[6];
IkReal x845=IKcos(j16);
IkReal x846=IKsin(j16);
IkReal x847=((0.997495519808809)*sj17);
IkReal x848=((1.0)*r01);
IkReal x849=((0.997495519808809)*cj17);
IkReal x850=((0.0707296823218818)*cj17);
IkReal x851=((1.0)*r00);
IkReal x852=((0.0707296823218818)*sj17);
IkReal x853=((1.0)*r02);
IkReal x854=(sj15*x846);
IkReal x855=(cj15*x845);
IkReal x856=(cj15*x846);
IkReal x857=(sj15*x845);
IkReal x858=(x846*x852);
evalcond[0]=(((r02*x846))+(((-1.0)*x847))+x850+(((-1.0)*x851*x857))+((r01*x855)));
evalcond[1]=((((-1.0)*x852))+(((-1.0)*x845*x853))+(((-1.0)*x849))+(((-1.0)*x851*x854))+((r01*x856)));
evalcond[2]=((((-1.0)*x853))+(((-1.0)*x846*x850))+((x846*x847))+(((-1.0)*x845*x852))+(((-1.0)*x845*x849)));
evalcond[3]=(((x846*x849))+(((-1.0)*x845*x850))+((r00*sj15))+(((-1.0)*cj15*x848))+((x845*x847))+x858);
evalcond[4]=(((x850*x857))+(((-1.0)*x851))+(((-1.0)*x852*x854))+(((-1.0)*x849*x854))+(((-1.0)*x847*x857)));
evalcond[5]=((((-1.0)*x850*x855))+((x847*x855))+(((-1.0)*x848))+((x852*x856))+((x849*x856)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(3);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j15;
vinfos[0].indices[0] = _ij15[0];
vinfos[0].indices[1] = _ij15[1];
vinfos[0].maxsolutions = _nj15;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j16;
vinfos[1].indices[0] = _ij16[0];
vinfos[1].indices[1] = _ij16[1];
vinfos[1].maxsolutions = _nj16;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j17;
vinfos[2].indices[0] = _ij17[0];
vinfos[2].indices[1] = _ij17[1];
vinfos[2].maxsolutions = _nj17;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x859=cj17*cj17;
IkReal x860=(cj15*r01);
IkReal x861=((0.0707296823218818)*sj17);
IkReal x862=(r00*sj15);
IkReal x863=(cj17*sj17);
IkReal x864=((0.997495519808809)*cj17);
CheckValue<IkReal> x865 = IKatan2WithCheck(IkReal(((-0.00500268796135431)+(((-0.989994624077291)*x859))+(((-0.141105082467155)*x863))+(r02*r02))),((-0.0705525412335773)+(((0.141105082467155)*x859))+(((-0.989994624077291)*x863))+(((-1.0)*r02*x862))+((r02*x860))),IKFAST_ATAN2_MAGTHRESH);
if(!x865.valid){
continue;
}
CheckValue<IkReal> x866=IKPowWithIntegerCheck(IKsign(((((0.997495519808809)*r02*sj17))+(((-1.0)*x860*x861))+(((-1.0)*x860*x864))+((x862*x864))+((x861*x862))+(((-0.0707296823218818)*cj17*r02)))),-1);
if(!x866.valid){
continue;
}
j16array[0]=((-1.5707963267949)+(x865.value)+(((1.5707963267949)*(x866.value))));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[6];
IkReal x867=IKcos(j16);
IkReal x868=IKsin(j16);
IkReal x869=((0.997495519808809)*sj17);
IkReal x870=((1.0)*r01);
IkReal x871=((0.997495519808809)*cj17);
IkReal x872=((0.0707296823218818)*cj17);
IkReal x873=((1.0)*r00);
IkReal x874=((0.0707296823218818)*sj17);
IkReal x875=((1.0)*r02);
IkReal x876=(sj15*x868);
IkReal x877=(cj15*x867);
IkReal x878=(cj15*x868);
IkReal x879=(sj15*x867);
IkReal x880=(x868*x874);
evalcond[0]=((((-1.0)*x869))+((r01*x877))+(((-1.0)*x873*x879))+((r02*x868))+x872);
evalcond[1]=(((r01*x878))+(((-1.0)*x873*x876))+(((-1.0)*x867*x875))+(((-1.0)*x871))+(((-1.0)*x874)));
evalcond[2]=(((x868*x869))+(((-1.0)*x868*x872))+(((-1.0)*x867*x874))+(((-1.0)*x867*x871))+(((-1.0)*x875)));
evalcond[3]=(((x867*x869))+((x868*x871))+((r00*sj15))+(((-1.0)*x867*x872))+x880+(((-1.0)*cj15*x870)));
evalcond[4]=(((x872*x879))+(((-1.0)*x871*x876))+(((-1.0)*x869*x879))+(((-1.0)*x874*x876))+(((-1.0)*x873)));
evalcond[5]=((((-1.0)*x872*x877))+((x871*x878))+((x874*x878))+((x869*x877))+(((-1.0)*x870)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(3);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j15;
vinfos[0].indices[0] = _ij15[0];
vinfos[0].indices[1] = _ij15[1];
vinfos[0].maxsolutions = _nj15;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j16;
vinfos[1].indices[0] = _ij16[0];
vinfos[1].indices[1] = _ij16[1];
vinfos[1].maxsolutions = _nj16;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j17;
vinfos[2].indices[0] = _ij17[0];
vinfos[2].indices[1] = _ij17[1];
vinfos[2].maxsolutions = _nj17;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
}
}

}

}
}
return solutions.GetNumSolutions()>0;
}
static inline void polyroots2(IkReal rawcoeffs[2+1], IkReal rawroots[2], int& numroots) {
    IkReal det = rawcoeffs[1]*rawcoeffs[1]-4*rawcoeffs[0]*rawcoeffs[2];
    if( det < 0 ) {
        numroots=0;
    }
    else if( det == 0 ) {
        rawroots[0] = -0.5*rawcoeffs[1]/rawcoeffs[0];
        numroots = 1;
    }
    else {
        det = IKsqrt(det);
        rawroots[0] = (-rawcoeffs[1]+det)/(2*rawcoeffs[0]);
        rawroots[1] = (-rawcoeffs[1]-det)/(2*rawcoeffs[0]);//rawcoeffs[2]/(rawcoeffs[0]*rawroots[0]);
        numroots = 2;
    }
}
};


/// solves the inverse kinematics equations.
/// \param pfree is an array specifying the free joints of the chain.
IKFAST_API bool ComputeIk(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions) {
IKSolver solver;
return solver.ComputeIk(eetrans,eerot,pfree,solutions);
}

IKFAST_API bool ComputeIk2(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions, void* pOpenRAVEManip) {
IKSolver solver;
return solver.ComputeIk(eetrans,eerot,pfree,solutions);
}

IKFAST_API const char* GetKinematicsHash() { return "d12c6bf757845ec19f86a54d5dcff771"; }

IKFAST_API const char* GetIkFastVersion() { return "0x10000048"; }

#ifdef IKFAST_NAMESPACE
} // end namespace
#endif

#ifndef IKFAST_NO_MAIN
#include <stdio.h>
#include <stdlib.h>
#ifdef IKFAST_NAMESPACE
using namespace IKFAST_NAMESPACE;
#endif
int main(int argc, char** argv)
{
    if( argc != 12+GetNumFreeParameters()+1 ) {
        printf("\nUsage: ./ik r00 r01 r02 t0 r10 r11 r12 t1 r20 r21 r22 t2 free0 ...\n\n"
               "Returns the ik solutions given the transformation of the end effector specified by\n"
               "a 3x3 rotation R (rXX), and a 3x1 translation (tX).\n"
               "There are %d free parameters that have to be specified.\n\n",GetNumFreeParameters());
        return 1;
    }

    IkSolutionList<IkReal> solutions;
    std::vector<IkReal> vfree(GetNumFreeParameters());
    IkReal eerot[9],eetrans[3];
    eerot[0] = atof(argv[1]); eerot[1] = atof(argv[2]); eerot[2] = atof(argv[3]); eetrans[0] = atof(argv[4]);
    eerot[3] = atof(argv[5]); eerot[4] = atof(argv[6]); eerot[5] = atof(argv[7]); eetrans[1] = atof(argv[8]);
    eerot[6] = atof(argv[9]); eerot[7] = atof(argv[10]); eerot[8] = atof(argv[11]); eetrans[2] = atof(argv[12]);
    for(std::size_t i = 0; i < vfree.size(); ++i)
        vfree[i] = atof(argv[13+i]);
    bool bSuccess = ComputeIk(eetrans, eerot, vfree.size() > 0 ? &vfree[0] : NULL, solutions);

    if( !bSuccess ) {
        fprintf(stderr,"Failed to get ik solution\n");
        return -1;
    }

    printf("Found %d ik solutions:\n", (int)solutions.GetNumSolutions());
    std::vector<IkReal> solvalues(GetNumJoints());
    for(std::size_t i = 0; i < solutions.GetNumSolutions(); ++i) {
        const IkSolutionBase<IkReal>& sol = solutions.GetSolution(i);
        printf("sol%d (free=%d): ", (int)i, (int)sol.GetFree().size());
        std::vector<IkReal> vsolfree(sol.GetFree().size());
        sol.GetSolution(&solvalues[0],vsolfree.size()>0?&vsolfree[0]:NULL);
        for( std::size_t j = 0; j < solvalues.size(); ++j)
            printf("%.15f, ", solvalues[j]);
        printf("\n");
    }
    return 0;
}

#endif
