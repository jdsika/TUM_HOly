/// autogenerated analytical inverse kinematics code from ikfast program part of OpenRAVE
/// \author Rosen Diankov
///
/// Licensed under the Apache License, Version 2.0 (the "License");
/// you may not use this file except in compliance with the License.
/// You may obtain a copy of the License at
///     http://www.apache.org/licenses/LICENSE-2.0
/// 
/// Unless required by applicable law or agreed to in writing, software
/// distributed under the License is distributed on an "AS IS" BASIS,
/// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
/// See the License for the specific language governing permissions and
/// limitations under the License.
///
/// ikfast version 0x10000048 generated on 2015-06-10 18:19:09.855967
/// To compile with gcc:
///     gcc -lstdc++ ik.cpp
/// To compile without any main function as a shared object (might need -llapack):
///     gcc -fPIC -lstdc++ -DIKFAST_NO_MAIN -DIKFAST_CLIBRARY -shared -Wl,-soname,libik.so -o libik.so ik.cpp
#define IKFAST_HAS_LIBRARY
#include "ikfast.h" // found inside share/openrave-X.Y/python/ikfast.h
using namespace ikfast;

// check if the included ikfast version matches what this file was compiled with
#define IKFAST_COMPILE_ASSERT(x) extern int __dummy[(int)x]
IKFAST_COMPILE_ASSERT(IKFAST_VERSION==0x10000048);

#include <cmath>
#include <vector>
#include <limits>
#include <algorithm>
#include <complex>

#ifndef IKFAST_ASSERT
#include <stdexcept>
#include <sstream>
#include <iostream>

#ifdef _MSC_VER
#ifndef __PRETTY_FUNCTION__
#define __PRETTY_FUNCTION__ __FUNCDNAME__
#endif
#endif

#ifndef __PRETTY_FUNCTION__
#define __PRETTY_FUNCTION__ __func__
#endif

#define IKFAST_ASSERT(b) { if( !(b) ) { std::stringstream ss; ss << "ikfast exception: " << __FILE__ << ":" << __LINE__ << ": " <<__PRETTY_FUNCTION__ << ": Assertion '" << #b << "' failed"; throw std::runtime_error(ss.str()); } }

#endif

#if defined(_MSC_VER)
#define IKFAST_ALIGNED16(x) __declspec(align(16)) x
#else
#define IKFAST_ALIGNED16(x) x __attribute((aligned(16)))
#endif

#define IK2PI  ((IkReal)6.28318530717959)
#define IKPI  ((IkReal)3.14159265358979)
#define IKPI_2  ((IkReal)1.57079632679490)

#ifdef _MSC_VER
#ifndef isnan
#define isnan _isnan
#endif
#ifndef isinf
#define isinf _isinf
#endif
//#ifndef isfinite
//#define isfinite _isfinite
//#endif
#endif // _MSC_VER

// lapack routines
extern "C" {
  void dgetrf_ (const int* m, const int* n, double* a, const int* lda, int* ipiv, int* info);
  void zgetrf_ (const int* m, const int* n, std::complex<double>* a, const int* lda, int* ipiv, int* info);
  void dgetri_(const int* n, const double* a, const int* lda, int* ipiv, double* work, const int* lwork, int* info);
  void dgesv_ (const int* n, const int* nrhs, double* a, const int* lda, int* ipiv, double* b, const int* ldb, int* info);
  void dgetrs_(const char *trans, const int *n, const int *nrhs, double *a, const int *lda, int *ipiv, double *b, const int *ldb, int *info);
  void dgeev_(const char *jobvl, const char *jobvr, const int *n, double *a, const int *lda, double *wr, double *wi,double *vl, const int *ldvl, double *vr, const int *ldvr, double *work, const int *lwork, int *info);
}

using namespace std; // necessary to get std math routines

#ifdef IKFAST_NAMESPACE
namespace IKFAST_NAMESPACE {
#endif

inline float IKabs(float f) { return fabsf(f); }
inline double IKabs(double f) { return fabs(f); }

inline float IKsqr(float f) { return f*f; }
inline double IKsqr(double f) { return f*f; }

inline float IKlog(float f) { return logf(f); }
inline double IKlog(double f) { return log(f); }

// allows asin and acos to exceed 1
#ifndef IKFAST_SINCOS_THRESH
#define IKFAST_SINCOS_THRESH ((IkReal)2e-6)
#endif

// used to check input to atan2 for degenerate cases
#ifndef IKFAST_ATAN2_MAGTHRESH
#define IKFAST_ATAN2_MAGTHRESH ((IkReal)2e-6)
#endif

// minimum distance of separate solutions
#ifndef IKFAST_SOLUTION_THRESH
#define IKFAST_SOLUTION_THRESH ((IkReal)1e-6)
#endif

// there are checkpoints in ikfast that are evaluated to make sure they are 0. This threshold speicfies by how much they can deviate
#ifndef IKFAST_EVALCOND_THRESH
#define IKFAST_EVALCOND_THRESH ((IkReal)0.000005)
#endif


inline float IKasin(float f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return float(-IKPI_2);
else if( f >= 1 ) return float(IKPI_2);
return asinf(f);
}
inline double IKasin(double f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return -IKPI_2;
else if( f >= 1 ) return IKPI_2;
return asin(f);
}

// return positive value in [0,y)
inline float IKfmod(float x, float y)
{
    while(x < 0) {
        x += y;
    }
    return fmodf(x,y);
}

// return positive value in [0,y)
inline double IKfmod(double x, double y)
{
    while(x < 0) {
        x += y;
    }
    return fmod(x,y);
}

inline float IKacos(float f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return float(IKPI);
else if( f >= 1 ) return float(0);
return acosf(f);
}
inline double IKacos(double f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return IKPI;
else if( f >= 1 ) return 0;
return acos(f);
}
inline float IKsin(float f) { return sinf(f); }
inline double IKsin(double f) { return sin(f); }
inline float IKcos(float f) { return cosf(f); }
inline double IKcos(double f) { return cos(f); }
inline float IKtan(float f) { return tanf(f); }
inline double IKtan(double f) { return tan(f); }
inline float IKsqrt(float f) { if( f <= 0.0f ) return 0.0f; return sqrtf(f); }
inline double IKsqrt(double f) { if( f <= 0.0 ) return 0.0; return sqrt(f); }
inline float IKatan2Simple(float fy, float fx) {
    return atan2f(fy,fx);
}
inline float IKatan2(float fy, float fx) {
    if( isnan(fy) ) {
        IKFAST_ASSERT(!isnan(fx)); // if both are nan, probably wrong value will be returned
        return float(IKPI_2);
    }
    else if( isnan(fx) ) {
        return 0;
    }
    return atan2f(fy,fx);
}
inline double IKatan2Simple(double fy, double fx) {
    return atan2(fy,fx);
}
inline double IKatan2(double fy, double fx) {
    if( isnan(fy) ) {
        IKFAST_ASSERT(!isnan(fx)); // if both are nan, probably wrong value will be returned
        return IKPI_2;
    }
    else if( isnan(fx) ) {
        return 0;
    }
    return atan2(fy,fx);
}

template <typename T>
struct CheckValue
{
    T value;
    bool valid;
};

template <typename T>
inline CheckValue<T> IKatan2WithCheck(T fy, T fx, T epsilon)
{
    CheckValue<T> ret;
    ret.valid = false;
    ret.value = 0;
    if( !isnan(fy) && !isnan(fx) ) {
        if( IKabs(fy) >= IKFAST_ATAN2_MAGTHRESH || IKabs(fx) > IKFAST_ATAN2_MAGTHRESH ) {
            ret.value = IKatan2Simple(fy,fx);
            ret.valid = true;
        }
    }
    return ret;
}

inline float IKsign(float f) {
    if( f > 0 ) {
        return float(1);
    }
    else if( f < 0 ) {
        return float(-1);
    }
    return 0;
}

inline double IKsign(double f) {
    if( f > 0 ) {
        return 1.0;
    }
    else if( f < 0 ) {
        return -1.0;
    }
    return 0;
}

template <typename T>
inline CheckValue<T> IKPowWithIntegerCheck(T f, int n)
{
    CheckValue<T> ret;
    ret.valid = true;
    if( n == 0 ) {
        ret.value = 1.0;
        return ret;
    }
    else if( n == 1 )
    {
        ret.value = f;
        return ret;
    }
    else if( n < 0 )
    {
        if( f == 0 )
        {
            ret.valid = false;
            ret.value = (T)1.0e30;
            return ret;
        }
        if( n == -1 ) {
            ret.value = T(1.0)/f;
            return ret;
        }
    }

    int num = n > 0 ? n : -n;
    if( num == 2 ) {
        ret.value = f*f;
    }
    else if( num == 3 ) {
        ret.value = f*f*f;
    }
    else {
        ret.value = 1.0;
        while(num>0) {
            if( num & 1 ) {
                ret.value *= f;
            }
            num >>= 1;
            f *= f;
        }
    }
    
    if( n < 0 ) {
        ret.value = T(1.0)/ret.value;
    }
    return ret;
}

/// solves the forward kinematics equations.
/// \param pfree is an array specifying the free joints of the chain.
IKFAST_API void ComputeFk(const IkReal* j, IkReal* eetrans, IkReal* eerot) {
IkReal x0,x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11;
x0=IKcos(j[1]);
x1=IKcos(j[0]);
x2=IKsin(j[1]);
x3=IKsin(j[0]);
x4=IKsin(j[2]);
x5=IKcos(j[2]);
x6=((0.997494764195995)*x1);
x7=((0.0797996)*x2);
x8=((0.0707403378672716)*x2);
x9=((0.997494764195995)*x2);
x10=(x0*x3);
x11=(x0*x1);
eetrans[0]=((0.07)+(((0.00565898)*x2))+(((0.0797996)*x0)));
eetrans[1]=((((-1.0)*x1*x7))+(((0.00565898)*x11)));
eetrans[2]=((0.03)+(((-1.0)*x3*x7))+(((0.00565898)*x10)));
eerot[0]=(((x4*(((((-0.0707403378672716)*x0))+x9))))+((x5*(((((-1.0)*x8))+(((-0.997494764195995)*x0)))))));
eerot[1]=(((x5*(((((-0.0707403378672716)*x11))+((x2*x6))))))+((x4*((((x0*x6))+((x1*x8)))))));
eerot[2]=(((x5*(((((-0.0707403378672716)*x10))+((x3*x9))))))+((x4*(((((0.997494764195995)*x10))+((x3*x8)))))));
}

IKFAST_API int GetNumFreeParameters() { return 1; }
IKFAST_API int* GetFreeParameters() { static int freeparams[] = {2}; return freeparams; }
IKFAST_API int GetNumJoints() { return 3; }

IKFAST_API int GetIkRealSize() { return sizeof(IkReal); }

IKFAST_API int GetIkType() { return 0x23000006; }

class IKSolver {
public:
IkReal j15,cj15,sj15,htj15,j15mul,j16,cj16,sj16,htj16,j16mul,j17,cj17,sj17,htj17,new_px,px,npx,new_py,py,npy,new_pz,pz,npz,pp;
unsigned char _ij15[2], _nj15,_ij16[2], _nj16,_ij17[2], _nj17;

IkReal j100, cj100, sj100;
unsigned char _ij100[2], _nj100;
bool ComputeIk(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions) {
j15=numeric_limits<IkReal>::quiet_NaN(); _ij15[0] = -1; _ij15[1] = -1; _nj15 = -1; j16=numeric_limits<IkReal>::quiet_NaN(); _ij16[0] = -1; _ij16[1] = -1; _nj16 = -1;  _ij17[0] = -1; _ij17[1] = -1; _nj17 = 0; 
for(int dummyiter = 0; dummyiter < 1; ++dummyiter) {
    solutions.Clear();
px = eetrans[0]; py = eetrans[1]; pz = eetrans[2];

j17=pfree[0]; cj17=cos(pfree[0]); sj17=sin(pfree[0]);
new_px=((0.03)+(((-1.0)*pz)));
new_py=py;
new_pz=((-0.07)+px);
px = new_px; py = new_py; pz = new_pz;
pp=((px*px)+(py*py)+(pz*pz));
{
IkReal j15eval[1];
IkReal x12=((9974852358.26759)*sj17);
IkReal x13=((707396621.343421)*cj17);
j15eval[0]=((IKabs((((px*x13))+(((-1.0)*px*x12)))))+(IKabs((((py*x13))+(((-1.0)*py*x12))))));
if( IKabs(j15eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[2];
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(px))+(IKabs(py)));
evalcond[1]=0;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j16eval[3];
px=0;
py=0;
pp=pz*pz;
IkReal x14=pz*pz;
IkReal x15=sj17*sj17;
IkReal x16=cj17*cj17;
j16eval[0]=(((x14*x15))+((x14*x16)));
j16eval[1]=pz;
j16eval[2]=(x15+x16);
if( IKabs(j16eval[0]) < 0.0000010000000000  || IKabs(j16eval[1]) < 0.0000010000000000  || IKabs(j16eval[2]) < 0.0000010000000000  )
{
{
IkReal evalcond[4];
bool bgotonextstatement = true;
do
{
evalcond[0]=IKabs(pz);
evalcond[1]=0;
evalcond[2]=((((2.47744983270028e-7)*cj17))+(((-0.0800000013421189)*sj17)));
evalcond[3]=((0.00640000021473902)+(((-0.00640000021467764)*(cj17*cj17)))+(((-3.96391979882109e-8)*cj17*sj17)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j15eval[1];
px=0;
py=0;
pp=0;
pz=0;
j15eval[0]=IKabs(((((-2.47744983270028e-7)*cj17))+(((0.0800000013421189)*sj17))));
if( IKabs(j15eval[0]) < 0.0000000100000000  )
{
{
IkReal j15eval[1];
px=0;
py=0;
pp=0;
pz=0;
IkReal x17=cj17*cj17;
j15eval[0]=((IKabs(((1.0)+(((-1.00000000000959)*x17)))))+(IKabs(((-2.0)+(((2.00000000001918)*x17))))));
if( IKabs(j15eval[0]) < 0.0000000100000000  )
{
continue; // no branches [j15, j16]

} else
{
IkReal op[4+1], zeror[4];
int numroots;
IkReal x18=cj17*cj17;
IkReal x19=((1.0)+(((-1.00000000000959)*x18)));
op[0]=x19;
op[1]=0;
op[2]=((-2.0)+(((2.00000000001918)*x18)));
op[3]=0;
op[4]=x19;
polyroots4(op,zeror,numroots);
IkReal j15array[4], cj15array[4], sj15array[4], tempj15array[1];
int numsolutions = 0;
for(int ij15 = 0; ij15 < numroots; ++ij15)
{
IkReal htj15 = zeror[ij15];
tempj15array[0]=((2.0)*(atan(htj15)));
for(int kj15 = 0; kj15 < 1; ++kj15)
{
j15array[numsolutions] = tempj15array[kj15];
if( j15array[numsolutions] > IKPI )
{
    j15array[numsolutions]-=IK2PI;
}
else if( j15array[numsolutions] < -IKPI )
{
    j15array[numsolutions]+=IK2PI;
}
sj15array[numsolutions] = IKsin(j15array[numsolutions]);
cj15array[numsolutions] = IKcos(j15array[numsolutions]);
numsolutions++;
}
}
bool j15valid[4]={true,true,true,true};
_nj15 = 4;
for(int ij15 = 0; ij15 < numsolutions; ++ij15)
    {
if( !j15valid[ij15] )
{
    continue;
}
    j15 = j15array[ij15]; cj15 = cj15array[ij15]; sj15 = sj15array[ij15];
htj15 = IKtan(j15/2);

_ij15[0] = ij15; _ij15[1] = -1;
for(int iij15 = ij15+1; iij15 < numsolutions; ++iij15)
{
if( j15valid[iij15] && IKabs(cj15array[ij15]-cj15array[iij15]) < IKFAST_SOLUTION_THRESH && IKabs(sj15array[ij15]-sj15array[iij15]) < IKFAST_SOLUTION_THRESH )
{
    j15valid[iij15]=false; _ij15[1] = iij15; break; 
}
}
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
j16array[0]=0;
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];

IkReal soleval[1];
IkReal x20=((0.0707403378672716)*sj16);
IkReal x21=(cj16*pz);
IkReal x22=(((px*sj15))+(((-1.0)*cj15*py)));
IkReal x23=(sj16*x22);
IkReal x24=((0.997494764195995)*x22);
IkReal x25=(cj16*x22);
soleval[0]=(((cj17*(((0.0800000013421189)+(((0.0707403378672716)*x25))+(((-1.0)*pz*x20))+(((-0.997494764195995)*x21))+(((-0.997494764195995)*x23))))))+(((-1.0)*sj17*(((-2.47744983270028e-7)+(((0.0707403378672716)*x21))+((x20*x22))+((cj16*x24))+(((-0.997494764195995)*pz*sj16)))))));
if( soleval[0] > 0.0000000000000000  )
{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(3);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j15;
vinfos[0].indices[0] = _ij15[0];
vinfos[0].indices[1] = _ij15[1];
vinfos[0].maxsolutions = _nj15;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j16;
vinfos[1].indices[0] = _ij16[0];
vinfos[1].indices[1] = _ij16[1];
vinfos[1].maxsolutions = _nj16;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j17;
vinfos[2].indices[0] = _ij17[0];
vinfos[2].indices[1] = _ij17[1];
vinfos[2].maxsolutions = _nj17;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
    }

}

}

} else
{
IkReal op[2+1], zeror[2];
int numroots;
IkReal x26=((2.47744983270028e-7)*cj17);
IkReal x27=((0.0800000013421189)*sj17);
op[0]=((((-1.0)*x26))+x27);
op[1]=0;
op[2]=((((-1.0)*x27))+x26);
polyroots2(op,zeror,numroots);
IkReal j15array[2], cj15array[2], sj15array[2], tempj15array[1];
int numsolutions = 0;
for(int ij15 = 0; ij15 < numroots; ++ij15)
{
IkReal htj15 = zeror[ij15];
tempj15array[0]=((2.0)*(atan(htj15)));
for(int kj15 = 0; kj15 < 1; ++kj15)
{
j15array[numsolutions] = tempj15array[kj15];
if( j15array[numsolutions] > IKPI )
{
    j15array[numsolutions]-=IK2PI;
}
else if( j15array[numsolutions] < -IKPI )
{
    j15array[numsolutions]+=IK2PI;
}
sj15array[numsolutions] = IKsin(j15array[numsolutions]);
cj15array[numsolutions] = IKcos(j15array[numsolutions]);
numsolutions++;
}
}
bool j15valid[2]={true,true};
_nj15 = 2;
for(int ij15 = 0; ij15 < numsolutions; ++ij15)
    {
if( !j15valid[ij15] )
{
    continue;
}
    j15 = j15array[ij15]; cj15 = cj15array[ij15]; sj15 = sj15array[ij15];
htj15 = IKtan(j15/2);

_ij15[0] = ij15; _ij15[1] = -1;
for(int iij15 = ij15+1; iij15 < numsolutions; ++iij15)
{
if( j15valid[iij15] && IKabs(cj15array[ij15]-cj15array[iij15]) < IKFAST_SOLUTION_THRESH && IKabs(sj15array[ij15]-sj15array[iij15]) < IKFAST_SOLUTION_THRESH )
{
    j15valid[iij15]=false; _ij15[1] = iij15; break; 
}
}
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
j16array[0]=0;
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];

IkReal soleval[1];
IkReal x28=((0.0707403378672716)*sj16);
IkReal x29=(cj16*pz);
IkReal x30=(((px*sj15))+(((-1.0)*cj15*py)));
IkReal x31=(sj16*x30);
IkReal x32=((0.997494764195995)*x30);
IkReal x33=(cj16*x30);
soleval[0]=(((cj17*(((0.0800000013421189)+(((-1.0)*pz*x28))+(((-0.997494764195995)*x31))+(((0.0707403378672716)*x33))+(((-0.997494764195995)*x29))))))+(((-1.0)*sj17*(((-2.47744983270028e-7)+((x28*x30))+((cj16*x32))+(((0.0707403378672716)*x29))+(((-0.997494764195995)*pz*sj16)))))));
if( soleval[0] > 0.0000000000000000  )
{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(3);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j15;
vinfos[0].indices[0] = _ij15[0];
vinfos[0].indices[1] = _ij15[1];
vinfos[0].maxsolutions = _nj15;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j16;
vinfos[1].indices[0] = _ij16[0];
vinfos[1].indices[1] = _ij16[1];
vinfos[1].maxsolutions = _nj16;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j17;
vinfos[2].indices[0] = _ij17[0];
vinfos[2].indices[1] = _ij17[1];
vinfos[2].maxsolutions = _nj17;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
    }

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j15, j16]

}
} while(0);
if( bgotonextstatement )
{
}
}
}

} else
{
{
IkReal j16array[2], cj16array[2], sj16array[2];
bool j16valid[2]={false};
_nj16 = 2;
IkReal x34=(cj17*pz);
IkReal x35=(pz*sj17);
IkReal x36=((((0.997494764195995)*x35))+(((-0.0707403378672716)*x34)));
IkReal x37=((((0.997494764195995)*x34))+(((0.0707403378672716)*x35)));
CheckValue<IkReal> x40 = IKatan2WithCheck(IkReal(x36),x37,IKFAST_ATAN2_MAGTHRESH);
if(!x40.valid){
continue;
}
IkReal x38=((1.0)*(x40.value));
if((((x36*x36)+(x37*x37))) < -0.00001)
continue;
CheckValue<IkReal> x41=IKPowWithIntegerCheck(IKabs(IKsqrt(((x36*x36)+(x37*x37)))),-1);
if(!x41.valid){
continue;
}
if( (((x41.value)*(((((2.47744983270028e-7)*cj17))+(((-0.0800000013421189)*sj17)))))) < -1-IKFAST_SINCOS_THRESH || (((x41.value)*(((((2.47744983270028e-7)*cj17))+(((-0.0800000013421189)*sj17)))))) > 1+IKFAST_SINCOS_THRESH )
    continue;
IkReal x39=IKasin(((x41.value)*(((((2.47744983270028e-7)*cj17))+(((-0.0800000013421189)*sj17))))));
j16array[0]=((((-1.0)*x39))+(((-1.0)*x38)));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
j16array[1]=((3.14159265358979)+(((-1.0)*x38))+x39);
sj16array[1]=IKsin(j16array[1]);
cj16array[1]=IKcos(j16array[1]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
if( j16array[1] > IKPI )
{
    j16array[1]-=IK2PI;
}
else if( j16array[1] < -IKPI )
{    j16array[1]+=IK2PI;
}
j16valid[1] = true;
for(int ij16 = 0; ij16 < 2; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 2; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[1];
IkReal x42=cj17*cj17;
IkReal x43=pz*pz;
IkReal x44=IKcos(j16);
IkReal x45=IKsin(j16);
IkReal x46=(cj17*sj17);
IkReal x47=x44*x44;
IkReal x48=((0.989991609196848)*x43);
IkReal x49=((0.141126233280118)*x43);
IkReal x50=(x44*x45);
IkReal x51=(x42*x43);
evalcond[0]=((0.00640000021473902)+(((-3.96391979882109e-8)*x46))+(((-1.9799832183937)*x43*x46*x50))+(((-1.0)*x42*x48))+(((-0.00640000021467764)*x42))+(((-1.0)*x49*x50))+(((1.9799832183937)*x47*x51))+(((-0.00500419540157573)*x43))+(((0.282252466560236)*x50*x51))+(((0.282252466560236)*x43*x46*x47))+(((-1.0)*x47*x48))+(((-1.0)*x46*x49)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j15eval[1];
px=0;
py=0;
pp=pz*pz;
IkReal x52=(pz*sj16);
IkReal x53=(cj16*pz);
j15eval[0]=IKabs(((((-285536.913537291)*sj17*x52))+(((285536.913537291)*cj17*x53))+(((-1.0)*cj17))+(((-4026296.52084129)*cj17*x52))+(((322912.699527496)*sj17))+(((-4026296.52084129)*sj17*x53))));
if( IKabs(j15eval[0]) < 0.0000000100000000  )
{
continue; // no branches [j15]

} else
{
IkReal op[2+1], zeror[2];
int numroots;
IkReal x54=(pz*sj16);
IkReal x55=(cj16*pz);
IkReal x56=((4026296.52084129)*cj17*x54);
IkReal x57=((4026296.52084129)*sj17*x55);
IkReal x58=((285536.913537291)*sj17*x54);
IkReal x59=((((285536.913537291)*cj17*x55))+(((322912.699527496)*sj17)));
IkReal x60=(x58+x57+x56);
op[0]=(x59+(((-1.0)*cj17))+(((-1.0)*x60)));
op[1]=0;
op[2]=(cj17+x60+(((-1.0)*x59)));
polyroots2(op,zeror,numroots);
IkReal j15array[2], cj15array[2], sj15array[2], tempj15array[1];
int numsolutions = 0;
for(int ij15 = 0; ij15 < numroots; ++ij15)
{
IkReal htj15 = zeror[ij15];
tempj15array[0]=((2.0)*(atan(htj15)));
for(int kj15 = 0; kj15 < 1; ++kj15)
{
j15array[numsolutions] = tempj15array[kj15];
if( j15array[numsolutions] > IKPI )
{
    j15array[numsolutions]-=IK2PI;
}
else if( j15array[numsolutions] < -IKPI )
{
    j15array[numsolutions]+=IK2PI;
}
sj15array[numsolutions] = IKsin(j15array[numsolutions]);
cj15array[numsolutions] = IKcos(j15array[numsolutions]);
numsolutions++;
}
}
bool j15valid[2]={true,true};
_nj15 = 2;
for(int ij15 = 0; ij15 < numsolutions; ++ij15)
    {
if( !j15valid[ij15] )
{
    continue;
}
    j15 = j15array[ij15]; cj15 = cj15array[ij15]; sj15 = sj15array[ij15];
htj15 = IKtan(j15/2);

_ij15[0] = ij15; _ij15[1] = -1;
for(int iij15 = ij15+1; iij15 < numsolutions; ++iij15)
{
if( j15valid[iij15] && IKabs(cj15array[ij15]-cj15array[iij15]) < IKFAST_SOLUTION_THRESH && IKabs(sj15array[ij15]-sj15array[iij15]) < IKFAST_SOLUTION_THRESH )
{
    j15valid[iij15]=false; _ij15[1] = iij15; break; 
}
}
IkReal soleval[1];
IkReal x61=((0.0707403378672716)*sj16);
IkReal x62=(cj16*pz);
IkReal x63=(((px*sj15))+(((-1.0)*cj15*py)));
IkReal x64=(sj16*x63);
IkReal x65=((0.997494764195995)*x63);
IkReal x66=(cj16*x63);
soleval[0]=(((cj17*(((0.0800000013421189)+(((0.0707403378672716)*x66))+(((-0.997494764195995)*x62))+(((-0.997494764195995)*x64))+(((-1.0)*pz*x61))))))+(((-1.0)*sj17*(((-2.47744983270028e-7)+(((0.0707403378672716)*x62))+((cj16*x65))+((x61*x63))+(((-0.997494764195995)*pz*sj16)))))));
if( soleval[0] > 0.0000000000000000  )
{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(3);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j15;
vinfos[0].indices[0] = _ij15[0];
vinfos[0].indices[1] = _ij15[1];
vinfos[0].maxsolutions = _nj15;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j16;
vinfos[1].indices[0] = _ij16[0];
vinfos[1].indices[1] = _ij16[1];
vinfos[1].maxsolutions = _nj16;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j17;
vinfos[2].indices[0] = _ij17[0];
vinfos[2].indices[1] = _ij17[1];
vinfos[2].maxsolutions = _nj17;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
    }

}

}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j15, j16]

}
} while(0);
if( bgotonextstatement )
{
}
}
}

} else
{
{
IkReal j15array[2], cj15array[2], sj15array[2];
bool j15valid[2]={false};
_nj15 = 2;
IkReal x67=((0.0707403378672716)*cj17);
IkReal x68=((0.997494764195995)*sj17);
CheckValue<IkReal> x70 = IKatan2WithCheck(IkReal(((((-1.0)*px*x68))+((px*x67)))),((((-1.0)*py*x68))+((py*x67))),IKFAST_ATAN2_MAGTHRESH);
if(!x70.valid){
continue;
}
IkReal x69=x70.value;
j15array[0]=((-1.0)*x69);
sj15array[0]=IKsin(j15array[0]);
cj15array[0]=IKcos(j15array[0]);
j15array[1]=((3.14159265358979)+(((-1.0)*x69)));
sj15array[1]=IKsin(j15array[1]);
cj15array[1]=IKcos(j15array[1]);
if( j15array[0] > IKPI )
{
    j15array[0]-=IK2PI;
}
else if( j15array[0] < -IKPI )
{    j15array[0]+=IK2PI;
}
j15valid[0] = true;
if( j15array[1] > IKPI )
{
    j15array[1]-=IK2PI;
}
else if( j15array[1] < -IKPI )
{    j15array[1]+=IK2PI;
}
j15valid[1] = true;
for(int ij15 = 0; ij15 < 2; ++ij15)
{
if( !j15valid[ij15] )
{
    continue;
}
_ij15[0] = ij15; _ij15[1] = -1;
for(int iij15 = ij15+1; iij15 < 2; ++iij15)
{
if( j15valid[iij15] && IKabs(cj15array[ij15]-cj15array[iij15]) < IKFAST_SOLUTION_THRESH && IKabs(sj15array[ij15]-sj15array[iij15]) < IKFAST_SOLUTION_THRESH )
{
    j15valid[iij15]=false; _ij15[1] = iij15; break; 
}
}
j15 = j15array[ij15]; cj15 = cj15array[ij15]; sj15 = sj15array[ij15];
{
IkReal evalcond[1];
IkReal x71=IKcos(j15);
IkReal x72=IKsin(j15);
IkReal x73=cj17*cj17;
IkReal x74=px*px;
IkReal x75=py*py;
IkReal x76=x71*x71;
IkReal x77=((0.989991609196848)*x73);
IkReal x78=((0.141126233280118)*cj17*sj17);
IkReal x79=(x75*x76);
IkReal x80=(x74*x76);
IkReal x81=(px*py*x71*x72);
evalcond[0]=(((x77*x80))+(((0.994995804598424)*x79))+(((-0.994995804598424)*x75))+((x78*x80))+(((-0.994995804598424)*x80))+(((-1.0)*x78*x79))+((x75*x77))+((x75*x78))+(((0.282252466560236)*cj17*sj17*x81))+(((1.9799832183937)*x73*x81))+(((-1.0)*x77*x79))+(((-1.98999160919685)*x81)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j16eval[1];
IkReal x82=cj17*cj17;
IkReal x83=cj15*cj15;
IkReal x84=pz*pz;
IkReal x85=py*py;
IkReal x86=sj17*sj17;
IkReal x87=(x83*x84);
j16eval[0]=(((x82*x87))+((x82*x85))+((x85*x86))+((x86*x87)));
if( IKabs(j16eval[0]) < 0.0000010000000000  )
{
{
IkReal j16eval[1];
IkReal x88=sj17*sj17;
IkReal x89=cj17*cj17;
IkReal x90=pz*pz;
IkReal x91=px*px;
IkReal x92=sj15*sj15;
IkReal x93=cj15*cj15;
IkReal x94=py*py;
IkReal x95=(x91*x92);
IkReal x96=(x93*x94);
IkReal x97=((2.0)*cj15*px*py*sj15);
j16eval[0]=(((x89*x96))+((x89*x95))+((x89*x90))+((x88*x95))+((x88*x96))+((x88*x90))+(((-1.0)*x88*x97))+(((-1.0)*x89*x97)));
if( IKabs(j16eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[5];
bool bgotonextstatement = true;
do
{
IkReal x98=py*py;
CheckValue<IkReal> x99=IKPowWithIntegerCheck(pz,-2);
if(!x99.valid){
continue;
}
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.0)+(IKsign(sj15)))))+(IKabs(cj15))+(IKabs((x98*(x99.value))))), 6.28318530717959)));
evalcond[1]=((((0.0707403378672716)*cj17*py))+(((-0.997494764195995)*py*sj17)));
evalcond[2]=((((-0.994995804598424)*x98))+(((0.989991609196848)*x98*(cj17*cj17)))+(((0.141126233280118)*cj17*sj17*x98)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j16eval[4];
sj15=1.0;
cj15=0;
j15=1.57079633263667;
IkReal x100=pz*pz;
IkReal x101=cj17*cj17;
IkReal x102=px*px;
j16eval[0]=1.00502936331837;
j16eval[1]=cj17;
j16eval[2]=(x100+x102);
j16eval[3]=(((x101*x102))+((x100*x101)));
if( IKabs(j16eval[0]) < 0.0000010000000000  || IKabs(j16eval[1]) < 0.0000010000000000  || IKabs(j16eval[2]) < 0.0000010000000000  || IKabs(j16eval[3]) < 0.0000010000000000  )
{
{
IkReal evalcond[5];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j17)))), 6.28318530717959)));
evalcond[1]=((-0.997494764195995)*py);
evalcond[2]=((-0.994995804598424)*(py*py));
evalcond[3]=0;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j16eval[1];
sj15=1.0;
cj15=0;
j15=1.57079633263667;
sj17=1.0;
cj17=0;
j17=1.5707963267949;
IkReal x103=pz*pz;
IkReal x104=px*px;
IkReal x105=(px*pz);
IkReal x106=((56.4031665253039)*x104);
IkReal x107=((((791.329298520291)*x105))+(((56.4031665253039)*x103)));
j16eval[0]=((IKabs(((((-1.0)*x107))+x106)))+(IKabs(((2.55785384108853)+(((-793.329298520291)*x104))+(((393.664649260146)*x103))+(((-169.209499575912)*x105)))))+(IKabs(((((-1.0)*x106))+x107)))+(IKabs(((1.27892692054426)+(((28.201583262652)*x105))+(((-1.0)*x104))+(((-198.832324630073)*x103))))));
if( IKabs(j16eval[0]) < 0.0000000100000000  )
{
continue; // no branches [j16]

} else
{
IkReal op[4+1], zeror[4];
int numroots;
IkReal x108=pz*pz;
IkReal x109=px*px;
IkReal x110=(px*pz);
IkReal x111=((56.4031665253039)*x109);
IkReal x112=((((791.329298520291)*x110))+(((56.4031665253039)*x108)));
IkReal x113=((1.27892692054426)+(((28.201583262652)*x110))+(((-1.0)*x109))+(((-198.832324630073)*x108)));
op[0]=x113;
op[1]=((((-1.0)*x111))+x112);
op[2]=((2.55785384108853)+(((-793.329298520291)*x109))+(((393.664649260146)*x108))+(((-169.209499575912)*x110)));
op[3]=((((-1.0)*x112))+x111);
op[4]=x113;
polyroots4(op,zeror,numroots);
IkReal j16array[4], cj16array[4], sj16array[4], tempj16array[1];
int numsolutions = 0;
for(int ij16 = 0; ij16 < numroots; ++ij16)
{
IkReal htj16 = zeror[ij16];
tempj16array[0]=((2.0)*(atan(htj16)));
for(int kj16 = 0; kj16 < 1; ++kj16)
{
j16array[numsolutions] = tempj16array[kj16];
if( j16array[numsolutions] > IKPI )
{
    j16array[numsolutions]-=IK2PI;
}
else if( j16array[numsolutions] < -IKPI )
{
    j16array[numsolutions]+=IK2PI;
}
sj16array[numsolutions] = IKsin(j16array[numsolutions]);
cj16array[numsolutions] = IKcos(j16array[numsolutions]);
numsolutions++;
}
}
bool j16valid[4]={true,true,true,true};
_nj16 = 4;
for(int ij16 = 0; ij16 < numsolutions; ++ij16)
    {
if( !j16valid[ij16] )
{
    continue;
}
    j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
htj16 = IKtan(j16/2);

_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < numsolutions; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
IkReal soleval[1];
IkReal x114=((0.0707403378672716)*sj16);
IkReal x115=(cj16*pz);
IkReal x116=(((px*sj15))+(((-1.0)*cj15*py)));
IkReal x117=(sj16*x116);
IkReal x118=((0.997494764195995)*x116);
IkReal x119=(cj16*x116);
soleval[0]=(((cj17*(((0.0800000013421189)+(((-0.997494764195995)*x117))+(((-0.997494764195995)*x115))+(((0.0707403378672716)*x119))+(((-1.0)*pz*x114))))))+(((-1.0)*sj17*(((-2.47744983270028e-7)+((cj16*x118))+((x114*x116))+(((0.0707403378672716)*x115))+(((-0.997494764195995)*pz*sj16)))))));
if( soleval[0] > 0.0000000000000000  )
{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(3);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j15;
vinfos[0].indices[0] = _ij15[0];
vinfos[0].indices[1] = _ij15[1];
vinfos[0].maxsolutions = _nj15;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j16;
vinfos[1].indices[0] = _ij16[0];
vinfos[1].indices[1] = _ij16[1];
vinfos[1].maxsolutions = _nj16;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j17;
vinfos[2].indices[0] = _ij17[0];
vinfos[2].indices[1] = _ij17[1];
vinfos[2].maxsolutions = _nj17;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
    }

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j17)))), 6.28318530717959)));
evalcond[1]=((0.997494764195995)*py);
evalcond[2]=((-0.994995804598424)*(py*py));
evalcond[3]=0;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j16eval[1];
sj15=1.0;
cj15=0;
j15=1.57079633263667;
sj17=-1.0;
cj17=0;
j17=-1.5707963267949;
IkReal x120=pz*pz;
IkReal x121=px*px;
IkReal x122=(px*pz);
IkReal x123=((56.4031665253039)*x121);
IkReal x124=((((56.4031665253039)*x120))+(((791.329298520291)*x122)));
j16eval[0]=((IKabs(((((-1.0)*x124))+x123)))+(IKabs(((1.27892692054426)+(((28.201583262652)*x122))+(((-1.0)*x121))+(((-198.832324630073)*x120)))))+(IKabs(((((-1.0)*x123))+x124)))+(IKabs(((2.55785384108853)+(((-793.329298520291)*x121))+(((-169.209499575912)*x122))+(((393.664649260146)*x120))))));
if( IKabs(j16eval[0]) < 0.0000000100000000  )
{
continue; // no branches [j16]

} else
{
IkReal op[4+1], zeror[4];
int numroots;
IkReal x125=pz*pz;
IkReal x126=px*px;
IkReal x127=(px*pz);
IkReal x128=((56.4031665253039)*x126);
IkReal x129=((((56.4031665253039)*x125))+(((791.329298520291)*x127)));
IkReal x130=((1.27892692054426)+(((28.201583262652)*x127))+(((-1.0)*x126))+(((-198.832324630073)*x125)));
op[0]=x130;
op[1]=((((-1.0)*x128))+x129);
op[2]=((2.55785384108853)+(((-793.329298520291)*x126))+(((-169.209499575912)*x127))+(((393.664649260146)*x125)));
op[3]=((((-1.0)*x129))+x128);
op[4]=x130;
polyroots4(op,zeror,numroots);
IkReal j16array[4], cj16array[4], sj16array[4], tempj16array[1];
int numsolutions = 0;
for(int ij16 = 0; ij16 < numroots; ++ij16)
{
IkReal htj16 = zeror[ij16];
tempj16array[0]=((2.0)*(atan(htj16)));
for(int kj16 = 0; kj16 < 1; ++kj16)
{
j16array[numsolutions] = tempj16array[kj16];
if( j16array[numsolutions] > IKPI )
{
    j16array[numsolutions]-=IK2PI;
}
else if( j16array[numsolutions] < -IKPI )
{
    j16array[numsolutions]+=IK2PI;
}
sj16array[numsolutions] = IKsin(j16array[numsolutions]);
cj16array[numsolutions] = IKcos(j16array[numsolutions]);
numsolutions++;
}
}
bool j16valid[4]={true,true,true,true};
_nj16 = 4;
for(int ij16 = 0; ij16 < numsolutions; ++ij16)
    {
if( !j16valid[ij16] )
{
    continue;
}
    j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
htj16 = IKtan(j16/2);

_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < numsolutions; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
IkReal soleval[1];
IkReal x131=((0.0707403378672716)*sj16);
IkReal x132=(cj16*pz);
IkReal x133=(((px*sj15))+(((-1.0)*cj15*py)));
IkReal x134=(sj16*x133);
IkReal x135=((0.997494764195995)*x133);
IkReal x136=(cj16*x133);
soleval[0]=((((-1.0)*sj17*(((-2.47744983270028e-7)+((cj16*x135))+(((0.0707403378672716)*x132))+((x131*x133))+(((-0.997494764195995)*pz*sj16))))))+((cj17*(((0.0800000013421189)+(((-1.0)*pz*x131))+(((0.0707403378672716)*x136))+(((-0.997494764195995)*x134))+(((-0.997494764195995)*x132)))))));
if( soleval[0] > 0.0000000000000000  )
{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(3);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j15;
vinfos[0].indices[0] = _ij15[0];
vinfos[0].indices[1] = _ij15[1];
vinfos[0].maxsolutions = _nj15;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j16;
vinfos[1].indices[0] = _ij16[0];
vinfos[1].indices[1] = _ij16[1];
vinfos[1].maxsolutions = _nj16;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j17;
vinfos[2].indices[0] = _ij17[0];
vinfos[2].indices[1] = _ij17[1];
vinfos[2].maxsolutions = _nj17;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
    }

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x137=py*py;
IkReal x138=cj17*cj17;
evalcond[0]=((px*px)+(pz*pz));
evalcond[1]=((((0.0707403378672716)*cj17*py))+(((-0.997494764195995)*py*sj17)));
evalcond[2]=((((0.141126233280118)*cj17*sj17*x137))+(((0.989991609196848)*x137*x138))+(((-0.994995804598424)*x137)));
evalcond[3]=((-0.00567319268543858)*cj17);
evalcond[4]=((0.00640000021473902)+(((-0.00640000302581045)*x138)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
j16array[0]=0;
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];

IkReal soleval[1];
IkReal x139=((0.0707403378672716)*sj16);
IkReal x140=(cj16*pz);
IkReal x141=(((px*sj15))+(((-1.0)*cj15*py)));
IkReal x142=(sj16*x141);
IkReal x143=((0.997494764195995)*x141);
IkReal x144=(cj16*x141);
soleval[0]=((((-1.0)*sj17*(((-2.47744983270028e-7)+((cj16*x143))+(((-0.997494764195995)*pz*sj16))+((x139*x141))+(((0.0707403378672716)*x140))))))+((cj17*(((0.0800000013421189)+(((-1.0)*pz*x139))+(((-0.997494764195995)*x140))+(((-0.997494764195995)*x142))+(((0.0707403378672716)*x144)))))));
if( soleval[0] > 0.0000000000000000  )
{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(3);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j15;
vinfos[0].indices[0] = _ij15[0];
vinfos[0].indices[1] = _ij15[1];
vinfos[0].maxsolutions = _nj15;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j16;
vinfos[1].indices[0] = _ij16[0];
vinfos[1].indices[1] = _ij16[1];
vinfos[1].maxsolutions = _nj16;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j17;
vinfos[2].indices[0] = _ij17[0];
vinfos[2].indices[1] = _ij17[1];
vinfos[2].maxsolutions = _nj17;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x145=py*py;
IkReal x146=cj17*cj17;
evalcond[0]=((IKabs(px))+(IKabs(pz)));
evalcond[1]=((((0.0707403378672716)*cj17*py))+(((-0.997494764195995)*py*sj17)));
evalcond[2]=((((0.989991609196848)*x145*x146))+(((-0.994995804598424)*x145))+(((0.141126233280118)*cj17*sj17*x145)));
evalcond[3]=((-0.00567319268543858)*cj17);
evalcond[4]=((0.00640000021473902)+(((-0.00640000302581045)*x146)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
j16array[0]=0;
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];

IkReal soleval[1];
IkReal x147=((0.0707403378672716)*sj16);
IkReal x148=(cj16*pz);
IkReal x149=(((px*sj15))+(((-1.0)*cj15*py)));
IkReal x150=(sj16*x149);
IkReal x151=((0.997494764195995)*x149);
IkReal x152=(cj16*x149);
soleval[0]=(((cj17*(((0.0800000013421189)+(((0.0707403378672716)*x152))+(((-1.0)*pz*x147))+(((-0.997494764195995)*x150))+(((-0.997494764195995)*x148))))))+(((-1.0)*sj17*(((-2.47744983270028e-7)+((cj16*x151))+((x147*x149))+(((-0.997494764195995)*pz*sj16))+(((0.0707403378672716)*x148)))))));
if( soleval[0] > 0.0000000000000000  )
{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(3);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j15;
vinfos[0].indices[0] = _ij15[0];
vinfos[0].indices[1] = _ij15[1];
vinfos[0].maxsolutions = _nj15;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j16;
vinfos[1].indices[0] = _ij16[0];
vinfos[1].indices[1] = _ij16[1];
vinfos[1].maxsolutions = _nj16;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j17;
vinfos[2].indices[0] = _ij17[0];
vinfos[2].indices[1] = _ij17[1];
vinfos[2].maxsolutions = _nj17;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j16]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}

} else
{
{
IkReal j16array[2], cj16array[2], sj16array[2];
bool j16valid[2]={false};
_nj16 = 2;
IkReal x153=cj17*cj17;
IkReal x154=((1.00502936331837)*x153);
CheckValue<IkReal> x157 = IKatan2WithCheck(IkReal(((-1.00251152777331)*cj17*px)),((1.00251152777331)*cj17*pz),IKFAST_ATAN2_MAGTHRESH);
if(!x157.valid){
continue;
}
IkReal x155=((1.0)*(x157.value));
if(((((x154*(pz*pz)))+((x154*(px*px))))) < -0.00001)
continue;
CheckValue<IkReal> x158=IKPowWithIntegerCheck(IKabs(IKsqrt((((x154*(pz*pz)))+((x154*(px*px)))))),-1);
if(!x158.valid){
continue;
}
if( (((0.00567319268543858)*cj17*(x158.value))) < -1-IKFAST_SINCOS_THRESH || (((0.00567319268543858)*cj17*(x158.value))) > 1+IKFAST_SINCOS_THRESH )
    continue;
IkReal x156=IKasin(((0.00567319268543858)*cj17*(x158.value)));
j16array[0]=((((-1.0)*x155))+x156);
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
j16array[1]=((3.14159265358979)+(((-1.0)*x155))+(((-1.0)*x156)));
sj16array[1]=IKsin(j16array[1]);
cj16array[1]=IKcos(j16array[1]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
if( j16array[1] > IKPI )
{
    j16array[1]-=IK2PI;
}
else if( j16array[1] < -IKPI )
{    j16array[1]+=IK2PI;
}
j16valid[1] = true;
for(int ij16 = 0; ij16 < 2; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 2; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[1];
IkReal x159=IKcos(j16);
IkReal x160=cj17*cj17;
IkReal x161=IKsin(j16);
IkReal x162=pz*pz;
IkReal x163=px*px;
IkReal x164=(px*pz);
IkReal x165=x159*x159;
IkReal x166=((0.141836008381036)*x160);
IkReal x167=((0.989991609196848)*x165);
IkReal x168=(x159*x161);
IkReal x169=((0.141126233280118)*x168);
IkReal x170=(x160*x165);
IkReal x171=(x164*x168);
evalcond[0]=((0.00640000021473902)+(((-0.994995804598424)*x163))+(((2.0)*x162*x170))+(((-2.0)*x163*x170))+(((-0.283672016762073)*x164*x170))+(((-0.141126233280118)*x164))+((x164*x166))+(((-1.0)*x162*x167))+(((-1.0)*x162*x169))+(((-1.0)*x163*x166*x168))+(((-1.9799832183937)*x171))+(((-1.0)*x160*x162))+((x162*x166*x168))+(((0.282252466560236)*x164*x165))+((x160*x163))+(((4.0)*x160*x171))+((x163*x167))+((x163*x169))+(((-0.00500419540157573)*x162))+(((-0.00640000302581045)*x160)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

IkReal soleval[1];
IkReal x172=((0.0707403378672716)*sj16);
IkReal x173=(cj16*pz);
IkReal x174=(((px*sj15))+(((-1.0)*cj15*py)));
IkReal x175=(sj16*x174);
IkReal x176=((0.997494764195995)*x174);
IkReal x177=(cj16*x174);
soleval[0]=((((-1.0)*sj17*(((-2.47744983270028e-7)+(((0.0707403378672716)*x173))+((x172*x174))+((cj16*x176))+(((-0.997494764195995)*pz*sj16))))))+((cj17*(((0.0800000013421189)+(((0.0707403378672716)*x177))+(((-0.997494764195995)*x173))+(((-0.997494764195995)*x175))+(((-1.0)*pz*x172)))))));
if( soleval[0] > 0.0000000000000000  )
{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(3);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j15;
vinfos[0].indices[0] = _ij15[0];
vinfos[0].indices[1] = _ij15[1];
vinfos[0].maxsolutions = _nj15;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j16;
vinfos[1].indices[0] = _ij16[0];
vinfos[1].indices[1] = _ij16[1];
vinfos[1].maxsolutions = _nj16;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j17;
vinfos[2].indices[0] = _ij17[0];
vinfos[2].indices[1] = _ij17[1];
vinfos[2].maxsolutions = _nj17;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x178=py*py;
CheckValue<IkReal> x179=IKPowWithIntegerCheck(pz,-2);
if(!x179.valid){
continue;
}
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(cj15))+(IKabs(((1.0)+(IKsign(sj15)))))+(IKabs((x178*(x179.value))))), 6.28318530717959)));
evalcond[1]=((((-0.0707403378672716)*cj17*py))+(((0.997494764195995)*py*sj17)));
evalcond[2]=((((-0.994995804598424)*x178))+(((0.989991609196848)*x178*(cj17*cj17)))+(((0.141126233280118)*cj17*sj17*x178)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j16eval[4];
sj15=-1.0;
cj15=0;
j15=-1.57079633263667;
IkReal x180=pz*pz;
IkReal x181=cj17*cj17;
IkReal x182=px*px;
j16eval[0]=1.00502936331837;
j16eval[1]=cj17;
j16eval[2]=(x180+x182);
j16eval[3]=(((x180*x181))+((x181*x182)));
if( IKabs(j16eval[0]) < 0.0000010000000000  || IKabs(j16eval[1]) < 0.0000010000000000  || IKabs(j16eval[2]) < 0.0000010000000000  || IKabs(j16eval[3]) < 0.0000010000000000  )
{
{
IkReal evalcond[5];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j17)))), 6.28318530717959)));
evalcond[1]=((0.997494764195995)*py);
evalcond[2]=((-0.994995804598424)*(py*py));
evalcond[3]=0;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
j16array[0]=0;
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];

IkReal soleval[1];
IkReal x183=((0.0707403378672716)*sj16);
IkReal x184=(cj16*pz);
IkReal x185=(((px*sj15))+(((-1.0)*cj15*py)));
IkReal x186=(sj16*x185);
IkReal x187=((0.997494764195995)*x185);
IkReal x188=(cj16*x185);
soleval[0]=(((cj17*(((0.0800000013421189)+(((0.0707403378672716)*x188))+(((-0.997494764195995)*x184))+(((-0.997494764195995)*x186))+(((-1.0)*pz*x183))))))+(((-1.0)*sj17*(((-2.47744983270028e-7)+((cj16*x187))+(((0.0707403378672716)*x184))+((x183*x185))+(((-0.997494764195995)*pz*sj16)))))));
if( soleval[0] > 0.0000000000000000  )
{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(3);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j15;
vinfos[0].indices[0] = _ij15[0];
vinfos[0].indices[1] = _ij15[1];
vinfos[0].maxsolutions = _nj15;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j16;
vinfos[1].indices[0] = _ij16[0];
vinfos[1].indices[1] = _ij16[1];
vinfos[1].maxsolutions = _nj16;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j17;
vinfos[2].indices[0] = _ij17[0];
vinfos[2].indices[1] = _ij17[1];
vinfos[2].maxsolutions = _nj17;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j17)))), 6.28318530717959)));
evalcond[1]=((-0.997494764195995)*py);
evalcond[2]=((-0.994995804598424)*(py*py));
evalcond[3]=0;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
j16array[0]=0;
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];

IkReal soleval[1];
IkReal x189=((0.0707403378672716)*sj16);
IkReal x190=(cj16*pz);
IkReal x191=(((px*sj15))+(((-1.0)*cj15*py)));
IkReal x192=(sj16*x191);
IkReal x193=((0.997494764195995)*x191);
IkReal x194=(cj16*x191);
soleval[0]=((((-1.0)*sj17*(((-2.47744983270028e-7)+((cj16*x193))+(((0.0707403378672716)*x190))+((x189*x191))+(((-0.997494764195995)*pz*sj16))))))+((cj17*(((0.0800000013421189)+(((-0.997494764195995)*x192))+(((-0.997494764195995)*x190))+(((-1.0)*pz*x189))+(((0.0707403378672716)*x194)))))));
if( soleval[0] > 0.0000000000000000  )
{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(3);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j15;
vinfos[0].indices[0] = _ij15[0];
vinfos[0].indices[1] = _ij15[1];
vinfos[0].maxsolutions = _nj15;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j16;
vinfos[1].indices[0] = _ij16[0];
vinfos[1].indices[1] = _ij16[1];
vinfos[1].maxsolutions = _nj16;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j17;
vinfos[2].indices[0] = _ij17[0];
vinfos[2].indices[1] = _ij17[1];
vinfos[2].maxsolutions = _nj17;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x195=py*py;
IkReal x196=cj17*cj17;
evalcond[0]=((px*px)+(pz*pz));
evalcond[1]=((((-0.0707403378672716)*cj17*py))+(((0.997494764195995)*py*sj17)));
evalcond[2]=((((0.141126233280118)*cj17*sj17*x195))+(((-0.994995804598424)*x195))+(((0.989991609196848)*x195*x196)));
evalcond[3]=((-0.00567319268543858)*cj17);
evalcond[4]=((0.00640000021473902)+(((-0.00640000302581045)*x196)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
j16array[0]=0;
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];

IkReal soleval[1];
IkReal x197=((0.0707403378672716)*sj16);
IkReal x198=(cj16*pz);
IkReal x199=(((px*sj15))+(((-1.0)*cj15*py)));
IkReal x200=(sj16*x199);
IkReal x201=((0.997494764195995)*x199);
IkReal x202=(cj16*x199);
soleval[0]=((((-1.0)*sj17*(((-2.47744983270028e-7)+(((0.0707403378672716)*x198))+((cj16*x201))+((x197*x199))+(((-0.997494764195995)*pz*sj16))))))+((cj17*(((0.0800000013421189)+(((-0.997494764195995)*x200))+(((-0.997494764195995)*x198))+(((-1.0)*pz*x197))+(((0.0707403378672716)*x202)))))));
if( soleval[0] > 0.0000000000000000  )
{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(3);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j15;
vinfos[0].indices[0] = _ij15[0];
vinfos[0].indices[1] = _ij15[1];
vinfos[0].maxsolutions = _nj15;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j16;
vinfos[1].indices[0] = _ij16[0];
vinfos[1].indices[1] = _ij16[1];
vinfos[1].maxsolutions = _nj16;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j17;
vinfos[2].indices[0] = _ij17[0];
vinfos[2].indices[1] = _ij17[1];
vinfos[2].maxsolutions = _nj17;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x203=py*py;
IkReal x204=cj17*cj17;
evalcond[0]=((IKabs(px))+(IKabs(pz)));
evalcond[1]=((((-0.0707403378672716)*cj17*py))+(((0.997494764195995)*py*sj17)));
evalcond[2]=((((0.989991609196848)*x203*x204))+(((0.141126233280118)*cj17*sj17*x203))+(((-0.994995804598424)*x203)));
evalcond[3]=((-0.00567319268543858)*cj17);
evalcond[4]=((0.00640000021473902)+(((-0.00640000302581045)*x204)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
j16array[0]=0;
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];

IkReal soleval[1];
IkReal x205=((0.0707403378672716)*sj16);
IkReal x206=(cj16*pz);
IkReal x207=(((px*sj15))+(((-1.0)*cj15*py)));
IkReal x208=(sj16*x207);
IkReal x209=((0.997494764195995)*x207);
IkReal x210=(cj16*x207);
soleval[0]=((((-1.0)*sj17*(((-2.47744983270028e-7)+((x205*x207))+((cj16*x209))+(((0.0707403378672716)*x206))+(((-0.997494764195995)*pz*sj16))))))+((cj17*(((0.0800000013421189)+(((-0.997494764195995)*x206))+(((-0.997494764195995)*x208))+(((0.0707403378672716)*x210))+(((-1.0)*pz*x205)))))));
if( soleval[0] > 0.0000000000000000  )
{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(3);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j15;
vinfos[0].indices[0] = _ij15[0];
vinfos[0].indices[1] = _ij15[1];
vinfos[0].maxsolutions = _nj15;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j16;
vinfos[1].indices[0] = _ij16[0];
vinfos[1].indices[1] = _ij16[1];
vinfos[1].maxsolutions = _nj16;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j17;
vinfos[2].indices[0] = _ij17[0];
vinfos[2].indices[1] = _ij17[1];
vinfos[2].maxsolutions = _nj17;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j16]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}

} else
{
{
IkReal j16array[2], cj16array[2], sj16array[2];
bool j16valid[2]={false};
_nj16 = 2;
IkReal x211=cj17*cj17;
IkReal x212=((1.00251152777331)*cj17);
IkReal x213=((1.00502936331837)*x211);
CheckValue<IkReal> x216 = IKatan2WithCheck(IkReal((px*x212)),(pz*x212),IKFAST_ATAN2_MAGTHRESH);
if(!x216.valid){
continue;
}
IkReal x214=((1.0)*(x216.value));
if(((((x213*(px*px)))+((x213*(pz*pz))))) < -0.00001)
continue;
CheckValue<IkReal> x217=IKPowWithIntegerCheck(IKabs(IKsqrt((((x213*(px*px)))+((x213*(pz*pz)))))),-1);
if(!x217.valid){
continue;
}
if( (((0.00567319268543858)*cj17*(x217.value))) < -1-IKFAST_SINCOS_THRESH || (((0.00567319268543858)*cj17*(x217.value))) > 1+IKFAST_SINCOS_THRESH )
    continue;
IkReal x215=IKasin(((0.00567319268543858)*cj17*(x217.value)));
j16array[0]=(x215+(((-1.0)*x214)));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
j16array[1]=((3.14159265358979)+(((-1.0)*x215))+(((-1.0)*x214)));
sj16array[1]=IKsin(j16array[1]);
cj16array[1]=IKcos(j16array[1]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
if( j16array[1] > IKPI )
{
    j16array[1]-=IK2PI;
}
else if( j16array[1] < -IKPI )
{    j16array[1]+=IK2PI;
}
j16valid[1] = true;
for(int ij16 = 0; ij16 < 2; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 2; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[1];
IkReal x218=IKcos(j16);
IkReal x219=IKsin(j16);
IkReal x220=cj17*cj17;
IkReal x221=pz*pz;
IkReal x222=px*px;
IkReal x223=(px*pz);
IkReal x224=x218*x218;
IkReal x225=((0.141836008381036)*x220);
IkReal x226=((0.989991609196848)*x224);
IkReal x227=(x218*x219);
IkReal x228=(x220*x224);
evalcond[0]=((0.00640000021473902)+(((-1.0)*x220*x221))+(((-0.282252466560236)*x223*x224))+(((-1.0)*x222*x225*x227))+((x222*x226))+(((-0.994995804598424)*x222))+(((-0.141126233280118)*x221*x227))+(((0.283672016762073)*x223*x228))+((x220*x222))+(((-1.0)*x223*x225))+(((1.9799832183937)*x223*x227))+(((0.141126233280118)*x222*x227))+(((-0.00640000302581045)*x220))+(((-0.00500419540157573)*x221))+(((-4.0)*x220*x223*x227))+((x221*x225*x227))+(((2.0)*x221*x228))+(((0.141126233280118)*x223))+(((-1.0)*x221*x226))+(((-2.0)*x222*x228)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

IkReal soleval[1];
IkReal x229=((0.0707403378672716)*sj16);
IkReal x230=(cj16*pz);
IkReal x231=(((px*sj15))+(((-1.0)*cj15*py)));
IkReal x232=(sj16*x231);
IkReal x233=((0.997494764195995)*x231);
IkReal x234=(cj16*x231);
soleval[0]=((((-1.0)*sj17*(((-2.47744983270028e-7)+((x229*x231))+((cj16*x233))+(((-0.997494764195995)*pz*sj16))+(((0.0707403378672716)*x230))))))+((cj17*(((0.0800000013421189)+(((-1.0)*pz*x229))+(((0.0707403378672716)*x234))+(((-0.997494764195995)*x232))+(((-0.997494764195995)*x230)))))));
if( soleval[0] > 0.0000000000000000  )
{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(3);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j15;
vinfos[0].indices[0] = _ij15[0];
vinfos[0].indices[1] = _ij15[1];
vinfos[0].maxsolutions = _nj15;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j16;
vinfos[1].indices[0] = _ij16[0];
vinfos[1].indices[1] = _ij16[1];
vinfos[1].maxsolutions = _nj16;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j17;
vinfos[2].indices[0] = _ij17[0];
vinfos[2].indices[1] = _ij17[1];
vinfos[2].maxsolutions = _nj17;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x235=cj15*cj15;
IkReal x236=px*px;
IkReal x237=cj17*cj17;
IkReal x238=(cj15*cj17);
IkReal x239=(cj15*sj17);
IkReal x240=(cj17*sj17);
IkReal x241=(x235*x236);
evalcond[0]=((IKabs(py))+(IKabs(pz)));
evalcond[1]=((((-0.997494764195995)*px*x239))+(((0.0707403378672716)*px*x238)));
evalcond[2]=((((2.47744983270028e-7)*x238))+(((-0.0800000013421189)*x239)));
evalcond[3]=((((-0.994995804598424)*x241))+(((0.989991609196848)*x237*x241))+(((0.141126233280118)*x240*x241)));
evalcond[4]=((((0.00640000021473902)*x235))+(((-0.00640000021467764)*x235*x237))+(((-3.96391979882109e-8)*x235*x240)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
j16array[0]=0;
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];

IkReal soleval[1];
IkReal x242=((0.0707403378672716)*sj16);
IkReal x243=(cj16*pz);
IkReal x244=(((px*sj15))+(((-1.0)*cj15*py)));
IkReal x245=(sj16*x244);
IkReal x246=((0.997494764195995)*x244);
IkReal x247=(cj16*x244);
soleval[0]=((((-1.0)*sj17*(((-2.47744983270028e-7)+(((0.0707403378672716)*x243))+((cj16*x246))+((x242*x244))+(((-0.997494764195995)*pz*sj16))))))+((cj17*(((0.0800000013421189)+(((-1.0)*pz*x242))+(((0.0707403378672716)*x247))+(((-0.997494764195995)*x243))+(((-0.997494764195995)*x245)))))));
if( soleval[0] > 0.0000000000000000  )
{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(3);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j15;
vinfos[0].indices[0] = _ij15[0];
vinfos[0].indices[1] = _ij15[1];
vinfos[0].maxsolutions = _nj15;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j16;
vinfos[1].indices[0] = _ij16[0];
vinfos[1].indices[1] = _ij16[1];
vinfos[1].maxsolutions = _nj16;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j17;
vinfos[2].indices[0] = _ij17[0];
vinfos[2].indices[1] = _ij17[1];
vinfos[2].maxsolutions = _nj17;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(py))+(IKabs(((-3.14159265358979)+(IKfmod(((1.5707963267949)+j15), 6.28318530717959))))));
evalcond[1]=0;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j16eval[1];
py=0;
j15=1.5707963267949;
sj15=1.0;
cj15=0;
pp=((px*px)+(pz*pz));
IkReal x248=sj17*sj17;
IkReal x249=pz*pz;
IkReal x250=cj17*cj17;
IkReal x251=px*px;
j16eval[0]=(((x248*x251))+((x249*x250))+((x248*x249))+((x250*x251)));
if( IKabs(j16eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[4];
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(px))+(IKabs(pz)));
evalcond[1]=0;
evalcond[2]=((((2.47744983270028e-7)*cj17))+(((-0.0800000013421189)*sj17)));
evalcond[3]=((0.00640000021473902)+(((-0.00640000021467764)*(cj17*cj17)))+(((-3.96391979882109e-8)*cj17*sj17)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
j16array[0]=0;
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];

IkReal soleval[1];
IkReal x252=((0.0707403378672716)*sj16);
IkReal x253=(cj16*pz);
IkReal x254=(((px*sj15))+(((-1.0)*cj15*py)));
IkReal x255=(sj16*x254);
IkReal x256=((0.997494764195995)*x254);
IkReal x257=(cj16*x254);
soleval[0]=((((-1.0)*sj17*(((-2.47744983270028e-7)+((cj16*x256))+(((0.0707403378672716)*x253))+((x252*x254))+(((-0.997494764195995)*pz*sj16))))))+((cj17*(((0.0800000013421189)+(((0.0707403378672716)*x257))+(((-0.997494764195995)*x255))+(((-0.997494764195995)*x253))+(((-1.0)*pz*x252)))))));
if( soleval[0] > 0.0000000000000000  )
{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(3);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j15;
vinfos[0].indices[0] = _ij15[0];
vinfos[0].indices[1] = _ij15[1];
vinfos[0].maxsolutions = _nj15;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j16;
vinfos[1].indices[0] = _ij16[0];
vinfos[1].indices[1] = _ij16[1];
vinfos[1].maxsolutions = _nj16;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j17;
vinfos[2].indices[0] = _ij17[0];
vinfos[2].indices[1] = _ij17[1];
vinfos[2].maxsolutions = _nj17;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j16]

}
} while(0);
if( bgotonextstatement )
{
}
}
}

} else
{
{
IkReal j16array[2], cj16array[2], sj16array[2];
bool j16valid[2]={false};
_nj16 = 2;
IkReal x258=((0.0707403378672716)*cj17);
IkReal x259=(px*sj17);
IkReal x260=((0.997494764195995)*cj17);
IkReal x261=(pz*sj17);
IkReal x262=((((-0.0707403378672716)*x259))+(((-1.0)*pz*x258))+(((-1.0)*px*x260))+(((0.997494764195995)*x261)));
IkReal x263=((((0.0707403378672716)*x261))+(((0.997494764195995)*x259))+((pz*x260))+(((-1.0)*px*x258)));
CheckValue<IkReal> x266 = IKatan2WithCheck(IkReal(x262),x263,IKFAST_ATAN2_MAGTHRESH);
if(!x266.valid){
continue;
}
IkReal x264=((1.0)*(x266.value));
if((((x263*x263)+(x262*x262))) < -0.00001)
continue;
CheckValue<IkReal> x267=IKPowWithIntegerCheck(IKabs(IKsqrt(((x263*x263)+(x262*x262)))),-1);
if(!x267.valid){
continue;
}
if( (((x267.value)*(((((2.47744983270028e-7)*cj17))+(((-0.0800000013421189)*sj17)))))) < -1-IKFAST_SINCOS_THRESH || (((x267.value)*(((((2.47744983270028e-7)*cj17))+(((-0.0800000013421189)*sj17)))))) > 1+IKFAST_SINCOS_THRESH )
    continue;
IkReal x265=IKasin(((x267.value)*(((((2.47744983270028e-7)*cj17))+(((-0.0800000013421189)*sj17))))));
j16array[0]=((((-1.0)*x265))+(((-1.0)*x264)));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
j16array[1]=((3.14159265358979)+x265+(((-1.0)*x264)));
sj16array[1]=IKsin(j16array[1]);
cj16array[1]=IKcos(j16array[1]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
if( j16array[1] > IKPI )
{
    j16array[1]-=IK2PI;
}
else if( j16array[1] < -IKPI )
{    j16array[1]+=IK2PI;
}
j16valid[1] = true;
for(int ij16 = 0; ij16 < 2; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 2; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[1];
IkReal x268=px*px;
IkReal x269=IKcos(j16);
IkReal x270=IKsin(j16);
IkReal x271=cj17*cj17;
IkReal x272=pz*pz;
IkReal x273=(px*pz);
IkReal x274=(cj17*sj17);
IkReal x275=x269*x269;
IkReal x276=((0.141126233280118)*x274);
IkReal x277=((1.9799832183937)*x274);
IkReal x278=(x271*x272);
IkReal x279=(x269*x270);
IkReal x280=((1.9799832183937)*x275);
IkReal x281=(x268*x271);
IkReal x282=((0.282252466560236)*x275);
IkReal x283=((0.989991609196848)*x275);
evalcond[0]=((0.00640000021473902)+((x268*x283))+(((-3.96391979882109e-8)*x274))+(((-0.00500419540157573)*x272))+(((-1.0)*x272*x276))+(((-1.0)*x273*x277))+(((0.141126233280118)*x268*x279))+(((0.989991609196848)*x281))+((x272*x274*x282))+(((-1.0)*x272*x277*x279))+((x278*x280))+(((-0.994995804598424)*x268))+(((0.282252466560236)*x278*x279))+(((-0.282252466560236)*x279*x281))+((x268*x277*x279))+(((0.564504933120473)*x273*x274*x279))+(((0.282252466560236)*x271*x273))+(((-1.0)*x280*x281))+(((3.95996643678739)*x273*x274*x275))+(((-1.0)*x268*x274*x282))+((x273*x282))+(((-0.564504933120473)*x271*x273*x275))+(((-1.9799832183937)*x273*x279))+(((-0.00640000021467764)*x271))+(((3.95996643678739)*x271*x273*x279))+(((-0.141126233280118)*x272*x279))+(((-1.0)*x272*x283))+(((-0.989991609196848)*x278))+(((-0.141126233280118)*x273))+((x268*x276)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

IkReal soleval[1];
IkReal x284=((0.0707403378672716)*sj16);
IkReal x285=(cj16*pz);
IkReal x286=(((px*sj15))+(((-1.0)*cj15*py)));
IkReal x287=(sj16*x286);
IkReal x288=((0.997494764195995)*x286);
IkReal x289=(cj16*x286);
soleval[0]=((((-1.0)*sj17*(((-2.47744983270028e-7)+((x284*x286))+(((0.0707403378672716)*x285))+((cj16*x288))+(((-0.997494764195995)*pz*sj16))))))+((cj17*(((0.0800000013421189)+(((0.0707403378672716)*x289))+(((-0.997494764195995)*x287))+(((-0.997494764195995)*x285))+(((-1.0)*pz*x284)))))));
if( soleval[0] > 0.0000000000000000  )
{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(3);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j15;
vinfos[0].indices[0] = _ij15[0];
vinfos[0].indices[1] = _ij15[1];
vinfos[0].maxsolutions = _nj15;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j16;
vinfos[1].indices[0] = _ij16[0];
vinfos[1].indices[1] = _ij16[1];
vinfos[1].maxsolutions = _nj16;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j17;
vinfos[2].indices[0] = _ij17[0];
vinfos[2].indices[1] = _ij17[1];
vinfos[2].maxsolutions = _nj17;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(py))+(IKabs(((-3.14159265358979)+(IKfmod(((4.71238898038469)+j15), 6.28318530717959))))));
evalcond[1]=0;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j16eval[1];
py=0;
j15=-1.5707963267949;
sj15=-1.0;
cj15=0;
pp=((px*px)+(pz*pz));
IkReal x290=sj17*sj17;
IkReal x291=pz*pz;
IkReal x292=cj17*cj17;
IkReal x293=px*px;
j16eval[0]=(((x291*x292))+((x290*x291))+((x290*x293))+((x292*x293)));
if( IKabs(j16eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[4];
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(px))+(IKabs(pz)));
evalcond[1]=0;
evalcond[2]=((((2.47744983270028e-7)*cj17))+(((-0.0800000013421189)*sj17)));
evalcond[3]=((0.00640000021473902)+(((-0.00640000021467764)*(cj17*cj17)))+(((-3.96391979882109e-8)*cj17*sj17)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
j16array[0]=0;
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];

IkReal soleval[1];
IkReal x294=((0.0707403378672716)*sj16);
IkReal x295=(cj16*pz);
IkReal x296=(((px*sj15))+(((-1.0)*cj15*py)));
IkReal x297=(sj16*x296);
IkReal x298=((0.997494764195995)*x296);
IkReal x299=(cj16*x296);
soleval[0]=((((-1.0)*sj17*(((-2.47744983270028e-7)+(((0.0707403378672716)*x295))+((x294*x296))+((cj16*x298))+(((-0.997494764195995)*pz*sj16))))))+((cj17*(((0.0800000013421189)+(((-1.0)*pz*x294))+(((-0.997494764195995)*x295))+(((-0.997494764195995)*x297))+(((0.0707403378672716)*x299)))))));
if( soleval[0] > 0.0000000000000000  )
{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(3);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j15;
vinfos[0].indices[0] = _ij15[0];
vinfos[0].indices[1] = _ij15[1];
vinfos[0].maxsolutions = _nj15;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j16;
vinfos[1].indices[0] = _ij16[0];
vinfos[1].indices[1] = _ij16[1];
vinfos[1].maxsolutions = _nj16;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j17;
vinfos[2].indices[0] = _ij17[0];
vinfos[2].indices[1] = _ij17[1];
vinfos[2].maxsolutions = _nj17;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j16]

}
} while(0);
if( bgotonextstatement )
{
}
}
}

} else
{
{
IkReal j16array[2], cj16array[2], sj16array[2];
bool j16valid[2]={false};
_nj16 = 2;
IkReal x300=((0.0707403378672716)*cj17);
IkReal x301=(px*sj17);
IkReal x302=((0.997494764195995)*cj17);
IkReal x303=(pz*sj17);
IkReal x304=(((px*x302))+(((0.0707403378672716)*x301))+(((-1.0)*pz*x300))+(((0.997494764195995)*x303)));
IkReal x305=(((px*x300))+(((0.0707403378672716)*x303))+(((-0.997494764195995)*x301))+((pz*x302)));
CheckValue<IkReal> x308 = IKatan2WithCheck(IkReal(x304),x305,IKFAST_ATAN2_MAGTHRESH);
if(!x308.valid){
continue;
}
IkReal x306=((1.0)*(x308.value));
if((((x305*x305)+(x304*x304))) < -0.00001)
continue;
CheckValue<IkReal> x309=IKPowWithIntegerCheck(IKabs(IKsqrt(((x305*x305)+(x304*x304)))),-1);
if(!x309.valid){
continue;
}
if( (((x309.value)*(((((2.47744983270028e-7)*cj17))+(((-0.0800000013421189)*sj17)))))) < -1-IKFAST_SINCOS_THRESH || (((x309.value)*(((((2.47744983270028e-7)*cj17))+(((-0.0800000013421189)*sj17)))))) > 1+IKFAST_SINCOS_THRESH )
    continue;
IkReal x307=IKasin(((x309.value)*(((((2.47744983270028e-7)*cj17))+(((-0.0800000013421189)*sj17))))));
j16array[0]=((((-1.0)*x307))+(((-1.0)*x306)));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
j16array[1]=((3.14159265358979)+x307+(((-1.0)*x306)));
sj16array[1]=IKsin(j16array[1]);
cj16array[1]=IKcos(j16array[1]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
if( j16array[1] > IKPI )
{
    j16array[1]-=IK2PI;
}
else if( j16array[1] < -IKPI )
{    j16array[1]+=IK2PI;
}
j16valid[1] = true;
for(int ij16 = 0; ij16 < 2; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 2; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[1];
IkReal x310=px*px;
IkReal x311=cj17*cj17;
IkReal x312=IKcos(j16);
IkReal x313=IKsin(j16);
IkReal x314=pz*pz;
IkReal x315=(px*pz);
IkReal x316=(cj17*sj17);
IkReal x317=x312*x312;
IkReal x318=((0.141126233280118)*x310);
IkReal x319=((0.141126233280118)*x314);
IkReal x320=(x311*x314);
IkReal x321=((1.9799832183937)*x317);
IkReal x322=(x310*x311);
IkReal x323=((0.282252466560236)*x317);
IkReal x324=((0.989991609196848)*x317);
IkReal x325=(x312*x313);
IkReal x326=((1.9799832183937)*x325);
evalcond[0]=((0.00640000021473902)+((x318*x325))+(((-0.00500419540157573)*x314))+(((0.282252466560236)*x320*x325))+(((-0.282252466560236)*x311*x315))+(((-3.96391979882109e-8)*x316))+(((1.9799832183937)*x315*x316))+(((-3.95996643678739)*x315*x316*x317))+(((-1.0)*x314*x324))+(((-1.0)*x321*x322))+((x310*x324))+((x320*x321))+(((-0.994995804598424)*x310))+(((-1.0)*x314*x316*x326))+(((-1.0)*x310*x316*x323))+(((-1.0)*x315*x323))+((x310*x316*x326))+(((0.564504933120473)*x311*x315*x317))+(((0.141126233280118)*x315))+((x314*x316*x323))+(((-1.0)*x319*x325))+(((0.989991609196848)*x322))+((x315*x326))+(((-0.00640000021467764)*x311))+(((-0.564504933120473)*x315*x316*x325))+(((-0.282252466560236)*x322*x325))+(((-0.989991609196848)*x320))+((x316*x318))+(((-3.95996643678739)*x311*x315*x325))+(((-1.0)*x316*x319)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

IkReal soleval[1];
IkReal x327=((0.0707403378672716)*sj16);
IkReal x328=(cj16*pz);
IkReal x329=(((px*sj15))+(((-1.0)*cj15*py)));
IkReal x330=(sj16*x329);
IkReal x331=((0.997494764195995)*x329);
IkReal x332=(cj16*x329);
soleval[0]=((((-1.0)*sj17*(((-2.47744983270028e-7)+((x327*x329))+((cj16*x331))+(((0.0707403378672716)*x328))+(((-0.997494764195995)*pz*sj16))))))+((cj17*(((0.0800000013421189)+(((-0.997494764195995)*x328))+(((0.0707403378672716)*x332))+(((-1.0)*pz*x327))+(((-0.997494764195995)*x330)))))));
if( soleval[0] > 0.0000000000000000  )
{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(3);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j15;
vinfos[0].indices[0] = _ij15[0];
vinfos[0].indices[1] = _ij15[1];
vinfos[0].maxsolutions = _nj15;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j16;
vinfos[1].indices[0] = _ij16[0];
vinfos[1].indices[1] = _ij16[1];
vinfos[1].maxsolutions = _nj16;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j17;
vinfos[2].indices[0] = _ij17[0];
vinfos[2].indices[1] = _ij17[1];
vinfos[2].maxsolutions = _nj17;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j16]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}

} else
{
{
IkReal j16array[2], cj16array[2], sj16array[2];
bool j16valid[2]={false};
_nj16 = 2;
IkReal x333=((0.0707403378672716)*cj17);
IkReal x334=(px*sj15);
IkReal x335=((0.997494764195995)*sj17);
IkReal x336=(cj15*py);
IkReal x337=((0.997494764195995)*cj17);
IkReal x338=((0.0707403378672716)*sj17);
IkReal x339=(((x336*x338))+((x336*x337))+(((-1.0)*pz*x333))+((pz*x335))+(((-1.0)*x334*x338))+(((-1.0)*x334*x337)));
IkReal x340=(((x334*x335))+(((-1.0)*x333*x334))+((x333*x336))+((pz*x337))+((pz*x338))+(((-1.0)*x335*x336)));
CheckValue<IkReal> x343 = IKatan2WithCheck(IkReal(x339),x340,IKFAST_ATAN2_MAGTHRESH);
if(!x343.valid){
continue;
}
IkReal x341=((1.0)*(x343.value));
if((((x339*x339)+(x340*x340))) < -0.00001)
continue;
CheckValue<IkReal> x344=IKPowWithIntegerCheck(IKabs(IKsqrt(((x339*x339)+(x340*x340)))),-1);
if(!x344.valid){
continue;
}
if( (((x344.value)*(((((2.47744983270028e-7)*cj17))+(((-0.0800000013421189)*sj17)))))) < -1-IKFAST_SINCOS_THRESH || (((x344.value)*(((((2.47744983270028e-7)*cj17))+(((-0.0800000013421189)*sj17)))))) > 1+IKFAST_SINCOS_THRESH )
    continue;
IkReal x342=IKasin(((x344.value)*(((((2.47744983270028e-7)*cj17))+(((-0.0800000013421189)*sj17))))));
j16array[0]=((((-1.0)*x341))+(((-1.0)*x342)));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
j16array[1]=((3.14159265358979)+x342+(((-1.0)*x341)));
sj16array[1]=IKsin(j16array[1]);
cj16array[1]=IKcos(j16array[1]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
if( j16array[1] > IKPI )
{
    j16array[1]-=IK2PI;
}
else if( j16array[1] < -IKPI )
{    j16array[1]+=IK2PI;
}
j16valid[1] = true;
for(int ij16 = 0; ij16 < 2; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 2; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[3];
IkReal x345=IKsin(j16);
IkReal x346=IKcos(j16);
IkReal x347=cj15*cj15;
IkReal x348=pz*pz;
IkReal x349=cj17*cj17;
IkReal x350=py*py;
IkReal x351=(py*sj17);
IkReal x352=(cj15*sj17);
IkReal x353=((0.282252466560236)*sj17);
IkReal x354=(cj15*pz);
IkReal x355=(cj17*sj17);
IkReal x356=x346*x346;
IkReal x357=((0.141126233280118)*x355);
IkReal x358=((0.997494764195995)*x345);
IkReal x359=(cj17*x354);
IkReal x360=((0.0707403378672716)*x346);
IkReal x361=(py*x346);
IkReal x362=((1.9799832183937)*x345);
IkReal x363=((0.0707403378672716)*x345);
IkReal x364=((0.989991609196848)*x349);
IkReal x365=((0.282252466560236)*x349);
IkReal x366=(x347*x348);
IkReal x367=(cj17*x356);
IkReal x368=(x345*x346);
IkReal x369=(x350*x356);
IkReal x370=(x349*x356);
evalcond[0]=(((cj17*py*x363))+(((2.47744983270028e-7)*cj15*cj17))+(((0.997494764195995)*pz*x346*x352))+((pz*x352*x363))+(((-0.0800000013421189)*x352))+(((0.997494764195995)*cj17*x361))+(((-1.0)*x359*x360))+((x358*x359))+(((-1.0)*x351*x358))+((x351*x360)));
evalcond[1]=((((-0.141126233280118)*x366*x368))+(((0.141126233280118)*py*x354))+(((-1.0)*x346*x355*x362*x366))+(((-1.0)*x350*x353*x367))+(((-1.0)*py*x354*x365))+(((-0.00640000021467764)*x347*x349))+((x350*x364))+((x354*x361*x362))+(((-1.9799832183937)*x349*x369))+(((0.564504933120473)*py*x354*x370))+(((1.9799832183937)*x351*x359))+((x365*x366*x368))+((x353*x366*x367))+(((1.9799832183937)*x366*x370))+(((-0.989991609196848)*x356*x366))+(((-0.282252466560236)*py*x354*x356))+(((0.141126233280118)*x350*x368))+(((0.00640000021473902)*x347))+((x346*x350*x355*x362))+(((0.989991609196848)*x369))+((x350*x357))+(((-1.0)*x364*x366))+(((-1.0)*x357*x366))+(((-0.564504933120473)*x351*x359*x368))+(((-3.95996643678739)*x351*x356*x359))+(((-0.00500419540157573)*x366))+(((-1.0)*x350*x365*x368))+(((-3.95996643678739)*x345*x349*x354*x361))+(((-3.96391979882109e-8)*x347*x355))+(((-0.994995804598424)*x350)));
IkReal x371=IKcos(j16);
IkReal x372=IKcos(j16);
IkReal x373=IKcos(j16);
IkReal x374=IKcos(j16);
IkReal x375=IKcos(j16);
IkReal x376=IKcos(j16);
IkReal x377=IKcos(j16);
IkReal x378=IKcos(j16);
IkReal x379=IKcos(j16);
IkReal x380=IKcos(j16);
IkReal x381=IKcos(j16);
IkReal x382=IKcos(j16);
IkReal x383=IKcos(j16);
IkReal x384=IKcos(j16);
IkReal x385=IKcos(j16);
IkReal x386=IKcos(j16);
IkReal x387=IKcos(j16);
IkReal x388=IKcos(j16);
IkReal x389=IKcos(j16);
IkReal x390=IKcos(j16);
IkReal x391=IKcos(j16);
evalcond[2]=((0.00640000021473902)+(((-0.989991609196848)*(cj15*cj15)*(px*px)*(x371*x371)))+(((0.989991609196848)*(px*px)*(x372*x372)))+(((-0.564504933120473)*cj15*cj17*py*pz*sj17*(IKcos(j16))*(IKsin(j16))))+(((0.141126233280118)*cj15*py*pz))+(((-1.9799832183937)*cj15*px*py*sj15*(cj17*cj17)))+(((-0.282252466560236)*cj15*py*pz*(x373*x373)))+(((-1.9799832183937)*(cj17*cj17)*(px*px)*(x374*x374)))+(((-0.994995804598424)*(px*px)))+(((0.989991609196848)*(cj17*cj17)*(px*px)))+(((0.989991609196848)*(cj15*cj15)*(cj17*cj17)*(py*py)))+(((-0.141126233280118)*(pz*pz)*(IKcos(j16))*(IKsin(j16))))+(((-0.00640000021467764)*(cj17*cj17)))+(((1.9799832183937)*(cj15*cj15)*(cj17*cj17)*(px*px)*(x375*x375)))+(((0.282252466560236)*px*pz*sj15*(x376*x376)))+(((0.564504933120473)*cj15*cj17*px*py*sj15*sj17*(x377*x377)))+(((0.994995804598424)*(cj15*cj15)*(px*px)))+(((-3.95996643678739)*cj15*cj17*px*py*sj15*sj17*(IKcos(j16))*(IKsin(j16))))+(((1.9799832183937)*cj17*sj17*(px*px)*(IKcos(j16))*(IKsin(j16))))+(((-0.141126233280118)*cj17*sj17*(cj15*cj15)*(px*px)))+(((0.564504933120473)*cj17*px*pz*sj15*sj17*(IKcos(j16))*(IKsin(j16))))+(((0.282252466560236)*(cj17*cj17)*(pz*pz)*(IKcos(j16))*(IKsin(j16))))+(((3.95996643678739)*cj15*px*py*sj15*(cj17*cj17)*(x378*x378)))+(((-0.282252466560236)*cj15*py*pz*(cj17*cj17)))+(((-1.9799832183937)*cj17*sj17*(pz*pz)*(IKcos(j16))*(IKsin(j16))))+(((0.564504933120473)*cj15*px*py*sj15*(cj17*cj17)*(IKcos(j16))*(IKsin(j16))))+(((3.95996643678739)*cj17*px*pz*sj15*sj17*(x379*x379)))+(((-0.989991609196848)*(cj15*cj15)*(cj17*cj17)*(px*px)))+(((0.141126233280118)*cj17*sj17*(cj15*cj15)*(py*py)))+(((0.282252466560236)*px*pz*sj15*(cj17*cj17)))+(((-1.9799832183937)*cj17*sj17*(cj15*cj15)*(px*px)*(IKcos(j16))*(IKsin(j16))))+(((-0.282252466560236)*(cj17*cj17)*(px*px)*(IKcos(j16))*(IKsin(j16))))+(((-0.282252466560236)*cj15*cj17*px*py*sj15*sj17))+(((-0.564504933120473)*px*pz*sj15*(cj17*cj17)*(x380*x380)))+(((-0.00500419540157573)*(pz*pz)))+(((-1.9799832183937)*cj15*px*py*sj15*(x381*x381)))+(((0.564504933120473)*cj15*py*pz*(cj17*cj17)*(x382*x382)))+(((1.9799832183937)*cj15*cj17*py*pz*sj17))+(((3.95996643678739)*px*pz*sj15*(cj17*cj17)*(IKcos(j16))*(IKsin(j16))))+(((-3.95996643678739)*cj15*py*pz*(cj17*cj17)*(IKcos(j16))*(IKsin(j16))))+(((1.9799832183937)*cj15*py*pz*(IKcos(j16))*(IKsin(j16))))+(((-0.989991609196848)*(cj17*cj17)*(pz*pz)))+(((0.282252466560236)*cj17*sj17*(cj15*cj15)*(px*px)*(x383*x383)))+(((-0.141126233280118)*cj17*sj17*(pz*pz)))+(((0.282252466560236)*(cj15*cj15)*(cj17*cj17)*(px*px)*(IKcos(j16))*(IKsin(j16))))+(((-0.141126233280118)*px*pz*sj15))+(((-3.95996643678739)*cj15*cj17*py*pz*sj17*(x384*x384)))+(((-1.9799832183937)*(cj15*cj15)*(cj17*cj17)*(py*py)*(x385*x385)))+(((-0.994995804598424)*(cj15*cj15)*(py*py)))+(((-0.141126233280118)*(cj15*cj15)*(px*px)*(IKcos(j16))*(IKsin(j16))))+(((-0.282252466560236)*cj17*sj17*(cj15*cj15)*(py*py)*(x386*x386)))+(((-0.282252466560236)*cj17*sj17*(px*px)*(x387*x387)))+(((1.98999160919685)*cj15*px*py*sj15))+(((-1.9799832183937)*cj17*px*pz*sj15*sj17))+(((-1.9799832183937)*px*pz*sj15*(IKcos(j16))*(IKsin(j16))))+(((1.9799832183937)*(cj17*cj17)*(pz*pz)*(x388*x388)))+(((0.141126233280118)*(cj15*cj15)*(py*py)*(IKcos(j16))*(IKsin(j16))))+(((1.9799832183937)*cj17*sj17*(cj15*cj15)*(py*py)*(IKcos(j16))*(IKsin(j16))))+(((-0.989991609196848)*(pz*pz)*(x389*x389)))+(((-0.282252466560236)*cj15*px*py*sj15*(IKcos(j16))*(IKsin(j16))))+(((0.141126233280118)*cj17*sj17*(px*px)))+(((-0.282252466560236)*(cj15*cj15)*(cj17*cj17)*(py*py)*(IKcos(j16))*(IKsin(j16))))+(((-3.96391979882109e-8)*cj17*sj17))+(((0.141126233280118)*(px*px)*(IKcos(j16))*(IKsin(j16))))+(((0.989991609196848)*(cj15*cj15)*(py*py)*(x390*x390)))+(((0.282252466560236)*cj17*sj17*(pz*pz)*(x391*x391))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

IkReal soleval[1];
IkReal x392=((0.0707403378672716)*sj16);
IkReal x393=(cj16*pz);
IkReal x394=(((px*sj15))+(((-1.0)*cj15*py)));
IkReal x395=(sj16*x394);
IkReal x396=((0.997494764195995)*x394);
IkReal x397=(cj16*x394);
soleval[0]=(((cj17*(((0.0800000013421189)+(((-0.997494764195995)*x395))+(((-0.997494764195995)*x393))+(((-1.0)*pz*x392))+(((0.0707403378672716)*x397))))))+(((-1.0)*sj17*(((-2.47744983270028e-7)+((cj16*x396))+(((0.0707403378672716)*x393))+(((-0.997494764195995)*pz*sj16))+((x392*x394)))))));
if( soleval[0] > 0.0000000000000000  )
{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(3);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j15;
vinfos[0].indices[0] = _ij15[0];
vinfos[0].indices[1] = _ij15[1];
vinfos[0].maxsolutions = _nj15;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j16;
vinfos[1].indices[0] = _ij16[0];
vinfos[1].indices[1] = _ij16[1];
vinfos[1].maxsolutions = _nj16;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j17;
vinfos[2].indices[0] = _ij17[0];
vinfos[2].indices[1] = _ij17[1];
vinfos[2].maxsolutions = _nj17;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j16array[2], cj16array[2], sj16array[2];
bool j16valid[2]={false};
_nj16 = 2;
IkReal x398=((0.0707403378672716)*py);
IkReal x399=((0.997494764195995)*py);
IkReal x400=(cj15*cj17);
IkReal x401=((0.0707403378672716)*pz);
IkReal x402=(cj15*sj17);
IkReal x403=((0.997494764195995)*cj15*pz);
IkReal x404=(((sj17*x398))+((cj17*x399))+(((-1.0)*x400*x401))+(((0.997494764195995)*pz*x402)));
IkReal x405=(((cj17*x398))+(((-1.0)*sj17*x399))+(((0.997494764195995)*pz*x400))+((x401*x402)));
CheckValue<IkReal> x408 = IKatan2WithCheck(IkReal(x404),x405,IKFAST_ATAN2_MAGTHRESH);
if(!x408.valid){
continue;
}
IkReal x406=((1.0)*(x408.value));
if((((x404*x404)+(x405*x405))) < -0.00001)
continue;
CheckValue<IkReal> x409=IKPowWithIntegerCheck(IKabs(IKsqrt(((x404*x404)+(x405*x405)))),-1);
if(!x409.valid){
continue;
}
if( (((x409.value)*(((((2.47744983270028e-7)*x400))+(((-0.0800000013421189)*x402)))))) < -1-IKFAST_SINCOS_THRESH || (((x409.value)*(((((2.47744983270028e-7)*x400))+(((-0.0800000013421189)*x402)))))) > 1+IKFAST_SINCOS_THRESH )
    continue;
IkReal x407=IKasin(((x409.value)*(((((2.47744983270028e-7)*x400))+(((-0.0800000013421189)*x402))))));
j16array[0]=((((-1.0)*x407))+(((-1.0)*x406)));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
j16array[1]=((3.14159265358979)+x407+(((-1.0)*x406)));
sj16array[1]=IKsin(j16array[1]);
cj16array[1]=IKcos(j16array[1]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
if( j16array[1] > IKPI )
{
    j16array[1]-=IK2PI;
}
else if( j16array[1] < -IKPI )
{    j16array[1]+=IK2PI;
}
j16valid[1] = true;
for(int ij16 = 0; ij16 < 2; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 2; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[3];
IkReal x410=IKsin(j16);
IkReal x411=IKcos(j16);
IkReal x412=cj15*cj15;
IkReal x413=pz*pz;
IkReal x414=cj17*cj17;
IkReal x415=py*py;
IkReal x416=((0.282252466560236)*sj17);
IkReal x417=((0.997494764195995)*pz);
IkReal x418=(cj17*pz);
IkReal x419=((3.95996643678739)*pz);
IkReal x420=(px*sj15);
IkReal x421=(cj15*py);
IkReal x422=x411*x411;
IkReal x423=((0.141126233280118)*cj17*sj17);
IkReal x424=(cj17*x410);
IkReal x425=((0.0707403378672716)*x420);
IkReal x426=(sj17*x421);
IkReal x427=((0.997494764195995)*x410);
IkReal x428=((0.0707403378672716)*x411);
IkReal x429=(sj17*x411);
IkReal x430=(pz*x421);
IkReal x431=((0.282252466560236)*x414);
IkReal x432=(x412*x413);
IkReal x433=(x414*x415);
IkReal x434=(cj17*x422);
IkReal x435=(x410*x411);
IkReal x436=((0.989991609196848)*x422);
IkReal x437=((0.997494764195995)*cj17*x411);
IkReal x438=(x414*x422);
evalcond[0]=((((0.0707403378672716)*x421*x424))+((x426*x428))+((x421*x437))+(((2.47744983270028e-7)*cj17))+(((-1.0)*x420*x437))+(((0.0707403378672716)*pz*sj17*x410))+(((-1.0)*x426*x427))+((sj17*x420*x427))+(((-1.0)*x425*x429))+(((-1.0)*x424*x425))+(((-1.0)*x418*x428))+(((-0.0800000013421189)*sj17))+((x417*x429))+((x417*x424)));
evalcond[1]=((((-1.0)*x430*x431))+(((0.00640000021473902)*x412))+(((-1.9799832183937)*x424*x429*x432))+((x415*x436))+(((-0.282252466560236)*x422*x430))+(((-0.564504933120473)*x418*x426*x435))+(((-0.00640000021467764)*x412*x414))+(((-1.0)*x432*x436))+(((-3.96391979882109e-8)*cj17*sj17*x412))+(((-1.0)*x415*x431*x435))+(((-1.0)*x415*x416*x434))+((x431*x432*x435))+((x415*x423))+((x416*x432*x434))+(((0.564504933120473)*x430*x438))+(((-1.0)*x414*x419*x421*x435))+(((1.9799832183937)*x418*x426))+(((-0.00500419540157573)*x432))+(((-0.141126233280118)*x432*x435))+(((0.141126233280118)*x430))+(((1.9799832183937)*x415*x424*x429))+(((0.989991609196848)*x433))+(((-0.994995804598424)*x415))+(((-3.95996643678739)*x418*x422*x426))+(((1.9799832183937)*x430*x435))+(((-0.989991609196848)*x414*x432))+(((1.9799832183937)*x432*x438))+(((0.141126233280118)*x415*x435))+(((-1.9799832183937)*x422*x433))+(((-1.0)*x423*x432)));
IkReal x439=IKcos(j16);
IkReal x440=IKcos(j16);
IkReal x441=IKcos(j16);
IkReal x442=IKcos(j16);
IkReal x443=IKcos(j16);
IkReal x444=IKcos(j16);
IkReal x445=IKcos(j16);
IkReal x446=IKcos(j16);
IkReal x447=IKcos(j16);
IkReal x448=IKcos(j16);
IkReal x449=IKcos(j16);
IkReal x450=IKcos(j16);
IkReal x451=IKcos(j16);
IkReal x452=IKcos(j16);
IkReal x453=IKcos(j16);
IkReal x454=IKcos(j16);
IkReal x455=IKcos(j16);
IkReal x456=IKcos(j16);
IkReal x457=IKcos(j16);
IkReal x458=IKcos(j16);
IkReal x459=IKcos(j16);
evalcond[2]=((0.00640000021473902)+(((-0.989991609196848)*(cj15*cj15)*(px*px)*(x439*x439)))+(((0.989991609196848)*(px*px)*(x440*x440)))+(((-0.564504933120473)*cj15*cj17*py*pz*sj17*(IKcos(j16))*(IKsin(j16))))+(((0.141126233280118)*cj15*py*pz))+(((-1.9799832183937)*cj15*px*py*sj15*(cj17*cj17)))+(((-0.282252466560236)*cj15*py*pz*(x441*x441)))+(((-1.9799832183937)*(cj17*cj17)*(px*px)*(x442*x442)))+(((-0.994995804598424)*(px*px)))+(((0.989991609196848)*(cj17*cj17)*(px*px)))+(((0.989991609196848)*(cj15*cj15)*(cj17*cj17)*(py*py)))+(((-0.141126233280118)*(pz*pz)*(IKcos(j16))*(IKsin(j16))))+(((-0.00640000021467764)*(cj17*cj17)))+(((1.9799832183937)*(cj15*cj15)*(cj17*cj17)*(px*px)*(x443*x443)))+(((0.282252466560236)*px*pz*sj15*(x444*x444)))+(((0.564504933120473)*cj15*cj17*px*py*sj15*sj17*(x445*x445)))+(((0.994995804598424)*(cj15*cj15)*(px*px)))+(((-3.95996643678739)*cj15*cj17*px*py*sj15*sj17*(IKcos(j16))*(IKsin(j16))))+(((1.9799832183937)*cj17*sj17*(px*px)*(IKcos(j16))*(IKsin(j16))))+(((-0.141126233280118)*cj17*sj17*(cj15*cj15)*(px*px)))+(((0.564504933120473)*cj17*px*pz*sj15*sj17*(IKcos(j16))*(IKsin(j16))))+(((0.282252466560236)*(cj17*cj17)*(pz*pz)*(IKcos(j16))*(IKsin(j16))))+(((3.95996643678739)*cj15*px*py*sj15*(cj17*cj17)*(x446*x446)))+(((-0.282252466560236)*cj15*py*pz*(cj17*cj17)))+(((-1.9799832183937)*cj17*sj17*(pz*pz)*(IKcos(j16))*(IKsin(j16))))+(((0.564504933120473)*cj15*px*py*sj15*(cj17*cj17)*(IKcos(j16))*(IKsin(j16))))+(((3.95996643678739)*cj17*px*pz*sj15*sj17*(x447*x447)))+(((-0.989991609196848)*(cj15*cj15)*(cj17*cj17)*(px*px)))+(((0.141126233280118)*cj17*sj17*(cj15*cj15)*(py*py)))+(((0.282252466560236)*px*pz*sj15*(cj17*cj17)))+(((-1.9799832183937)*cj17*sj17*(cj15*cj15)*(px*px)*(IKcos(j16))*(IKsin(j16))))+(((-0.282252466560236)*(cj17*cj17)*(px*px)*(IKcos(j16))*(IKsin(j16))))+(((-0.282252466560236)*cj15*cj17*px*py*sj15*sj17))+(((-0.564504933120473)*px*pz*sj15*(cj17*cj17)*(x448*x448)))+(((-0.00500419540157573)*(pz*pz)))+(((-1.9799832183937)*cj15*px*py*sj15*(x449*x449)))+(((0.564504933120473)*cj15*py*pz*(cj17*cj17)*(x450*x450)))+(((1.9799832183937)*cj15*cj17*py*pz*sj17))+(((3.95996643678739)*px*pz*sj15*(cj17*cj17)*(IKcos(j16))*(IKsin(j16))))+(((-3.95996643678739)*cj15*py*pz*(cj17*cj17)*(IKcos(j16))*(IKsin(j16))))+(((1.9799832183937)*cj15*py*pz*(IKcos(j16))*(IKsin(j16))))+(((-0.989991609196848)*(cj17*cj17)*(pz*pz)))+(((0.282252466560236)*cj17*sj17*(cj15*cj15)*(px*px)*(x451*x451)))+(((-0.141126233280118)*cj17*sj17*(pz*pz)))+(((0.282252466560236)*(cj15*cj15)*(cj17*cj17)*(px*px)*(IKcos(j16))*(IKsin(j16))))+(((-0.141126233280118)*px*pz*sj15))+(((-3.95996643678739)*cj15*cj17*py*pz*sj17*(x452*x452)))+(((-1.9799832183937)*(cj15*cj15)*(cj17*cj17)*(py*py)*(x453*x453)))+(((-0.994995804598424)*(cj15*cj15)*(py*py)))+(((-0.141126233280118)*(cj15*cj15)*(px*px)*(IKcos(j16))*(IKsin(j16))))+(((-0.282252466560236)*cj17*sj17*(cj15*cj15)*(py*py)*(x454*x454)))+(((-0.282252466560236)*cj17*sj17*(px*px)*(x455*x455)))+(((1.98999160919685)*cj15*px*py*sj15))+(((-1.9799832183937)*cj17*px*pz*sj15*sj17))+(((-1.9799832183937)*px*pz*sj15*(IKcos(j16))*(IKsin(j16))))+(((1.9799832183937)*(cj17*cj17)*(pz*pz)*(x456*x456)))+(((0.141126233280118)*(cj15*cj15)*(py*py)*(IKcos(j16))*(IKsin(j16))))+(((1.9799832183937)*cj17*sj17*(cj15*cj15)*(py*py)*(IKcos(j16))*(IKsin(j16))))+(((-0.989991609196848)*(pz*pz)*(x457*x457)))+(((-0.282252466560236)*cj15*px*py*sj15*(IKcos(j16))*(IKsin(j16))))+(((0.141126233280118)*cj17*sj17*(px*px)))+(((-0.282252466560236)*(cj15*cj15)*(cj17*cj17)*(py*py)*(IKcos(j16))*(IKsin(j16))))+(((-3.96391979882109e-8)*cj17*sj17))+(((0.141126233280118)*(px*px)*(IKcos(j16))*(IKsin(j16))))+(((0.989991609196848)*(cj15*cj15)*(py*py)*(x458*x458)))+(((0.282252466560236)*cj17*sj17*(pz*pz)*(x459*x459))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

IkReal soleval[1];
IkReal x460=((0.0707403378672716)*sj16);
IkReal x461=(cj16*pz);
IkReal x462=(((px*sj15))+(((-1.0)*cj15*py)));
IkReal x463=(sj16*x462);
IkReal x464=((0.997494764195995)*x462);
IkReal x465=(cj16*x462);
soleval[0]=((((-1.0)*sj17*(((-2.47744983270028e-7)+(((0.0707403378672716)*x461))+((x460*x462))+(((-0.997494764195995)*pz*sj16))+((cj16*x464))))))+((cj17*(((0.0800000013421189)+(((0.0707403378672716)*x465))+(((-1.0)*pz*x460))+(((-0.997494764195995)*x463))+(((-0.997494764195995)*x461)))))));
if( soleval[0] > 0.0000000000000000  )
{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(3);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j15;
vinfos[0].indices[0] = _ij15[0];
vinfos[0].indices[1] = _ij15[1];
vinfos[0].maxsolutions = _nj15;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j16;
vinfos[1].indices[0] = _ij16[0];
vinfos[1].indices[1] = _ij16[1];
vinfos[1].maxsolutions = _nj16;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j17;
vinfos[2].indices[0] = _ij17[0];
vinfos[2].indices[1] = _ij17[1];
vinfos[2].maxsolutions = _nj17;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
}
}

}

}
}
return solutions.GetNumSolutions()>0;
}

static inline void polyroots3(IkReal rawcoeffs[3+1], IkReal rawroots[3], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots2(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[3];
    const int maxsteps = 110;
    for(int i = 0; i < 3; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[3];
    IkReal err[3];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 3; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 3; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 3; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 3; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[3] = {false};
    for(int i = 0; i < 3; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 3; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots2(IkReal rawcoeffs[2+1], IkReal rawroots[2], int& numroots) {
    IkReal det = rawcoeffs[1]*rawcoeffs[1]-4*rawcoeffs[0]*rawcoeffs[2];
    if( det < 0 ) {
        numroots=0;
    }
    else if( det == 0 ) {
        rawroots[0] = -0.5*rawcoeffs[1]/rawcoeffs[0];
        numroots = 1;
    }
    else {
        det = IKsqrt(det);
        rawroots[0] = (-rawcoeffs[1]+det)/(2*rawcoeffs[0]);
        rawroots[1] = (-rawcoeffs[1]-det)/(2*rawcoeffs[0]);//rawcoeffs[2]/(rawcoeffs[0]*rawroots[0]);
        numroots = 2;
    }
}
static inline void polyroots4(IkReal rawcoeffs[4+1], IkReal rawroots[4], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots3(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[4];
    const int maxsteps = 110;
    for(int i = 0; i < 4; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[4];
    IkReal err[4];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 4; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 4; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 4; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 4; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[4] = {false};
    for(int i = 0; i < 4; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 4; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
};


/// solves the inverse kinematics equations.
/// \param pfree is an array specifying the free joints of the chain.
IKFAST_API bool ComputeIk(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions) {
IKSolver solver;
return solver.ComputeIk(eetrans,eerot,pfree,solutions);
}

IKFAST_API bool ComputeIk2(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions, void* pOpenRAVEManip) {
IKSolver solver;
return solver.ComputeIk(eetrans,eerot,pfree,solutions);
}

IKFAST_API const char* GetKinematicsHash() { return "ba4c7e89ca702944e857d4b29d0ccb7f"; }

IKFAST_API const char* GetIkFastVersion() { return "0x10000048"; }

#ifdef IKFAST_NAMESPACE
} // end namespace
#endif

#ifndef IKFAST_NO_MAIN
#include <stdio.h>
#include <stdlib.h>
#ifdef IKFAST_NAMESPACE
using namespace IKFAST_NAMESPACE;
#endif
int main(int argc, char** argv)
{
    if( argc != 12+GetNumFreeParameters()+1 ) {
        printf("\nUsage: ./ik r00 r01 r02 t0 r10 r11 r12 t1 r20 r21 r22 t2 free0 ...\n\n"
               "Returns the ik solutions given the transformation of the end effector specified by\n"
               "a 3x3 rotation R (rXX), and a 3x1 translation (tX).\n"
               "There are %d free parameters that have to be specified.\n\n",GetNumFreeParameters());
        return 1;
    }

    IkSolutionList<IkReal> solutions;
    std::vector<IkReal> vfree(GetNumFreeParameters());
    IkReal eerot[9],eetrans[3];
    eerot[0] = atof(argv[1]); eerot[1] = atof(argv[2]); eerot[2] = atof(argv[3]); eetrans[0] = atof(argv[4]);
    eerot[3] = atof(argv[5]); eerot[4] = atof(argv[6]); eerot[5] = atof(argv[7]); eetrans[1] = atof(argv[8]);
    eerot[6] = atof(argv[9]); eerot[7] = atof(argv[10]); eerot[8] = atof(argv[11]); eetrans[2] = atof(argv[12]);
    for(std::size_t i = 0; i < vfree.size(); ++i)
        vfree[i] = atof(argv[13+i]);
    bool bSuccess = ComputeIk(eetrans, eerot, vfree.size() > 0 ? &vfree[0] : NULL, solutions);

    if( !bSuccess ) {
        fprintf(stderr,"Failed to get ik solution\n");
        return -1;
    }

    printf("Found %d ik solutions:\n", (int)solutions.GetNumSolutions());
    std::vector<IkReal> solvalues(GetNumJoints());
    for(std::size_t i = 0; i < solutions.GetNumSolutions(); ++i) {
        const IkSolutionBase<IkReal>& sol = solutions.GetSolution(i);
        printf("sol%d (free=%d): ", (int)i, (int)sol.GetFree().size());
        std::vector<IkReal> vsolfree(sol.GetFree().size());
        sol.GetSolution(&solvalues[0],vsolfree.size()>0?&vsolfree[0]:NULL);
        for( std::size_t j = 0; j < solvalues.size(); ++j)
            printf("%.15f, ", solvalues[j]);
        printf("\n");
    }
    return 0;
}

#endif
